This is python.info, produced by makeinfo version 4.8 from python.texi.

Generated by Sphinx 1.6.3.
INFO-DIR-SECTION Python
START-INFO-DIR-ENTRY
* Python: (python.info). The Python reference manual.
END-INFO-DIR-ENTRY

     Python 2.7.13, July 15, 2017

     Copyright (C) 1990-2017, Python Software Foundation


File: python.info,  Node: IPC,  Up: Creating a Socket

10.10.2.1 IPC
.............

If you need fast IPC between two processes on one machine, you should
look into whatever form of shared memory the platform offers. A simple
protocol based around shared memory and locks or semaphores is by far
the fastest technique.

If you do decide to use sockets, bind the “server” socket to
`'localhost''. On most platforms, this will take a shortcut around a
couple of layers of network code and be quite a bit faster.


File: python.info,  Node: Using a Socket,  Next: Disconnecting,  Prev: Creating a Socket,  Up: Socket Programming HOWTO

10.10.3 Using a Socket
----------------------

The first thing to note, is that the web browser’s “client”
socket and the web server’s “client” socket are identical beasts.
That is, this is a “peer to peer” conversation. Or to put it
another way, `as the designer, you will have to decide what the rules
of etiquette are for a conversation'. Normally, the `connect'ing socket
starts the conversation, by sending in a request, or perhaps a signon.
But that’s a design decision - it’s not a rule of sockets.

Now there are two sets of verbs to use for communication. You can use
`send' and `recv', or you can transform your client socket into a
file-like beast and use `read' and `write'. The latter is the way Java
presents its sockets.  I’m not going to talk about it here, except to
warn you that you need to use `flush' on sockets. These are buffered
“files”, and a common mistake is to `write' something, and then
`read' for a reply. Without a `flush' in there, you may wait forever
for the reply, because the request may still be in your output buffer.

Now we come to the major stumbling block of sockets - `send' and `recv'
operate on the network buffers. They do not necessarily handle all the
bytes you hand them (or expect from them), because their major focus is
handling the network buffers. In general, they return when the
associated network buffers have been filled (`send') or emptied
(`recv'). They then tell you how many bytes they handled. It is `your'
responsibility to call them again until your message has been
completely dealt with.

When a `recv' returns 0 bytes, it means the other side has closed (or
is in the process of closing) the connection.  You will not receive any
more data on this connection. Ever.  You may be able to send data
successfully; I’ll talk more about this later.

A protocol like HTTP uses a socket for only one transfer. The client
sends a request, then reads a reply.  That’s it. The socket is
discarded. This means that a client can detect the end of the reply by
receiving 0 bytes.

But if you plan to reuse your socket for further transfers, you need to
realize that `there is no' EOT (End of Transfer) `on a socket.' I
repeat: if a socket `send' or `recv' returns after handling 0 bytes,
the connection has been broken.  If the connection has `not' been
broken, you may wait on a `recv' forever, because the socket will `not'
tell you that there’s nothing more to read (for now).  Now if you
think about that a bit, you’ll come to realize a fundamental truth of
sockets: `messages must either be fixed length' (yuck), `or be
delimited' (shrug), `or indicate how long they are' (much better), `or
end by shutting down the connection'. The choice is entirely yours,
(but some ways are righter than others).

Assuming you don’t want to end the connection, the simplest solution
is a fixed length message:

    class mysocket:
        '''demonstration class only
          - coded for clarity, not efficiency
        '''

        def __init__(self, sock=None):
            if sock is None:
                self.sock = socket.socket(
                    socket.AF_INET, socket.SOCK_STREAM)
            else:
                self.sock = sock

        def connect(self, host, port):
            self.sock.connect((host, port))

        def mysend(self, msg):
            totalsent = 0
            while totalsent < MSGLEN:
                sent = self.sock.send(msg[totalsent:])
                if sent == 0:
                    raise RuntimeError("socket connection broken")
                totalsent = totalsent + sent

        def myreceive(self):
            chunks = []
            bytes_recd = 0
            while bytes_recd < MSGLEN:
                chunk = self.sock.recv(min(MSGLEN - bytes_recd, 2048))
                if chunk == '':
                    raise RuntimeError("socket connection broken")
                chunks.append(chunk)
                bytes_recd = bytes_recd + len(chunk)
            return ''.join(chunks)

The sending code here is usable for almost any messaging scheme - in
Python you send strings, and you can use `len()' to determine its
length (even if it has embedded `\0' characters). It’s mostly the
receiving code that gets more complex. (And in C, it’s not much
worse, except you can’t use `strlen' if the message has embedded
`\0's.)

The easiest enhancement is to make the first character of the message an
indicator of message type, and have the type determine the length. Now
you have two `recv's - the first to get (at least) that first character
so you can look up the length, and the second in a loop to get the
rest. If you decide to go the delimited route, you’ll be receiving in
some arbitrary chunk size, (4096 or 8192 is frequently a good match for
network buffer sizes), and scanning what you’ve received for a
delimiter.

One complication to be aware of: if your conversational protocol allows
multiple messages to be sent back to back (without some kind of reply),
and you pass `recv' an arbitrary chunk size, you may end up reading the
start of a following message. You’ll need to put that aside and hold
onto it, until it’s needed.

Prefixing the message with its length (say, as 5 numeric characters)
gets more complex, because (believe it or not), you may not get all 5
characters in one `recv'. In playing around, you’ll get away with it;
but in high network loads, your code will very quickly break unless you
use two `recv' loops - the first to determine the length, the second to
get the data part of the message. Nasty.  This is also when you’ll
discover that `send' does not always manage to get rid of everything in
one pass. And despite having read this, you will eventually get bit by
it!

In the interests of space, building your character, (and preserving my
competitive position), these enhancements are left as an exercise for
the reader. Lets move on to cleaning up.

* Menu:

* Binary Data::


File: python.info,  Node: Binary Data,  Up: Using a Socket

10.10.3.1 Binary Data
.....................

It is perfectly possible to send binary data over a socket. The major
problem is that not all machines use the same formats for binary data.
For example, a Motorola chip will represent a 16 bit integer with the
value 1 as the two hex bytes 00 01. Intel and DEC, however, are
byte-reversed - that same 1 is 01 00.  Socket libraries have calls for
converting 16 and 32 bit integers - `ntohl, htonl, ntohs, htons' where
“n” means `network' and “h” means `host', “s” means `short'
and “l” means `long'. Where network order is host order, these do
nothing, but where the machine is byte-reversed, these swap the bytes
around appropriately.

In these days of 32 bit machines, the ascii representation of binary
data is frequently smaller than the binary representation. That’s
because a surprising amount of the time, all those longs have the value
0, or maybe 1. The string “0” would be two bytes, while binary is
four. Of course, this doesn’t fit well with fixed-length messages.
Decisions, decisions.


File: python.info,  Node: Disconnecting,  Next: Non-blocking Sockets,  Prev: Using a Socket,  Up: Socket Programming HOWTO

10.10.4 Disconnecting
---------------------

Strictly speaking, you’re supposed to use `shutdown' on a socket
before you `close' it.  The `shutdown' is an advisory to the socket at
the other end.  Depending on the argument you pass it, it can mean
“I’m not going to send anymore, but I’ll still listen”, or
“I’m not listening, good riddance!”.  Most socket libraries,
however, are so used to programmers neglecting to use this piece of
etiquette that normally a `close' is the same as `shutdown(); close()'.
So in most situations, an explicit `shutdown' is not needed.

One way to use `shutdown' effectively is in an HTTP-like exchange. The
client sends a request and then does a `shutdown(1)'. This tells the
server “This client is done sending, but can still receive.”  The
server can detect “EOF” by a receive of 0 bytes. It can assume it
has the complete request.  The server sends a reply. If the `send'
completes successfully then, indeed, the client was still receiving.

Python takes the automatic shutdown a step further, and says that when
a socket is garbage collected, it will automatically do a `close' if
it’s needed. But relying on this is a very bad habit. If your socket
just disappears without doing a `close', the socket at the other end
may hang indefinitely, thinking you’re just being slow. `Please'
`close' your sockets when you’re done.

* Menu:

* When Sockets Die::


File: python.info,  Node: When Sockets Die,  Up: Disconnecting

10.10.4.1 When Sockets Die
..........................

Probably the worst thing about using blocking sockets is what happens
when the other side comes down hard (without doing a `close'). Your
socket is likely to hang. SOCKSTREAM is a reliable protocol, and it
will wait a long, long time before giving up on a connection. If
you’re using threads, the entire thread is essentially dead.
There’s not much you can do about it. As long as you aren’t doing
something dumb, like holding a lock while doing a blocking read, the
thread isn’t really consuming much in the way of resources. Do `not'
try to kill the thread - part of the reason that threads are more
efficient than processes is that they avoid the overhead associated
with the automatic recycling of resources. In other words, if you do
manage to kill the thread, your whole process is likely to be screwed
up.


File: python.info,  Node: Non-blocking Sockets,  Prev: Disconnecting,  Up: Socket Programming HOWTO

10.10.5 Non-blocking Sockets
----------------------------

If you’ve understood the preceding, you already know most of what you
need to know about the mechanics of using sockets. You’ll still use
the same calls, in much the same ways. It’s just that, if you do it
right, your app will be almost inside-out.

In Python, you use `socket.setblocking(0)' to make it non-blocking. In
C, it’s more complex, (for one thing, you’ll need to choose between
the BSD flavor `O_NONBLOCK' and the almost indistinguishable Posix
flavor `O_NDELAY', which is completely different from `TCP_NODELAY'),
but it’s the exact same idea. You do this after creating the socket,
but before using it. (Actually, if you’re nuts, you can switch back
and forth.)

The major mechanical difference is that `send', `recv', `connect' and
`accept' can return without having done anything. You have (of course) a
number of choices. You can check return code and error codes and
generally drive yourself crazy. If you don’t believe me, try it
sometime. Your app will grow large, buggy and suck CPU. So let’s skip
the brain-dead solutions and do it right.

Use `select'.

In C, coding `select' is fairly complex. In Python, it’s a piece of
cake, but it’s close enough to the C version that if you understand
`select' in Python, you’ll have little trouble with it in C:

    ready_to_read, ready_to_write, in_error = \
                   select.select(
                      potential_readers,
                      potential_writers,
                      potential_errs,
                      timeout)

You pass `select' three lists: the first contains all sockets that you
might want to try reading; the second all the sockets you might want to
try writing to, and the last (normally left empty) those that you want
to check for errors.  You should note that a socket can go into more
than one list. The `select' call is blocking, but you can give it a
timeout. This is generally a sensible thing to do - give it a nice long
timeout (say a minute) unless you have good reason to do otherwise.

In return, you will get three lists. They contain the sockets that are
actually readable, writable and in error. Each of these lists is a
subset (possibly empty) of the corresponding list you passed in.

If a socket is in the output readable list, you can be
as-close-to-certain-as-we-ever-get-in-this-business that a `recv' on
that socket will return `something'. Same idea for the writable list.
You’ll be able to send `something'. Maybe not all you want to, but
`something' is better than nothing.  (Actually, any reasonably healthy
socket will return as writable - it just means outbound network buffer
space is available.)

If you have a “server” socket, put it in the potential_readers
list. If it comes out in the readable list, your `accept' will (almost
certainly) work. If you have created a new socket to `connect' to
someone else, put it in the potential_writers list. If it shows up in
the writable list, you have a decent chance that it has connected.

One very nasty problem with `select': if somewhere in those input lists
of sockets is one which has died a nasty death, the `select' will fail.
You then need to loop through every single damn socket in all those
lists and do a `select([sock],[],[],0)' until you find the bad one.
That timeout of 0 means it won’t take long, but it’s ugly.

Actually, `select' can be handy even with blocking sockets. It’s one
way of determining whether you will block - the socket returns as
readable when there’s something in the buffers.  However, this still
doesn’t help with the problem of determining whether the other end is
done, or just busy with something else.

`Portability alert': On Unix, `select' works both with the sockets and
files. Don’t try this on Windows. On Windows, `select' works with
sockets only. Also note that in C, many of the more advanced socket
options are done differently on Windows. In fact, on Windows I usually
use threads (which work very, very well) with my sockets. Face it, if
you want any kind of performance, your code will look very different on
Windows than on Unix.

* Menu:

* Performance: Performance<2>.


File: python.info,  Node: Performance<2>,  Up: Non-blocking Sockets

10.10.5.1 Performance
.....................

There’s no question that the fastest sockets code uses non-blocking
sockets and select to multiplex them. You can put together something
that will saturate a LAN connection without putting any strain on the
CPU. The trouble is that an app written this way can’t do much of
anything else - it needs to be ready to shuffle bytes around at all
times.

Assuming that your app is actually supposed to do something more than
that, threading is the optimal solution, (and using non-blocking
sockets will be faster than using blocking sockets). Unfortunately,
threading support in Unixes varies both in API and quality. So the
normal Unix solution is to fork a subprocess to deal with each
connection. The overhead for this is significant (and don’t do this
on Windows - the overhead of process creation is enormous there). It
also means that unless each subprocess is completely independent,
you’ll need to use another form of IPC, say a pipe, or shared memory
and semaphores, to communicate between the parent and child processes.

Finally, remember that even though blocking sockets are somewhat slower
than non-blocking, in many cases they are the “right” solution.
After all, if your app is driven by the data it receives over a socket,
there’s not much sense in complicating the logic just so your app can
wait on `select' instead of `recv'.


File: python.info,  Node: Sorting HOW TO,  Next: Unicode HOWTO,  Prev: Socket Programming HOWTO,  Up: Python HOWTOs

10.11 Sorting HOW TO
====================

Author: Andrew Dalke and Raymond Hettinger

Release: 0.1

Python lists have a built-in `list.sort()' method that modifies the list
in-place.  There is also a *Note sorted(): 223. built-in function that
builds a new sorted list from an iterable.

In this document, we explore the various techniques for sorting data
using Python.

* Menu:

* Sorting Basics::
* Key Functions::
* Operator Module Functions::
* Ascending and Descending::
* Sort Stability and Complex Sorts::
* The Old Way Using Decorate-Sort-Undecorate::
* The Old Way Using the cmp Parameter::
* Odd and Ends::


File: python.info,  Node: Sorting Basics,  Next: Key Functions,  Up: Sorting HOW TO

10.11.1 Sorting Basics
----------------------

A simple ascending sort is very easy: just call the *Note sorted():
223. function. It returns a new sorted list:

    >>> sorted([5, 2, 3, 1, 4])
    [1, 2, 3, 4, 5]

You can also use the `list.sort()' method of a list. It modifies the
list in-place (and returns `None' to avoid confusion). Usually it’s
less convenient than *Note sorted(): 223. - but if you don’t need the
original list, it’s slightly more efficient.

    >>> a = [5, 2, 3, 1, 4]
    >>> a.sort()
    >>> a
    [1, 2, 3, 4, 5]

Another difference is that the `list.sort()' method is only defined for
lists. In contrast, the *Note sorted(): 223. function accepts any
iterable.

    >>> sorted({1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'})
    [1, 2, 3, 4, 5]


File: python.info,  Node: Key Functions,  Next: Operator Module Functions,  Prev: Sorting Basics,  Up: Sorting HOW TO

10.11.2 Key Functions
---------------------

Starting with Python 2.4, both `list.sort()' and *Note sorted(): 223.
added a `key' parameter to specify a function to be called on each list
element prior to making comparisons.

For example, here’s a case-insensitive string comparison:

    >>> sorted("This is a test string from Andrew".split(), key=str.lower)
    ['a', 'Andrew', 'from', 'is', 'string', 'test', 'This']

The value of the `key' parameter should be a function that takes a
single argument and returns a key to use for sorting purposes. This
technique is fast because the key function is called exactly once for
each input record.

A common pattern is to sort complex objects using some of the
object’s indices as keys. For example:

    >>> student_tuples = [
    ...     ('john', 'A', 15),
    ...     ('jane', 'B', 12),
    ...     ('dave', 'B', 10),
    ... ]
    >>> sorted(student_tuples, key=lambda student: student[2])   # sort by age
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

The same technique works for objects with named attributes. For example:

    >>> class Student:
    ...     def __init__(self, name, grade, age):
    ...         self.name = name
    ...         self.grade = grade
    ...         self.age = age
    ...     def __repr__(self):
    ...         return repr((self.name, self.grade, self.age))

    >>> student_objects = [
    ...     Student('john', 'A', 15),
    ...     Student('jane', 'B', 12),
    ...     Student('dave', 'B', 10),
    ... ]
    >>> sorted(student_objects, key=lambda student: student.age)   # sort by age
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]


File: python.info,  Node: Operator Module Functions,  Next: Ascending and Descending,  Prev: Key Functions,  Up: Sorting HOW TO

10.11.3 Operator Module Functions
---------------------------------

The key-function patterns shown above are very common, so Python
provides convenience functions to make accessor functions easier and
faster. The operator module has *Note operator.itemgetter(): e16, *Note
operator.attrgetter(): e15, and starting in Python 2.5 an *Note
operator.methodcaller(): e17. function.

Using those functions, the above examples become simpler and faster:

    >>> from operator import itemgetter, attrgetter

    >>> sorted(student_tuples, key=itemgetter(2))
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

    >>> sorted(student_objects, key=attrgetter('age'))
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

The operator module functions allow multiple levels of sorting. For
example, to sort by `grade' then by `age':

    >>> sorted(student_tuples, key=itemgetter(1,2))
    [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

    >>> sorted(student_objects, key=attrgetter('grade', 'age'))
    [('john', 'A', 15), ('dave', 'B', 10), ('jane', 'B', 12)]

The *Note operator.methodcaller(): e17. function makes method calls
with fixed parameters for each object being sorted.  For example, the
*Note str.count(): 8e5.  method could be used to compute message
priority by counting the number of exclamation marks in a message:

    >>> from operator import methodcaller
    >>> messages = ['critical!!!', 'hurry!', 'standby', 'immediate!!']
    >>> sorted(messages, key=methodcaller('count', '!'))
    ['standby', 'hurry!', 'immediate!!', 'critical!!!']


File: python.info,  Node: Ascending and Descending,  Next: Sort Stability and Complex Sorts,  Prev: Operator Module Functions,  Up: Sorting HOW TO

10.11.4 Ascending and Descending
--------------------------------

Both `list.sort()' and *Note sorted(): 223. accept a `reverse'
parameter with a boolean value. This is used to flag descending sorts.
For example, to get the student data in reverse `age' order:

    >>> sorted(student_tuples, key=itemgetter(2), reverse=True)
    [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

    >>> sorted(student_objects, key=attrgetter('age'), reverse=True)
    [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]


File: python.info,  Node: Sort Stability and Complex Sorts,  Next: The Old Way Using Decorate-Sort-Undecorate,  Prev: Ascending and Descending,  Up: Sorting HOW TO

10.11.5 Sort Stability and Complex Sorts
----------------------------------------

Starting with Python 2.2, sorts are guaranteed to be stable(1). That
means that when multiple records have the same key, their original
order is preserved.

    >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
    >>> sorted(data, key=itemgetter(0))
    [('blue', 1), ('blue', 2), ('red', 1), ('red', 2)]

Notice how the two records for `blue' retain their original order so
that `('blue', 1)' is guaranteed to precede `('blue', 2)'.

This wonderful property lets you build complex sorts in a series of
sorting steps. For example, to sort the student data by descending
`grade' and then ascending `age', do the `age' sort first and then sort
again using `grade':

    >>> s = sorted(student_objects, key=attrgetter('age'))     # sort on secondary key
    >>> sorted(s, key=attrgetter('grade'), reverse=True)       # now sort on primary key, descending
    [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

The Timsort(2) algorithm used in Python does multiple sorts efficiently
because it can take advantage of any ordering already present in a
dataset.

---------- Footnotes ----------

(1) https://en.wikipedia.org/wiki/Sorting_algorithm#Stability

(2) https://en.wikipedia.org/wiki/Timsort


File: python.info,  Node: The Old Way Using Decorate-Sort-Undecorate,  Next: The Old Way Using the cmp Parameter,  Prev: Sort Stability and Complex Sorts,  Up: Sorting HOW TO

10.11.6 The Old Way Using Decorate-Sort-Undecorate
--------------------------------------------------

This idiom is called Decorate-Sort-Undecorate after its three steps:

   * First, the initial list is decorated with new values that control
     the sort order.

   * Second, the decorated list is sorted.

   * Finally, the decorations are removed, creating a list that
     contains only the initial values in the new order.

For example, to sort the student data by `grade' using the DSU approach:

    >>> decorated = [(student.grade, i, student) for i, student in enumerate(student_objects)]
    >>> decorated.sort()
    >>> [student for grade, i, student in decorated]               # undecorate
    [('john', 'A', 15), ('jane', 'B', 12), ('dave', 'B', 10)]

This idiom works because tuples are compared lexicographically; the
first items are compared; if they are the same then the second items
are compared, and so on.

It is not strictly necessary in all cases to include the index `i' in
the decorated list, but including it gives two benefits:

   * The sort is stable – if two items have the same key, their order
     will be preserved in the sorted list.

   * The original items do not have to be comparable because the
     ordering of the decorated tuples will be determined by at most the
     first two items. So for example the original list could contain
     complex numbers which cannot be sorted directly.

Another name for this idiom is Schwartzian transform(1), after Randal
L. Schwartz, who popularized it among Perl programmers.

For large lists and lists where the comparison information is expensive
to calculate, and Python versions before 2.4, DSU is likely to be the
fastest way to sort the list. For 2.4 and later, key functions provide
the same functionality.

---------- Footnotes ----------

(1) https://en.wikipedia.org/wiki/Schwartzian_transform


File: python.info,  Node: The Old Way Using the cmp Parameter,  Next: Odd and Ends,  Prev: The Old Way Using Decorate-Sort-Undecorate,  Up: Sorting HOW TO

10.11.7 The Old Way Using the `cmp' Parameter
---------------------------------------------

Many constructs given in this HOWTO assume Python 2.4 or later. Before
that, there was no *Note sorted(): 223. builtin and `list.sort()' took
no keyword arguments. Instead, all of the Py2.x versions supported a
`cmp' parameter to handle user specified comparison functions.

In Python 3, the `cmp' parameter was removed entirely (as part of a
larger effort to simplify and unify the language, eliminating the
conflict between rich comparisons and the *Note __cmp__(): 221. magic
method).

In Python 2, `sort()' allowed an optional function which can be called
for doing the comparisons. That function should take two arguments to
be compared and then return a negative value for less-than, return zero
if they are equal, or return a positive value for greater-than. For
example, we can do:

    >>> def numeric_compare(x, y):
    ...     return x - y
    >>> sorted([5, 2, 4, 1, 3], cmp=numeric_compare) # doctest: +SKIP
    [1, 2, 3, 4, 5]

Or you can reverse the order of comparison with:

    >>> def reverse_numeric(x, y):
    ...     return y - x
    >>> sorted([5, 2, 4, 1, 3], cmp=reverse_numeric) # doctest: +SKIP
    [5, 4, 3, 2, 1]

When porting code from Python 2.x to 3.x, the situation can arise when
you have the user supplying a comparison function and you need to
convert that to a key function. The following wrapper makes that easy
to do:

    def cmp_to_key(mycmp):
        'Convert a cmp= function into a key= function'
        class K(object):
            def __init__(self, obj, *args):
                self.obj = obj
            def __lt__(self, other):
                return mycmp(self.obj, other.obj) < 0
            def __gt__(self, other):
                return mycmp(self.obj, other.obj) > 0
            def __eq__(self, other):
                return mycmp(self.obj, other.obj) == 0
            def __le__(self, other):
                return mycmp(self.obj, other.obj) <= 0
            def __ge__(self, other):
                return mycmp(self.obj, other.obj) >= 0
            def __ne__(self, other):
                return mycmp(self.obj, other.obj) != 0
        return K

To convert to a key function, just wrap the old comparison function:

    >>> sorted([5, 2, 4, 1, 3], key=cmp_to_key(reverse_numeric))
    [5, 4, 3, 2, 1]

In Python 2.7, the *Note functools.cmp_to_key(): 222. function was
added to the functools module.


File: python.info,  Node: Odd and Ends,  Prev: The Old Way Using the cmp Parameter,  Up: Sorting HOW TO

10.11.8 Odd and Ends
--------------------

   * For locale aware sorting, use *Note locale.strxfrm(): 20d1. for a
     key function or *Note locale.strcoll(): 20cf. for a comparison
     function.

   * The `reverse' parameter still maintains sort stability (so that
     records with equal keys retain their original order).
     Interestingly, that effect can be simulated without the parameter
     by using the builtin *Note reversed(): 411. function twice:

         >>> data = [('red', 1), ('blue', 1), ('red', 2), ('blue', 2)]
         >>> standard_way = sorted(data, key=itemgetter(0), reverse=True)
         >>> double_reversed = list(reversed(sorted(reversed(data), key=itemgetter(0))))
         >>> assert standard_way == double_reversed
         >>> standard_way
         [('red', 1), ('red', 2), ('blue', 1), ('blue', 2)]

   * To create a standard sort order for a class, just add the
     appropriate rich comparison methods:

         >>> Student.__eq__ = lambda self, other: self.age == other.age
         >>> Student.__ne__ = lambda self, other: self.age != other.age
         >>> Student.__lt__ = lambda self, other: self.age < other.age
         >>> Student.__le__ = lambda self, other: self.age <= other.age
         >>> Student.__gt__ = lambda self, other: self.age > other.age
         >>> Student.__ge__ = lambda self, other: self.age >= other.age
         >>> sorted(student_objects)
         [('dave', 'B', 10), ('jane', 'B', 12), ('john', 'A', 15)]

     For general purpose comparisons, the recommended approach is to
     define all six rich comparison operators.  The *Note
     functools.total_ordering(): 21b. class decorator makes this easy
     to implement.

   * Key functions need not depend directly on the objects being
     sorted. A key function can also access external resources. For
     instance, if the student grades are stored in a dictionary, they
     can be used to sort a separate list of student names:

         >>> students = ['dave', 'john', 'jane']
         >>> grades = {'john': 'F', 'jane':'A', 'dave': 'C'}
         >>> sorted(students, key=grades.__getitem__)
         ['jane', 'dave', 'john']


File: python.info,  Node: Unicode HOWTO,  Next: HOWTO Fetch Internet Resources Using urllib2,  Prev: Sorting HOW TO,  Up: Python HOWTOs

10.12 Unicode HOWTO
===================

Release: 1.03

This HOWTO discusses Python 2.x’s support for Unicode, and explains
various problems that people commonly encounter when trying to work
with Unicode.  For the Python 3 version, see
<<https://docs.python.org/3/howto/unicode.html>>.

* Menu:

* Introduction to Unicode::
* Python 2.x’s Unicode Support: Python 2 x’s Unicode Support.
* Reading and Writing Unicode Data::
* Revision History and Acknowledgements: Revision History and Acknowledgements<2>.


File: python.info,  Node: Introduction to Unicode,  Next: Python 2 x’s Unicode Support,  Up: Unicode HOWTO

10.12.1 Introduction to Unicode
-------------------------------

* Menu:

* History of Character Codes::
* Definitions::
* Encodings::
* References: References<2>.


File: python.info,  Node: History of Character Codes,  Next: Definitions,  Up: Introduction to Unicode

10.12.1.1 History of Character Codes
....................................

In 1968, the American Standard Code for Information Interchange, better
known by its acronym ASCII, was standardized.  ASCII defined numeric
codes for various characters, with the numeric values running from 0 to
127.  For example, the lowercase letter ‘a’ is assigned 97 as its
code value.

ASCII was an American-developed standard, so it only defined unaccented
characters.  There was an ‘e’, but no ‘é’ or ‘Í’.  This
meant that languages which required accented characters couldn’t be
faithfully represented in ASCII.  (Actually the missing accents matter
for English, too, which contains words such as ‘naïve’ and
‘café’, and some publications have house styles which require
spellings such as ‘coöperate’.)

For a while people just wrote programs that didn’t display accents.
I remember looking at Apple ][ BASIC programs, published in
French-language publications in the mid-1980s, that had lines like
these:

    PRINT "MISE A JOUR TERMINEE"
    PRINT "PARAMETRES ENREGISTRES"

Those messages should contain accents, and they just look wrong to
someone who can read French.

In the 1980s, almost all personal computers were 8-bit, meaning that
bytes could hold values ranging from 0 to 255.  ASCII codes only went
up to 127, so some machines assigned values between 128 and 255 to
accented characters.  Different machines had different codes, however,
which led to problems exchanging files.  Eventually various commonly
used sets of values for the 128–255 range emerged.  Some were true
standards, defined by the International Standards Organization, and
some were `de facto' conventions that were invented by one company or
another and managed to catch on.

255 characters aren’t very many.  For example, you can’t fit both
the accented characters used in Western Europe and the Cyrillic
alphabet used for Russian into the 128–255 range because there are
more than 128 such characters.

You could write files using different codes (all your Russian files in
a coding system called KOI8, all your French files in a different
coding system called Latin1), but what if you wanted to write a French
document that quotes some Russian text?  In the 1980s people began to
want to solve this problem, and the Unicode standardization effort
began.

Unicode started out using 16-bit characters instead of 8-bit
characters.  16 bits means you have 2^16 = 65,536 distinct values
available, making it possible to represent many different characters
from many different alphabets; an initial goal was to have Unicode
contain the alphabets for every single human language.  It turns out
that even 16 bits isn’t enough to meet that goal, and the modern
Unicode specification uses a wider range of codes, 0–1,114,111
(0x10ffff in base-16).

There’s a related ISO standard, ISO 10646.  Unicode and ISO 10646 were
originally separate efforts, but the specifications were merged with
the 1.1 revision of Unicode.

(This discussion of Unicode’s history is highly simplified.  I
don’t think the average Python programmer needs to worry about the
historical details; consult the Unicode consortium site listed in the
References for more information.)


File: python.info,  Node: Definitions,  Next: Encodings,  Prev: History of Character Codes,  Up: Introduction to Unicode

10.12.1.2 Definitions
.....................

A `character' is the smallest possible component of a text.  ‘A’,
‘B’, ‘C’, etc., are all different characters.  So are ‘È’
and ‘Í’.  Characters are abstractions, and vary depending on the
language or context you’re talking about.  For example, the symbol
for ohms (Ω) is usually drawn much like the capital letter omega (Ω)
in the Greek alphabet (they may even be the same in some fonts), but
these are two different characters that have different meanings.

The Unicode standard describes how characters are represented by `code
points'.  A code point is an integer value, usually denoted in base 16.
In the standard, a code point is written using the notation U+12ca to
mean the character with value 0x12ca (4810 decimal).  The Unicode
standard contains a lot of tables listing characters and their
corresponding code points:

    0061    'a'; LATIN SMALL LETTER A
    0062    'b'; LATIN SMALL LETTER B
    0063    'c'; LATIN SMALL LETTER C
    ...
    007B    '{'; LEFT CURLY BRACKET

Strictly, these definitions imply that it’s meaningless to say
‘this is character U+12ca’.  U+12ca is a code point, which
represents some particular character; in this case, it represents the
character ‘ETHIOPIC SYLLABLE WI’.  In informal contexts, this
distinction between code points and characters will sometimes be
forgotten.

A character is represented on a screen or on paper by a set of graphical
elements that’s called a `glyph'.  The glyph for an uppercase A, for
example, is two diagonal strokes and a horizontal stroke, though the
exact details will depend on the font being used.  Most Python code
doesn’t need to worry about glyphs; figuring out the correct glyph to
display is generally the job of a GUI toolkit or a terminal’s font
renderer.


File: python.info,  Node: Encodings,  Next: References<2>,  Prev: Definitions,  Up: Introduction to Unicode

10.12.1.3 Encodings
...................

To summarize the previous section: a Unicode string is a sequence of
code points, which are numbers from 0 to 0x10ffff.  This sequence needs
to be represented as a set of bytes (meaning, values from 0–255) in
memory.  The rules for translating a Unicode string into a sequence of
bytes are called an `encoding'.

The first encoding you might think of is an array of 32-bit integers.
In this representation, the string “Python” would look like this:

       P           y           t           h           o           n
    0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00
       0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23

This representation is straightforward but using it presents a number of
problems.

  1. It’s not portable; different processors order the bytes
     differently.

  2. It’s very wasteful of space.  In most texts, the majority of the
     code points are less than 127, or less than 255, so a lot of space
     is occupied by zero bytes.  The above string takes 24 bytes
     compared to the 6 bytes needed for an ASCII representation.
     Increased RAM usage doesn’t matter too much (desktop computers
     have megabytes of RAM, and strings aren’t usually that large),
     but expanding our usage of disk and network bandwidth by a factor
     of 4 is intolerable.

  3. It’s not compatible with existing C functions such as
     `strlen()', so a new family of wide string functions would need to
     be used.

  4. Many Internet standards are defined in terms of textual data, and
     can’t handle content with embedded zero bytes.

Generally people don’t use this encoding, instead choosing other
encodings that are more efficient and convenient.  UTF-8 is probably
the most commonly supported encoding; it will be discussed below.

Encodings don’t have to handle every possible Unicode character, and
most encodings don’t.  For example, Python’s default encoding is
the ‘ascii’ encoding.  The rules for converting a Unicode string
into the ASCII encoding are simple; for each code point:

  1. If the code point is < 128, each byte is the same as the value of
     the code point.

  2. If the code point is 128 or greater, the Unicode string can’t be
     represented in this encoding.  (Python raises a *Note
     UnicodeEncodeError: 981. exception in this case.)

Latin-1, also known as ISO-8859-1, is a similar encoding.  Unicode code
points 0–255 are identical to the Latin-1 values, so converting to
this encoding simply requires converting code points to byte values; if
a code point larger than 255 is encountered, the string can’t be
encoded into Latin-1.

Encodings don’t have to be simple one-to-one mappings like Latin-1.
Consider IBM’s EBCDIC, which was used on IBM mainframes.  Letter
values weren’t in one block: ‘a’ through ‘i’ had values from
129 to 137, but ‘j’ through ‘r’ were 145 through 153.  If you
wanted to use EBCDIC as an encoding, you’d probably use some sort of
lookup table to perform the conversion, but this is largely an internal
detail.

UTF-8 is one of the most commonly used encodings.  UTF stands for
“Unicode Transformation Format”, and the ‘8’ means that 8-bit
numbers are used in the encoding.  (There’s also a UTF-16 encoding,
but it’s less frequently used than UTF-8.)  UTF-8 uses the following
rules:

  1. If the code point is <128, it’s represented by the corresponding
     byte value.

  2. If the code point is between 128 and 0x7ff, it’s turned into two
     byte values between 128 and 255.

  3. Code points >0x7ff are turned into three- or four-byte sequences,
     where each byte of the sequence is between 128 and 255.

UTF-8 has several convenient properties:

  1. It can handle any Unicode code point.

  2. A Unicode string is turned into a string of bytes containing no
     embedded zero bytes.  This avoids byte-ordering issues, and means
     UTF-8 strings can be processed by C functions such as `strcpy()'
     and sent through protocols that can’t handle zero bytes.

  3. A string of ASCII text is also valid UTF-8 text.

  4. UTF-8 is fairly compact; the majority of code points are turned
     into two bytes, and values less than 128 occupy only a single byte.

  5. If bytes are corrupted or lost, it’s possible to determine the
     start of the next UTF-8-encoded code point and resynchronize.
     It’s also unlikely that random 8-bit data will look like valid
     UTF-8.


File: python.info,  Node: References<2>,  Prev: Encodings,  Up: Introduction to Unicode

10.12.1.4 References
....................

The Unicode Consortium site at <<http://www.unicode.org>> has character
charts, a glossary, and PDF versions of the Unicode specification.  Be
prepared for some difficult reading.
<<http://www.unicode.org/history/>> is a chronology of the origin and
development of Unicode.

To help understand the standard, Jukka Korpela has written an
introductory guide to reading the Unicode character tables, available at
<<https://www.cs.tut.fi/~jkorpela/unicode/guide.html>>.

Another good introductory article was written by Joel Spolsky
<<http://www.joelonsoftware.com/articles/Unicode.html>>.  If this
introduction didn’t make things clear to you, you should try reading
this alternate article before continuing.

Wikipedia entries are often helpful; see the entries for “character
encoding” <<http://en.wikipedia.org/wiki/Character_encoding>> and
UTF-8 <<http://en.wikipedia.org/wiki/UTF-8>>, for example.


File: python.info,  Node: Python 2 x’s Unicode Support,  Next: Reading and Writing Unicode Data,  Prev: Introduction to Unicode,  Up: Unicode HOWTO

10.12.2 Python 2.x’s Unicode Support
--------------------------------------

Now that you’ve learned the rudiments of Unicode, we can look at
Python’s Unicode features.

* Menu:

* The Unicode Type::
* Unicode Literals in Python Source Code::
* Unicode Properties::
* References: References<3>.


File: python.info,  Node: The Unicode Type,  Next: Unicode Literals in Python Source Code,  Up: Python 2 x’s Unicode Support

10.12.2.1 The Unicode Type
..........................

Unicode strings are expressed as instances of the *Note unicode: 1f5.
type, one of Python’s repertoire of built-in types.  It derives from
an abstract type called *Note basestring: 474, which is also an
ancestor of the *Note str: 1ea. type; you can therefore check if a
value is a string type with `isinstance(value, basestring)'.  Under the
hood, Python represents Unicode strings as either 16- or 32-bit
integers, depending on how the Python interpreter was compiled.

The *Note unicode(): 1f5. constructor has the signature
`unicode(string[, encoding, errors])'.  All of its arguments should be
8-bit strings.  The first argument is converted to Unicode using the
specified encoding; if you leave off the `encoding' argument, the ASCII
encoding is used for the conversion, so characters greater than 127
will be treated as errors:

    >>> unicode('abcdef')
    u'abcdef'
    >>> s = unicode('abcdef')
    >>> type(s)
    <type 'unicode'>
    >>> unicode('abcdef' + chr(255))    #doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
    ...
    UnicodeDecodeError: 'ascii' codec can't decode byte 0xff in position 6:
    ordinal not in range(128)

The `errors' argument specifies the response when the input string
can’t be converted according to the encoding’s rules.  Legal values
for this argument are ‘strict’ (raise a `UnicodeDecodeError'
exception), ‘replace’ (add U+FFFD, ‘REPLACEMENT CHARACTER’), or
‘ignore’ (just leave the character out of the Unicode result).  The
following examples show the differences:

    >>> unicode('\x80abc', errors='strict')     #doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    UnicodeDecodeError: 'ascii' codec can't decode byte 0x80 in position 0:
    ordinal not in range(128)
    >>> unicode('\x80abc', errors='replace')
    u'\ufffdabc'
    >>> unicode('\x80abc', errors='ignore')
    u'abc'

Encodings are specified as strings containing the encoding’s name.
Python 2.7 comes with roughly 100 different encodings; see the Python
Library Reference at *Note Standard Encodings: 8e8. for a list.  Some
encodings have multiple names; for example, ‘latin-1’,
‘iso_8859_1’ and ‘8859’ are all synonyms for the same encoding.

One-character Unicode strings can also be created with the *Note
unichr(): 4b1.  built-in function, which takes integers and returns a
Unicode string of length 1 that contains the corresponding code point.
The reverse operation is the built-in *Note ord(): 71f. function that
takes a one-character Unicode string and returns the code point value:

    >>> unichr(40960)
    u'\ua000'
    >>> ord(u'\ua000')
    40960

Instances of the *Note unicode: 1f5. type have many of the same methods
as the 8-bit string type for operations such as searching and
formatting:

    >>> s = u'Was ever feather so lightly blown to and fro as this multitude?'
    >>> s.count('e')
    5
    >>> s.find('feather')
    9
    >>> s.find('bird')
    -1
    >>> s.replace('feather', 'sand')
    u'Was ever sand so lightly blown to and fro as this multitude?'
    >>> s.upper()
    u'WAS EVER FEATHER SO LIGHTLY BLOWN TO AND FRO AS THIS MULTITUDE?'

Note that the arguments to these methods can be Unicode strings or 8-bit
strings.  8-bit strings will be converted to Unicode before carrying
out the operation; Python’s default ASCII encoding will be used, so
characters greater than 127 will cause an exception:

    >>> s.find('Was\x9f')                   #doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    UnicodeDecodeError: 'ascii' codec can't decode byte 0x9f in position 3:
    ordinal not in range(128)
    >>> s.find(u'Was\x9f')
    -1

Much Python code that operates on strings will therefore work with
Unicode strings without requiring any changes to the code.  (Input and
output code needs more updating for Unicode; more on this later.)

Another important method is `.encode([encoding], [errors='strict'])',
which returns an 8-bit string version of the Unicode string, encoded in
the requested encoding.  The `errors' parameter is the same as the
parameter of the `unicode()' constructor, with one additional
possibility; as well as ‘strict’, ‘ignore’, and ‘replace’,
you can also pass ‘xmlcharrefreplace’ which uses XML’s character
references.  The following example shows the different results:

    >>> u = unichr(40960) + u'abcd' + unichr(1972)
    >>> u.encode('utf-8')
    '\xea\x80\x80abcd\xde\xb4'
    >>> u.encode('ascii')                       #doctest: +NORMALIZE_WHITESPACE
    Traceback (most recent call last):
        ...
    UnicodeEncodeError: 'ascii' codec can't encode character u'\ua000' in
    position 0: ordinal not in range(128)
    >>> u.encode('ascii', 'ignore')
    'abcd'
    >>> u.encode('ascii', 'replace')
    '?abcd?'
    >>> u.encode('ascii', 'xmlcharrefreplace')
    '&#40960;abcd&#1972;'

Python’s 8-bit strings have a `.decode([encoding], [errors])' method
that interprets the string using the given encoding:

    >>> u = unichr(40960) + u'abcd' + unichr(1972)   # Assemble a string
    >>> utf8_version = u.encode('utf-8')             # Encode as UTF-8
    >>> type(utf8_version), utf8_version
    (<type 'str'>, '\xea\x80\x80abcd\xde\xb4')
    >>> u2 = utf8_version.decode('utf-8')            # Decode using UTF-8
    >>> u == u2                                      # The two strings match
    True

The low-level routines for registering and accessing the available
encodings are found in the *Note codecs: 63. module.  However, the
encoding and decoding functions returned by this module are usually
more low-level than is comfortable, so I’m not going to describe the
*Note codecs: 63. module here.  If you need to implement a completely
new encoding, you’ll need to learn about the *Note codecs: 63. module
interfaces, but implementing encodings is a specialized task that also
won’t be covered here.  Consult the Python documentation to learn
more about this module.

The most commonly used part of the *Note codecs: 63. module is the
*Note codecs.open(): a88. function which will be discussed in the
section on input and output.


File: python.info,  Node: Unicode Literals in Python Source Code,  Next: Unicode Properties,  Prev: The Unicode Type,  Up: Python 2 x’s Unicode Support

10.12.2.2 Unicode Literals in Python Source Code
................................................

In Python source code, Unicode literals are written as strings prefixed
with the ‘u’ or ‘U’ character: `u'abcdefghijk''.  Specific code
points can be written using the `\u' escape sequence, which is followed
by four hex digits giving the code point.  The `\U' escape sequence is
similar, but expects 8 hex digits, not 4.

Unicode literals can also use the same escape sequences as 8-bit
strings, including `\x', but `\x' only takes two hex digits so it
can’t express an arbitrary code point.  Octal escapes can go up to
U+01ff, which is octal 777.

    >>> s = u"a\xac\u1234\u20ac\U00008000"
    ... #      ^^^^ two-digit hex escape
    ... #          ^^^^^^ four-digit Unicode escape
    ... #                      ^^^^^^^^^^ eight-digit Unicode escape
    >>> for c in s:  print ord(c),
    ...
    97 172 4660 8364 32768

Using escape sequences for code points greater than 127 is fine in
small doses, but becomes an annoyance if you’re using many accented
characters, as you would in a program with messages in French or some
other accent-using language.  You can also assemble strings using the
*Note unichr(): 4b1. built-in function, but this is even more tedious.

Ideally, you’d want to be able to write literals in your language’s
natural encoding.  You could then edit Python source code with your
favorite editor which would display the accented characters naturally,
and have the right characters used at runtime.

Python supports writing Unicode literals in any encoding, but you have
to declare the encoding being used.  This is done by including a
special comment as either the first or second line of the source file:

    #!/usr/bin/env python
    # -*- coding: latin-1 -*-

    u = u'abcdé'
    print ord(u[-1])

The syntax is inspired by Emacs’s notation for specifying variables
local to a file.  Emacs supports many different variables, but Python
only supports ‘coding’.  The `-*-' symbols indicate to Emacs that
the comment is special; they have no significance to Python but are a
convention.  Python looks for `coding: name' or `coding=name' in the
comment.

If you don’t include such a comment, the default encoding used will
be ASCII.  Versions of Python before 2.4 were Euro-centric and assumed
Latin-1 as a default encoding for string literals; in Python 2.4,
characters greater than 127 still work but result in a warning.  For
example, the following program has no encoding declaration:

    #!/usr/bin/env python
    u = u'abcdé'
    print ord(u[-1])

When you run it with Python 2.4, it will output the following warning:

    amk:~$ python2.4 p263.py
    sys:1: DeprecationWarning: Non-ASCII character '\xe9'
         in file p263.py on line 2, but no encoding declared;
         see https://www.python.org/peps/pep-0263.html for details

Python 2.5 and higher are stricter and will produce a syntax error:

    amk:~$ python2.5 p263.py
    File "/tmp/p263.py", line 2
    SyntaxError: Non-ASCII character '\xc3' in file /tmp/p263.py
      on line 2, but no encoding declared; see
      https://www.python.org/peps/pep-0263.html for details


File: python.info,  Node: Unicode Properties,  Next: References<3>,  Prev: Unicode Literals in Python Source Code,  Up: Python 2 x’s Unicode Support

10.12.2.3 Unicode Properties
............................

The Unicode specification includes a database of information about code
points.  For each code point that’s defined, the information includes
the character’s name, its category, the numeric value if applicable
(Unicode has characters representing the Roman numerals and fractions
such as one-third and four-fifths).  There are also properties related
to the code point’s use in bidirectional text and other
display-related properties.

The following program displays some information about several
characters, and prints the numeric value of one particular character:

    import unicodedata

    u = unichr(233) + unichr(0x0bf2) + unichr(3972) + unichr(6000) + unichr(13231)

    for i, c in enumerate(u):
        print i, '%04x' % ord(c), unicodedata.category(c),
        print unicodedata.name(c)

    # Get numeric value of second character
    print unicodedata.numeric(u[1])

When run, this prints:

    0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE
    1 0bf2 No TAMIL NUMBER ONE THOUSAND
    2 0f84 Mn TIBETAN MARK HALANTA
    3 1770 Lo TAGBANWA LETTER SA
    4 33af So SQUARE RAD OVER S SQUARED
    1000.0

The category codes are abbreviations describing the nature of the
character.  These are grouped into categories such as “Letter”,
“Number”, “Punctuation”, or “Symbol”, which in turn are
broken up into subcategories.  To take the codes from the above output,
`'Ll'' means ‘Letter, lowercase’, `'No'' means “Number, other”,
`'Mn'' is “Mark, nonspacing”, and `'So'' is “Symbol, other”.
See <<http://www.unicode.org/reports/tr44/#General_Category_Values>>
for a list of category codes.


File: python.info,  Node: References<3>,  Prev: Unicode Properties,  Up: Python 2 x’s Unicode Support

10.12.2.4 References
....................

The Unicode and 8-bit string types are described in the Python library
reference at *Note Sequence Types — str, unicode, list, tuple,
bytearray, buffer, xrange: 53d.

The documentation for the *Note unicodedata: 186. module.

The documentation for the *Note codecs: 63. module.

Marc-André Lemburg gave a presentation at EuroPython 2002 titled
“Python and Unicode”.  A PDF version of his slides is available at
<<https://downloads.egenix.com/python/Unicode-EPC2002-Talk.pdf>>, and
is an excellent overview of the design of Python’s Unicode features.


File: python.info,  Node: Reading and Writing Unicode Data,  Next: Revision History and Acknowledgements<2>,  Prev: Python 2 x’s Unicode Support,  Up: Unicode HOWTO

10.12.3 Reading and Writing Unicode Data
----------------------------------------

Once you’ve written some code that works with Unicode data, the next
problem is input/output.  How do you get Unicode strings into your
program, and how do you convert Unicode into a form suitable for
storage or transmission?

It’s possible that you may not need to do anything depending on your
input sources and output destinations; you should check whether the
libraries used in your application support Unicode natively.  XML
parsers often return Unicode data, for example.  Many relational
databases also support Unicode-valued columns and can return Unicode
values from an SQL query.

Unicode data is usually converted to a particular encoding before it
gets written to disk or sent over a socket.  It’s possible to do all
the work yourself: open a file, read an 8-bit string from it, and
convert the string with `unicode(str, encoding)'.  However, the manual
approach is not recommended.

One problem is the multi-byte nature of encodings; one Unicode
character can be represented by several bytes.  If you want to read the
file in arbitrary-sized chunks (say, 1K or 4K), you need to write
error-handling code to catch the case where only part of the bytes
encoding a single Unicode character are read at the end of a chunk.
One solution would be to read the entire file into memory and then
perform the decoding, but that prevents you from working with files that
are extremely large; if you need to read a 2Gb file, you need 2Gb of
RAM.  (More, really, since for at least a moment you’d need to have
both the encoded string and its Unicode version in memory.)

The solution would be to use the low-level decoding interface to catch
the case of partial coding sequences.  The work of implementing this
has already been done for you: the *Note codecs: 63. module includes a
version of the *Note open(): 2d9.  function that returns a file-like
object that assumes the file’s contents are in a specified encoding
and accepts Unicode parameters for methods such as `.read()' and
`.write()'.

The function’s parameters are `open(filename, mode='rb',
encoding=None, errors='strict', buffering=1)'.  `mode' can be `'r'',
`'w'', or `'a'', just like the corresponding parameter to the regular
built-in `open()' function; add a `'+'' to update the file.
`buffering' is similarly parallel to the standard function’s
parameter.  `encoding' is a string giving the encoding to use; if
it’s left as `None', a regular Python file object that accepts 8-bit
strings is returned.  Otherwise, a wrapper object is returned, and data
written to or read from the wrapper object will be converted as needed.
`errors' specifies the action for encoding errors and can be one of the
usual values of ‘strict’, ‘ignore’, and ‘replace’.

Reading Unicode from a file is therefore simple:

    import codecs
    f = codecs.open('unicode.rst', encoding='utf-8')
    for line in f:
        print repr(line)

It’s also possible to open files in update mode, allowing both
reading and writing:

    f = codecs.open('test', encoding='utf-8', mode='w+')
    f.write(u'\u4500 blah blah blah\n')
    f.seek(0)
    print repr(f.readline()[:1])
    f.close()

Unicode character U+FEFF is used as a byte-order mark (BOM), and is
often written as the first character of a file in order to assist with
autodetection of the file’s byte ordering.  Some encodings, such as
UTF-16, expect a BOM to be present at the start of a file; when such an
encoding is used, the BOM will be automatically written as the first
character and will be silently dropped when the file is read.  There
are variants of these encodings, such as ‘utf-16-le’ and
‘utf-16-be’ for little-endian and big-endian encodings, that
specify one particular byte ordering and don’t skip the BOM.

* Menu:

* Unicode filenames::
* Tips for Writing Unicode-aware Programs::
* References: References<4>.


File: python.info,  Node: Unicode filenames,  Next: Tips for Writing Unicode-aware Programs,  Up: Reading and Writing Unicode Data

10.12.3.1 Unicode filenames
...........................

Most of the operating systems in common use today support filenames
that contain arbitrary Unicode characters.  Usually this is implemented
by converting the Unicode string into some encoding that varies
depending on the system.  For example, Mac OS X uses UTF-8 while
Windows uses a configurable encoding; on Windows, Python uses the name
“mbcs” to refer to whatever the currently configured encoding is.
On Unix systems, there will only be a filesystem encoding if you’ve
set the `LANG' or `LC_CTYPE' environment variables; if you haven’t,
the default encoding is ASCII.

The *Note sys.getfilesystemencoding(): 1012. function returns the
encoding to use on your current system, in case you want to do the
encoding manually, but there’s not much reason to bother.  When
opening a file for reading or writing, you can usually just provide the
Unicode string as the filename, and it will be automatically converted
to the right encoding for you:

    filename = u'filename\u4500abc'
    f = open(filename, 'w')
    f.write('blah\n')
    f.close()

Functions in the *Note os: 129. module such as *Note os.stat(): 3de.
will also accept Unicode filenames.

*Note os.listdir(): 2d5, which returns filenames, raises an issue:
should it return the Unicode version of filenames, or should it return
8-bit strings containing the encoded versions?  *Note os.listdir():
2d5. will do both, depending on whether you provided the directory path
as an 8-bit string or a Unicode string.  If you pass a Unicode string
as the path, filenames will be decoded using the filesystem’s
encoding and a list of Unicode strings will be returned, while passing
an 8-bit path will return the 8-bit versions of the filenames.  For
example, assuming the default filesystem encoding is UTF-8, running the
following program:

    fn = u'filename\u4500abc'
    f = open(fn, 'w')
    f.close()

    import os
    print os.listdir('.')
    print os.listdir(u'.')

will produce the following output:

    amk:~$ python t.py
    ['.svn', 'filename\xe4\x94\x80abc', ...]
    [u'.svn', u'filename\u4500abc', ...]

The first list contains UTF-8-encoded filenames, and the second list
contains the Unicode versions.


File: python.info,  Node: Tips for Writing Unicode-aware Programs,  Next: References<4>,  Prev: Unicode filenames,  Up: Reading and Writing Unicode Data

10.12.3.2 Tips for Writing Unicode-aware Programs
.................................................

This section provides some suggestions on writing software that deals
with Unicode.

The most important tip is:

     Software should only work with Unicode strings internally,
     converting to a particular encoding on output.

If you attempt to write processing functions that accept both Unicode
and 8-bit strings, you will find your program vulnerable to bugs
wherever you combine the two different kinds of strings.  Python’s
default encoding is ASCII, so whenever a character with an ASCII value
> 127 is in the input data, you’ll get a *Note UnicodeDecodeError:
982. because that character can’t be handled by the ASCII encoding.

It’s easy to miss such problems if you only test your software with
data that doesn’t contain any accents; everything will seem to work,
but there’s actually a bug in your program waiting for the first user
who attempts to use characters > 127.  A second tip, therefore, is:

     Include characters > 127 and, even better, characters > 255 in
     your test data.

When using data coming from a web browser or some other untrusted
source, a common technique is to check for illegal characters in a
string before using the string in a generated command line or storing
it in a database.  If you’re doing this, be careful to check the
string once it’s in the form that will be used or stored; it’s
possible for encodings to be used to disguise characters.  This is
especially true if the input data also specifies the encoding; many
encodings leave the commonly checked-for characters alone, but Python
includes some encodings such as `'base64'' that modify every single
character.

For example, let’s say you have a content management system that
takes a Unicode filename, and you want to disallow paths with a ‘/’
character.  You might write this code:

    def read_file (filename, encoding):
        if '/' in filename:
            raise ValueError("'/' not allowed in filenames")
        unicode_name = filename.decode(encoding)
        f = open(unicode_name, 'r')
        # ... return contents of file ...

However, if an attacker could specify the `'base64'' encoding, they
could pass `'L2V0Yy9wYXNzd2Q='', which is the base-64 encoded form of
the string `'/etc/passwd'', to read a system file.  The above code
looks for `'/'' characters in the encoded form and misses the dangerous
character in the resulting decoded form.


File: python.info,  Node: References<4>,  Prev: Tips for Writing Unicode-aware Programs,  Up: Reading and Writing Unicode Data

10.12.3.3 References
....................

The PDF slides for Marc-André Lemburg’s presentation “Writing
Unicode-aware Applications in Python” are available at
<<https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-applications-in-Python.pdf>>
and discuss questions of character encodings as well as how to
internationalize and localize an application.


File: python.info,  Node: Revision History and Acknowledgements<2>,  Prev: Reading and Writing Unicode Data,  Up: Unicode HOWTO

10.12.4 Revision History and Acknowledgements
---------------------------------------------

Thanks to the following people who have noted errors or offered
suggestions on this article: Nicholas Bastin, Marius Gedminas, Kent
Johnson, Ken Krugler, Marc-André Lemburg, Martin von Löwis, Chad
Whitacre.

Version 1.0: posted August 5 2005.

Version 1.01: posted August 7 2005.  Corrects factual and markup
errors; adds several links.

Version 1.02: posted August 16 2005.  Corrects factual errors.

Version 1.03: posted June 20 2010.  Notes that Python 3.x is not
covered, and that the HOWTO only covers 2.x.


File: python.info,  Node: HOWTO Fetch Internet Resources Using urllib2,  Next: HOWTO Use Python in the web,  Prev: Unicode HOWTO,  Up: Python HOWTOs

10.13 HOWTO Fetch Internet Resources Using urllib2
==================================================

Author: Michael Foord(1)

     Note: There is a French translation of an earlier revision of this
     HOWTO, available at urllib2 - Le Manuel manquant(2).

* Menu:

* Introduction: Introduction<13>.
* Fetching URLs::
* Handling Exceptions: Handling Exceptions<2>.
* info and geturl::
* Openers and Handlers::
* Basic Authentication::
* Proxies::
* Sockets and Layers::
* Footnotes::

---------- Footnotes ----------

(1) http://www.voidspace.org.uk/python/index.shtml

(2) http://www.voidspace.org.uk/python/articles/urllib2_francais.shtml


File: python.info,  Node: Introduction<13>,  Next: Fetching URLs,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.1 Introduction
--------------------

Related Articles
................

You may also find useful the following article on fetching web resources
with Python:

   * Basic Authentication(1)

          A tutorial on `Basic Authentication', with examples in Python.

`urllib2' is a Python module for fetching URLs (Uniform Resource
Locators). It offers a very simple interface, in the form of the
`urlopen' function. This is capable of fetching URLs using a variety of
different protocols. It also offers a slightly more complex interface
for handling common situations - like basic authentication, cookies,
proxies and so on. These are provided by objects called handlers and
openers.

urllib2 supports fetching URLs for many “URL schemes” (identified
by the string before the “:” in URL - for example “ftp” is the
URL scheme of “<ftp://python.org/>”) using their associated network
protocols (e.g. FTP, HTTP).  This tutorial focuses on the most common
case, HTTP.

For straightforward situations `urlopen' is very easy to use. But as
soon as you encounter errors or non-trivial cases when opening HTTP
URLs, you will need some understanding of the HyperText Transfer
Protocol. The most comprehensive and authoritative reference to HTTP is RFC
2616(2). This is a technical document and not intended to be easy to
read. This HOWTO aims to illustrate using `urllib2', with enough detail
about HTTP to help you through. It is not intended to replace the *Note
urllib2: 189. docs, but is supplementary to them.

---------- Footnotes ----------

(1) http://www.voidspace.org.uk/python/articles/authentication.shtml

(2) https://tools.ietf.org/html/rfc2616.html


File: python.info,  Node: Fetching URLs,  Next: Handling Exceptions<2>,  Prev: Introduction<13>,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.2 Fetching URLs
---------------------

The simplest way to use urllib2 is as follows:

    import urllib2
    response = urllib2.urlopen('http://python.org/')
    html = response.read()

Many uses of urllib2 will be that simple (note that instead of an
‘http:’ URL we could have used a URL starting with ‘ftp:’,
‘file:’, etc.).  However, it’s the purpose of this tutorial to
explain the more complicated cases, concentrating on HTTP.

HTTP is based on requests and responses - the client makes requests and
servers send responses. urllib2 mirrors this with a `Request' object
which represents the HTTP request you are making. In its simplest form
you create a Request object that specifies the URL you want to fetch.
Calling `urlopen' with this Request object returns a response object
for the URL requested. This response is a file-like object, which means
you can for example call `.read()' on the response:

    import urllib2

    req = urllib2.Request('http://www.voidspace.org.uk')
    response = urllib2.urlopen(req)
    the_page = response.read()

Note that urllib2 makes use of the same Request interface to handle all
URL schemes.  For example, you can make an FTP request like so:

    req = urllib2.Request('ftp://example.com/')

In the case of HTTP, there are two extra things that Request objects
allow you to do: First, you can pass data to be sent to the server.
Second, you can pass extra information (“metadata”) `about' the
data or the about request itself, to the server - this information is
sent as HTTP “headers”.  Let’s look at each of these in turn.

* Menu:

* Data::
* Headers::


File: python.info,  Node: Data,  Next: Headers,  Up: Fetching URLs

10.13.2.1 Data
..............

Sometimes you want to send data to a URL (often the URL will refer to a
CGI (Common Gateway Interface) script (1) or other web application).
With HTTP, this is often done using what’s known as a `POST' request.
This is often what your browser does when you submit a HTML form that
you filled in on the web. Not all POSTs have to come from forms: you
can use a POST to transmit arbitrary data to your own application. In
the common case of HTML forms, the data needs to be encoded in a
standard way, and then passed to the Request object as the `data'
argument. The encoding is done using a function from the `urllib'
library `not' from `urllib2'.

    import urllib
    import urllib2

    url = 'http://www.someserver.com/cgi-bin/register.cgi'
    values = {'name' : 'Michael Foord',
              'location' : 'Northampton',
              'language' : 'Python' }

    data = urllib.urlencode(values)
    req = urllib2.Request(url, data)
    response = urllib2.urlopen(req)
    the_page = response.read()

Note that other encodings are sometimes required (e.g. for file upload
from HTML forms - see HTML Specification, Form Submission(2) for more
details).

If you do not pass the `data' argument, urllib2 uses a `GET' request.
One way in which GET and POST requests differ is that POST requests
often have “side-effects”: they change the state of the system in
some way (for example by placing an order with the website for a
hundredweight of tinned spam to be delivered to your door).  Though the
HTTP standard makes it clear that POSTs are intended to `always' cause
side-effects, and GET requests `never' to cause side-effects, nothing
prevents a GET request from having side-effects, nor a POST requests
from having no side-effects. Data can also be passed in an HTTP GET
request by encoding it in the URL itself.

This is done as follows:

    >>> import urllib2
    >>> import urllib
    >>> data = {}
    >>> data['name'] = 'Somebody Here'
    >>> data['location'] = 'Northampton'
    >>> data['language'] = 'Python'
    >>> url_values = urllib.urlencode(data)
    >>> print url_values  # The order may differ. #doctest: +SKIP
    name=Somebody+Here&language=Python&location=Northampton
    >>> url = 'http://www.example.com/example.cgi'
    >>> full_url = url + '?' + url_values
    >>> data = urllib2.urlopen(full_url)

Notice that the full URL is created by adding a `?' to the URL,
followed by the encoded values.

---------- Footnotes ----------

(1) For an introduction to the CGI protocol see Writing Web
Applications in Python
(http://www.pyzine.com/Issue008/Section_Articles/article_CGIOne.html).

(2) https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13


File: python.info,  Node: Headers,  Prev: Data,  Up: Fetching URLs

10.13.2.2 Headers
.................

We’ll discuss here one particular HTTP header, to illustrate how to
add headers to your HTTP request.

Some websites (1) dislike being browsed by programs, or send different
versions to different browsers (2). By default urllib2 identifies
itself as `Python-urllib/x.y' (where `x' and `y' are the major and
minor version numbers of the Python release, e.g. `Python-urllib/2.5'),
which may confuse the site, or just plain not work. The way a browser
identifies itself is through the `User-Agent' header (3). When you
create a Request object you can pass a dictionary of headers in. The
following example makes the same request as above, but identifies
itself as a version of Internet Explorer (4).

    import urllib
    import urllib2

    url = 'http://www.someserver.com/cgi-bin/register.cgi'
    user_agent = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64)'
    values = {'name': 'Michael Foord',
              'location': 'Northampton',
              'language': 'Python' }
    headers = {'User-Agent': user_agent}

    data = urllib.urlencode(values)
    req = urllib2.Request(url, data, headers)
    response = urllib2.urlopen(req)
    the_page = response.read()

The response also has two useful methods. See the section on *Note info
and geturl: 3035.  which comes after we have a look at what happens
when things go wrong.

---------- Footnotes ----------

(1) Google for example.

(2) Browser sniffing is a very bad practice for website design -
building sites using web standards is much more sensible. Unfortunately
a lot of sites still send different versions to different browsers.

(3) The user agent for MSIE 6 is `‘Mozilla/4.0 (compatible; MSIE 6.0;
Windows NT 5.1; SV1; .NET CLR 1.1.4322)’'

(4) For details of more HTTP request headers, see Quick Reference to
HTTP Headers (https://www.cs.tut.fi/~jkorpela/http.html).


File: python.info,  Node: Handling Exceptions<2>,  Next: info and geturl,  Prev: Fetching URLs,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.3 Handling Exceptions
---------------------------

`urlopen' raises `URLError' when it cannot handle a response (though as
usual with Python APIs, built-in exceptions such as *Note ValueError:
236, *Note TypeError: 218. etc. may also be raised).

`HTTPError' is the subclass of `URLError' raised in the specific case of
HTTP URLs.

* Menu:

* URLError::
* HTTPError::
* Wrapping it Up::


File: python.info,  Node: URLError,  Next: HTTPError,  Up: Handling Exceptions<2>

10.13.3.1 URLError
..................

Often, URLError is raised because there is no network connection (no
route to the specified server), or the specified server doesn’t
exist.  In this case, the exception raised will have a ‘reason’
attribute, which is a tuple containing an error code and a text error
message.

e.g.

    >>> req = urllib2.Request('http://www.pretend_server.org')
    >>> try: urllib2.urlopen(req)
    ... except URLError as e:
    ...    print e.reason   #doctest: +SKIP
    ...
    (4, 'getaddrinfo failed')


File: python.info,  Node: HTTPError,  Next: Wrapping it Up,  Prev: URLError,  Up: Handling Exceptions<2>

10.13.3.2 HTTPError
...................

Every HTTP response from the server contains a numeric “status
code”. Sometimes the status code indicates that the server is unable
to fulfil the request. The default handlers will handle some of these
responses for you (for example, if the response is a “redirection”
that requests the client fetch the document from a different URL,
urllib2 will handle that for you). For those it can’t handle, urlopen
will raise an `HTTPError'. Typical errors include ‘404’ (page not
found), ‘403’ (request forbidden), and ‘401’ (authentication
required).

See section 10 of RFC 2616 for a reference on all the HTTP error codes.

The `HTTPError' instance raised will have an integer ‘code’
attribute, which corresponds to the error sent by the server.

* Menu:

* Error Codes::


File: python.info,  Node: Error Codes,  Up: HTTPError

10.13.3.3 Error Codes
.....................

Because the default handlers handle redirects (codes in the 300 range),
and codes in the 100–299 range indicate success, you will usually
only see error codes in the 400–599 range.

`BaseHTTPServer.BaseHTTPRequestHandler.responses' is a useful
dictionary of response codes in that shows all the response codes used
by RFC 2616. The dictionary is reproduced here for convenience

    # Table mapping response codes to messages; entries have the
    # form {code: (shortmessage, longmessage)}.
    responses = {
        100: ('Continue', 'Request received, please continue'),
        101: ('Switching Protocols',
              'Switching to new protocol; obey Upgrade header'),

        200: ('OK', 'Request fulfilled, document follows'),
        201: ('Created', 'Document created, URL follows'),
        202: ('Accepted',
              'Request accepted, processing continues off-line'),
        203: ('Non-Authoritative Information', 'Request fulfilled from cache'),
        204: ('No Content', 'Request fulfilled, nothing follows'),
        205: ('Reset Content', 'Clear input form for further input.'),
        206: ('Partial Content', 'Partial content follows.'),

        300: ('Multiple Choices',
              'Object has several resources -- see URI list'),
        301: ('Moved Permanently', 'Object moved permanently -- see URI list'),
        302: ('Found', 'Object moved temporarily -- see URI list'),
        303: ('See Other', 'Object moved -- see Method and URL list'),
        304: ('Not Modified',
              'Document has not changed since given time'),
        305: ('Use Proxy',
              'You must use proxy specified in Location to access this '
              'resource.'),
        307: ('Temporary Redirect',
              'Object moved temporarily -- see URI list'),

        400: ('Bad Request',
              'Bad request syntax or unsupported method'),
        401: ('Unauthorized',
              'No permission -- see authorization schemes'),
        402: ('Payment Required',
              'No payment -- see charging schemes'),
        403: ('Forbidden',
              'Request forbidden -- authorization will not help'),
        404: ('Not Found', 'Nothing matches the given URI'),
        405: ('Method Not Allowed',
              'Specified method is invalid for this server.'),
        406: ('Not Acceptable', 'URI not available in preferred format.'),
        407: ('Proxy Authentication Required', 'You must authenticate with '
              'this proxy before proceeding.'),
        408: ('Request Timeout', 'Request timed out; try again later.'),
        409: ('Conflict', 'Request conflict.'),
        410: ('Gone',
              'URI no longer exists and has been permanently removed.'),
        411: ('Length Required', 'Client must specify Content-Length.'),
        412: ('Precondition Failed', 'Precondition in headers is false.'),
        413: ('Request Entity Too Large', 'Entity is too large.'),
        414: ('Request-URI Too Long', 'URI is too long.'),
        415: ('Unsupported Media Type', 'Entity body in unsupported format.'),
        416: ('Requested Range Not Satisfiable',
              'Cannot satisfy request range.'),
        417: ('Expectation Failed',
              'Expect condition could not be satisfied.'),

        500: ('Internal Server Error', 'Server got itself in trouble'),
        501: ('Not Implemented',
              'Server does not support this operation'),
        502: ('Bad Gateway', 'Invalid responses from another server/proxy.'),
        503: ('Service Unavailable',
              'The server cannot process the request due to a high load'),
        504: ('Gateway Timeout',
              'The gateway server did not receive a timely response'),
        505: ('HTTP Version Not Supported', 'Cannot fulfill request.'),
        }

When an error is raised the server responds by returning an HTTP error
code `and' an error page. You can use the `HTTPError' instance as a
response on the page returned. This means that as well as the code
attribute, it also has read, geturl, and info, methods.

    >>> req = urllib2.Request('http://www.python.org/fish.html')
    >>> try:
    ...     urllib2.urlopen(req)
    ... except urllib2.HTTPError as e:
    ...     print e.code
    ...     print e.read() #doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
    ...
    404
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
    ...
    <title>Page Not Found</title>
    ...


File: python.info,  Node: Wrapping it Up,  Prev: HTTPError,  Up: Handling Exceptions<2>

10.13.3.4 Wrapping it Up
........................

So if you want to be prepared for `HTTPError' `or' `URLError' there are
two basic approaches. I prefer the second approach.

* Menu:

* Number 1::
* Number 2::


File: python.info,  Node: Number 1,  Next: Number 2,  Up: Wrapping it Up

10.13.3.5 Number 1
..................

    from urllib2 import Request, urlopen, URLError, HTTPError
    req = Request(someurl)
    try:
        response = urlopen(req)
    except HTTPError as e:
        print 'The server couldn\'t fulfill the request.'
        print 'Error code: ', e.code
    except URLError as e:
        print 'We failed to reach a server.'
        print 'Reason: ', e.reason
    else:
        # everything is fine

     Note: The `except HTTPError' `must' come first, otherwise `except
     URLError' will `also' catch an `HTTPError'.


File: python.info,  Node: Number 2,  Prev: Number 1,  Up: Wrapping it Up

10.13.3.6 Number 2
..................

    from urllib2 import Request, urlopen, URLError
    req = Request(someurl)
    try:
        response = urlopen(req)
    except URLError as e:
        if hasattr(e, 'reason'):
            print 'We failed to reach a server.'
            print 'Reason: ', e.reason
        elif hasattr(e, 'code'):
            print 'The server couldn\'t fulfill the request.'
            print 'Error code: ', e.code
    else:
        # everything is fine


File: python.info,  Node: info and geturl,  Next: Openers and Handlers,  Prev: Handling Exceptions<2>,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.4 info and geturl
-----------------------

The response returned by urlopen (or the `HTTPError' instance) has two
useful methods `info()' and `geturl()'.

`geturl' - this returns the real URL of the page fetched. This is useful
because `urlopen' (or the opener object used) may have followed a
redirect. The URL of the page fetched may not be the same as the URL
requested.

`info' - this returns a dictionary-like object that describes the page
fetched, particularly the headers sent by the server. It is currently an
`httplib.HTTPMessage' instance.

Typical headers include ‘Content-length’, ‘Content-type’, and
so on. See the Quick Reference to HTTP Headers(1) for a useful listing
of HTTP headers with brief explanations of their meaning and use.

---------- Footnotes ----------

(1) https://www.cs.tut.fi/~jkorpela/http.html


File: python.info,  Node: Openers and Handlers,  Next: Basic Authentication,  Prev: info and geturl,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.5 Openers and Handlers
----------------------------

When you fetch a URL you use an opener (an instance of the perhaps
confusingly-named *Note urllib2.OpenerDirector: 1cf2.). Normally we
have been using the default opener - via `urlopen' - but you can create
custom openers. Openers use handlers. All the “heavy lifting” is
done by the handlers. Each handler knows how to open URLs for a
particular URL scheme (http, ftp, etc.), or how to handle an aspect of
URL opening, for example HTTP redirections or HTTP cookies.

You will want to create openers if you want to fetch URLs with specific
handlers installed, for example to get an opener that handles cookies,
or to get an opener that does not handle redirections.

To create an opener, instantiate an `OpenerDirector', and then call
`.add_handler(some_handler_instance)' repeatedly.

Alternatively, you can use `build_opener', which is a convenience
function for creating opener objects with a single function call.
`build_opener' adds several handlers by default, but provides a quick
way to add more and/or override the default handlers.

Other sorts of handlers you might want to can handle proxies,
authentication, and other common but slightly specialised situations.

`install_opener' can be used to make an `opener' object the (global)
default opener. This means that calls to `urlopen' will use the opener
you have installed.

Opener objects have an `open' method, which can be called directly to
fetch urls in the same way as the `urlopen' function: there’s no need
to call `install_opener', except as a convenience.


File: python.info,  Node: Basic Authentication,  Next: Proxies,  Prev: Openers and Handlers,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.6 Basic Authentication
----------------------------

To illustrate creating and installing a handler we will use the
`HTTPBasicAuthHandler'. For a more detailed discussion of this subject
– including an explanation of how Basic Authentication works - see
the Basic Authentication Tutorial(1).

When authentication is required, the server sends a header (as well as
the 401 error code) requesting authentication.  This specifies the
authentication scheme and a ‘realm’. The header looks like:
`WWW-Authenticate: SCHEME realm="REALM"'.

e.g.

    WWW-Authenticate: Basic realm="cPanel Users"

The client should then retry the request with the appropriate name and
password for the realm included as a header in the request. This is
‘basic authentication’. In order to simplify this process we can
create an instance of `HTTPBasicAuthHandler' and an opener to use this
handler.

The `HTTPBasicAuthHandler' uses an object called a password manager to
handle the mapping of URLs and realms to passwords and usernames. If
you know what the realm is (from the authentication header sent by the
server), then you can use a `HTTPPasswordMgr'. Frequently one doesn’t
care what the realm is. In that case, it is convenient to use
`HTTPPasswordMgrWithDefaultRealm'. This allows you to specify a default
username and password for a URL. This will be supplied in the absence
of you providing an alternative combination for a specific realm. We
indicate this by providing `None' as the realm argument to the
`add_password' method.

The top-level URL is the first URL that requires authentication. URLs
“deeper” than the URL you pass to .add_password() will also match.

    # create a password manager
    password_mgr = urllib2.HTTPPasswordMgrWithDefaultRealm()

    # Add the username and password.
    # If we knew the realm, we could use it instead of None.
    top_level_url = "http://example.com/foo/"
    password_mgr.add_password(None, top_level_url, username, password)

    handler = urllib2.HTTPBasicAuthHandler(password_mgr)

    # create "opener" (OpenerDirector instance)
    opener = urllib2.build_opener(handler)

    # use the opener to fetch a URL
    opener.open(a_url)

    # Install the opener.
    # Now all calls to urllib2.urlopen use our opener.
    urllib2.install_opener(opener)

     Note: In the above example we only supplied our
     `HTTPBasicAuthHandler' to `build_opener'. By default openers have
     the handlers for normal situations – `ProxyHandler' (if a proxy
     setting such as an `http_proxy' environment variable is set),
     `UnknownHandler', `HTTPHandler', `HTTPDefaultErrorHandler',
     `HTTPRedirectHandler', `FTPHandler', `FileHandler',
     `HTTPErrorProcessor'.

`top_level_url' is in fact `either' a full URL (including the
‘http:’ scheme component and the hostname and optionally the port
number) e.g. “<http://example.com/>” `or' an “authority” (i.e.
the hostname, optionally including the port number) e.g.
“example.com” or “example.com:8080” (the latter example
includes a port number).  The authority, if present, must NOT contain
the “userinfo” component - for example
“joe:password@example.com” is not correct.

---------- Footnotes ----------

(1) http://www.voidspace.org.uk/python/articles/authentication.shtml


File: python.info,  Node: Proxies,  Next: Sockets and Layers,  Prev: Basic Authentication,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.7 Proxies
---------------

`urllib2' will auto-detect your proxy settings and use those. This is
through the `ProxyHandler', which is part of the normal handler chain
when a proxy setting is detected.  Normally that’s a good thing, but
there are occasions when it may not be helpful (1). One way to do this
is to setup our own `ProxyHandler', with no proxies defined. This is
done using similar steps to setting up a Basic Authentication(2)
handler:

    >>> proxy_support = urllib2.ProxyHandler({})
    >>> opener = urllib2.build_opener(proxy_support)
    >>> urllib2.install_opener(opener)

     Note: Currently `urllib2' `does not' support fetching of `https'
     locations through a proxy.  However, this can be enabled by
     extending urllib2 as shown in the recipe (3).

     Note: `HTTP_PROXY' will be ignored if a variable `REQUEST_METHOD'
     is set; see the documentation on *Note getproxies(): 1ce4.

---------- Footnotes ----------

(1) In my case I have to use a proxy to access the internet at work. If
you attempt to fetch `localhost' URLs through this proxy it blocks
them. IE is set to use the proxy, which urllib2 picks up on. In order
to test scripts with a localhost server, I have to prevent urllib2 from
using the proxy.

(2) http://www.voidspace.org.uk/python/articles/authentication.shtml

(3) urllib2 opener for SSL proxy (CONNECT method): ASPN Cookbook Recipe
(https://code.activestate.com/recipes/456195/).


File: python.info,  Node: Sockets and Layers,  Next: Footnotes,  Prev: Proxies,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.8 Sockets and Layers
--------------------------

The Python support for fetching resources from the web is layered.
urllib2 uses the httplib library, which in turn uses the socket library.

As of Python 2.3 you can specify how long a socket should wait for a
response before timing out. This can be useful in applications which
have to fetch web pages. By default the socket module has `no timeout'
and can hang. Currently, the socket timeout is not exposed at the
httplib or urllib2 levels.  However, you can set the default timeout
globally for all sockets using

    import socket
    import urllib2

    # timeout in seconds
    timeout = 10
    socket.setdefaulttimeout(timeout)

    # this call to urllib2.urlopen now uses the default timeout
    # we have set in the socket module
    req = urllib2.Request('http://www.voidspace.org.uk')
    response = urllib2.urlopen(req)

__________________________________________________________________


File: python.info,  Node: Footnotes,  Prev: Sockets and Layers,  Up: HOWTO Fetch Internet Resources Using urllib2

10.13.9 Footnotes
-----------------

This document was reviewed and revised by John Lee.


File: python.info,  Node: HOWTO Use Python in the web,  Next: Argparse Tutorial,  Prev: HOWTO Fetch Internet Resources Using urllib2,  Up: Python HOWTOs

10.14 HOWTO Use Python in the web
=================================

Author: Marek Kubica

Abstract
........

This document shows how Python fits into the web.  It presents some ways
to integrate Python with a web server, and general practices useful for
developing web sites.

Programming for the Web has become a hot topic since the rise of “Web
2.0”, which focuses on user-generated content on web sites.  It has
always been possible to use Python for creating web sites, but it was a
rather tedious task.  Therefore, many frameworks and helper tools have
been created to assist developers in creating faster and more robust
sites.  This HOWTO describes some of the methods used to combine Python
with a web server to create dynamic content.  It is not meant as a
complete introduction, as this topic is far too broad to be covered in
one single document.  However, a short overview of the most popular
libraries is provided.

See also
........

While this HOWTO tries to give an overview of Python in the web, it
cannot always be as up to date as desired.  Web development in Python
is rapidly moving forward, so the wiki page on Web Programming(1) may
be more in sync with recent development.

* Menu:

* The Low-Level View::
* Step back; WSGI: Step back WSGI.
* Model-View-Controller::
* Ingredients for Websites::
* Frameworks::

---------- Footnotes ----------

(1) https://wiki.python.org/moin/WebProgramming


File: python.info,  Node: The Low-Level View,  Next: Step back WSGI,  Up: HOWTO Use Python in the web

10.14.1 The Low-Level View
--------------------------

When a user enters a web site, their browser makes a connection to the
site’s web server (this is called the `request').  The server looks
up the file in the file system and sends it back to the user’s
browser, which displays it (this is the `response').  This is roughly
how the underlying protocol, HTTP, works.

Dynamic web sites are not based on files in the file system, but rather
on programs which are run by the web server when a request comes in,
and which `generate' the content that is returned to the user.  They
can do all sorts of useful things, like display the postings of a
bulletin board, show your email, configure software, or just display
the current time.  These programs can be written in any programming
language the server supports.  Since most servers support Python, it is
easy to use Python to create dynamic web sites.

Most HTTP servers are written in C or C++, so they cannot execute
Python code directly – a bridge is needed between the server and the
program.  These bridges, or rather interfaces, define how programs
interact with the server.  There have been numerous attempts to create
the best possible interface, but there are only a few worth mentioning.

Not every web server supports every interface.  Many web servers only
support old, now-obsolete interfaces; however, they can often be
extended using third-party modules to support newer ones.

* Menu:

* Common Gateway Interface::
* mod_python::
* FastCGI and SCGI::
* mod_wsgi::


File: python.info,  Node: Common Gateway Interface,  Next: mod_python,  Up: The Low-Level View

10.14.1.1 Common Gateway Interface
..................................

This interface, most commonly referred to as “CGI”, is the oldest,
and is supported by nearly every web server out of the box.  Programs
using CGI to communicate with their web server need to be started by
the server for every request.  So, every request starts a new Python
interpreter – which takes some time to start up – thus making the
whole interface only usable for low load situations.

The upside of CGI is that it is simple – writing a Python program
which uses CGI is a matter of about three lines of code.  This
simplicity comes at a price: it does very few things to help the
developer.

Writing CGI programs, while still possible, is no longer recommended.
With *Note WSGI: 3046, a topic covered later in this document, it is
possible to write programs that emulate CGI, so they can be run as CGI
if no better option is available.

See also
........

The Python standard library includes some modules that are helpful for
creating plain CGI programs:

   * *Note cgi: 5c. – Handling of user input in CGI scripts

   * *Note cgitb: 5e. – Displays nice tracebacks when errors happen
     in CGI applications, instead of presenting a “500 Internal
     Server Error” message

The Python wiki features a page on CGI scripts(1) with some additional
information about CGI in Python.

* Menu:

* Simple script for testing CGI::
* Setting up CGI on your own server::
* Common problems with CGI scripts::

---------- Footnotes ----------

(1) https://wiki.python.org/moin/CgiScripts


File: python.info,  Node: Simple script for testing CGI,  Next: Setting up CGI on your own server,  Up: Common Gateway Interface

10.14.1.2 Simple script for testing CGI
.......................................

To test whether your web server works with CGI, you can use this short
and simple CGI program:

    #!/usr/bin/env python
    # -*- coding: UTF-8 -*-

    # enable debugging
    import cgitb
    cgitb.enable()

    print "Content-Type: text/plain;charset=utf-8"
    print

    print "Hello World!"

Depending on your web server configuration, you may need to save this
code with a `.py' or `.cgi' extension.  Additionally, this file may
also need to be in a `cgi-bin' folder, for security reasons.

You might wonder what the `cgitb' line is about.  This line makes it
possible to display a nice traceback instead of just crashing and
displaying an “Internal Server Error” in the user’s browser.
This is useful for debugging, but it might risk exposing some
confidential data to the user.  You should not use `cgitb' in
production code for this reason.  You should `always' catch exceptions,
and display proper error pages – end-users don’t like to see
nondescript “Internal Server Errors” in their browsers.


File: python.info,  Node: Setting up CGI on your own server,  Next: Common problems with CGI scripts,  Prev: Simple script for testing CGI,  Up: Common Gateway Interface

10.14.1.3 Setting up CGI on your own server
...........................................

If you don’t have your own web server, this does not apply to you.
You can check whether it works as-is, and if not you will need to talk
to the administrator of your web server. If it is a big host, you can
try filing a ticket asking for Python support.

If you are your own administrator or want to set up CGI for testing
purposes on your own computers, you have to configure it by yourself.
There is no single way to configure CGI, as there are many web servers
with different configuration options.  Currently the most widely used
free web server is Apache HTTPd(1), or Apache for short. Apache can be
easily installed on nearly every system using the system’s package
management tool.  lighttpd(2) is another alternative and is said to
have better performance.  On many systems this server can also be
installed using the package management tool, so manually compiling the
web server may not be needed.

   * On Apache you can take a look at the Dynamic Content with CGI(3)
     tutorial, where everything is described.  Most of the time it is
     enough just to set `+ExecCGI'.  The tutorial also describes the
     most common gotchas that might arise.

   * On lighttpd you need to use the CGI module(4), which can be
     configured in a straightforward way.  It boils down to setting
     `cgi.assign' properly.

---------- Footnotes ----------

(1) http://httpd.apache.org/

(2) http://www.lighttpd.net

(3) http://httpd.apache.org/docs/2.2/howto/cgi.html

(4) http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModCGI


File: python.info,  Node: Common problems with CGI scripts,  Prev: Setting up CGI on your own server,  Up: Common Gateway Interface

10.14.1.4 Common problems with CGI scripts
..........................................

Using CGI sometimes leads to small annoyances while trying to get these
scripts to run.  Sometimes a seemingly correct script does not work as
expected, the cause being some small hidden problem that’s difficult
to spot.

Some of these potential problems are:

   * The Python script is not marked as executable.  When CGI scripts
     are not executable most web servers will let the user download it,
     instead of running it and sending the output to the user.  For CGI
     scripts to run properly on Unix-like operating systems, the `+x'
     bit needs to be set.  Using `chmod a+x your_script.py' may solve
     this problem.

   * On a Unix-like system, The line endings in the program file must
     be Unix style line endings.  This is important because the web
     server checks the first line of the script (called shebang) and
     tries to run the program specified there.  It gets easily confused
     by Windows line endings (Carriage Return & Line Feed, also called
     CRLF), so you have to convert the file to Unix line endings (only
     Line Feed, LF).  This can be done automatically by uploading the
     file via FTP in text mode instead of binary mode, but the
     preferred way is just telling your editor to save the files with
     Unix line endings.  Most editors support this.

   * Your web server must be able to read the file, and you need to
     make sure the permissions are correct.  On unix-like systems, the
     server often runs as user and group `www-data', so it might be
     worth a try to change the file ownership, or making the file world
     readable by using `chmod a+r your_script.py'.

   * The web server must know that the file you’re trying to access
     is a CGI script.  Check the configuration of your web server, as
     it may be configured to expect a specific file extension for CGI
     scripts.

   * On Unix-like systems, the path to the interpreter in the shebang
     (`#!/usr/bin/env python') must be correct.  This line calls
     `/usr/bin/env' to find Python, but it will fail if there is no
     `/usr/bin/env', or if Python is not in the web server’s path.
     If you know where your Python is installed, you can also use that
     full path.  The commands `whereis python' and `type -p python'
     could help you find where it is installed.  Once you know the
     path, you can change the shebang accordingly: `#!/usr/bin/python'.

   * The file must not contain a BOM (Byte Order Mark). The BOM is
     meant for determining the byte order of UTF-16 and UTF-32
     encodings, but some editors write this also into UTF-8 files.  The
     BOM interferes with the shebang line, so be sure to tell your
     editor not to write the BOM.

   * If the web server is using *Note mod_python: 304a, `mod_python'
     may be having problems.  `mod_python' is able to handle CGI
     scripts by itself, but it can also be a source of issues.


File: python.info,  Node: mod_python,  Next: FastCGI and SCGI,  Prev: Common Gateway Interface,  Up: The Low-Level View

10.14.1.5 mod_python
....................

People coming from PHP often find it hard to grasp how to use Python in
the web.  Their first thought is mostly mod_python(1), because they
think that this is the equivalent to `mod_php'.  Actually, there are
many differences.  What `mod_python' does is embed the interpreter into
the Apache process, thus speeding up requests by not having to start a
Python interpreter for each request.  On the other hand, it is not
“Python intermixed with HTML” in the way that PHP is often
intermixed with HTML. The Python equivalent of that is a template
engine.  `mod_python' itself is much more powerful and provides more
access to Apache internals.  It can emulate CGI, work in a “Python
Server Pages” mode (similar to JSP) which is “HTML intermingled
with Python”, and it has a “Publisher” which designates one file
to accept all requests and decide what to do with them.

`mod_python' does have some problems.  Unlike the PHP interpreter, the
Python interpreter uses caching when executing files, so changes to a
file will require the web server to be restarted.  Another problem is
the basic concept – Apache starts child processes to handle the
requests, and unfortunately every child process needs to load the whole
Python interpreter even if it does not use it.  This makes the whole
web server slower.  Another problem is that, because `mod_python' is
linked against a specific version of `libpython', it is not possible to
switch from an older version to a newer (e.g. 2.4 to 2.5) without
recompiling `mod_python'.  `mod_python' is also bound to the Apache web
server, so programs written for `mod_python' cannot easily run on other
web servers.

These are the reasons why `mod_python' should be avoided when writing
new programs.  In some circumstances it still might be a good idea to
use `mod_python' for deployment, but WSGI makes it possible to run WSGI
programs under `mod_python' as well.

---------- Footnotes ----------

(1) http://modpython.org/


File: python.info,  Node: FastCGI and SCGI,  Next: mod_wsgi,  Prev: mod_python,  Up: The Low-Level View

10.14.1.6 FastCGI and SCGI
..........................

FastCGI and SCGI try to solve the performance problem of CGI in another
way.  Instead of embedding the interpreter into the web server, they
create long-running background processes. There is still a module in
the web server which makes it possible for the web server to
“speak” with the background process.  As the background process is
independent of the server, it can be written in any language, including
Python.  The language just needs to have a library which handles the
communication with the webserver.

The difference between FastCGI and SCGI is very small, as SCGI is
essentially just a “simpler FastCGI”.  As the web server support
for SCGI is limited, most people use FastCGI instead, which works the
same way.  Almost everything that applies to SCGI also applies to
FastCGI as well, so we’ll only cover the latter.

These days, FastCGI is never used directly.  Just like `mod_python', it
is only used for the deployment of WSGI applications.

* Menu:

* Setting up FastCGI::


File: python.info,  Node: Setting up FastCGI,  Up: FastCGI and SCGI

10.14.1.7 Setting up FastCGI
............................

Each web server requires a specific module.

   * Apache has both mod_fastcgi(1) and mod_fcgid(2).  `mod_fastcgi' is
     the original one, but it has some licensing issues, which is why
     it is sometimes considered non-free.  `mod_fcgid' is a smaller,
     compatible alternative.  One of these modules needs to be loaded
     by Apache.

   * lighttpd ships its own FastCGI module(3) as well as an SCGI
     module(4).

   * nginx(5) also supports FastCGI(6).

Once you have installed and configured the module, you can test it with
the following WSGI-application:

    #!/usr/bin/env python
    # -*- coding: UTF-8 -*-

    from cgi import escape
    import sys, os
    from flup.server.fcgi import WSGIServer

    def app(environ, start_response):
        start_response('200 OK', [('Content-Type', 'text/html')])

        yield '<h1>FastCGI Environment</h1>'
        yield '<table>'
        for k, v in sorted(environ.items()):
            yield '<tr><th>%s</th><td>%s</td></tr>' % (escape(k), escape(v))
        yield '</table>'

    WSGIServer(app).run()

This is a simple WSGI application, but you need to install flup(7)
first, as flup handles the low level FastCGI access.

See also
........

There is some documentation on setting up Django with WSGI(8), most of
which can be reused for other WSGI-compliant frameworks and libraries.
Only the `manage.py' part has to be changed, the example used here can
be used instead.  Django does more or less the exact same thing.

---------- Footnotes ----------

(1) http://www.fastcgi.com/drupal/

(2) https://httpd.apache.org/mod_fcgid/

(3) http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModFastCGI

(4) http://redmine.lighttpd.net/projects/lighttpd/wiki/Docs_ModSCGI

(5) http://nginx.org/

(6)
https://www.nginx.com/resources/wiki/start/topics/examples/simplepythonfcgi/

(7) https://pypi.python.org/pypi/flup/1.0

(8) https://docs.djangoproject.com/en/dev/howto/deployment/wsgi/


File: python.info,  Node: mod_wsgi,  Prev: FastCGI and SCGI,  Up: The Low-Level View

10.14.1.8 mod_wsgi
..................

mod_wsgi(1) is an attempt to get rid of the low level gateways.  Given
that FastCGI, SCGI, and mod_python are mostly used to deploy WSGI
applications, mod_wsgi was started to directly embed WSGI applications
into the Apache web server. mod_wsgi is specifically designed to host
WSGI applications.  It makes the deployment of WSGI applications much
easier than deployment using other low level methods, which need glue
code.  The downside is that mod_wsgi is limited to the Apache web
server; other servers would need their own implementations of mod_wsgi.

mod_wsgi supports two modes: embedded mode, in which it integrates with
the Apache process, and daemon mode, which is more FastCGI-like.
Unlike FastCGI, mod_wsgi handles the worker-processes by itself, which
makes administration easier.

---------- Footnotes ----------

(1) http://code.google.com/p/modwsgi/


File: python.info,  Node: Step back WSGI,  Next: Model-View-Controller,  Prev: The Low-Level View,  Up: HOWTO Use Python in the web

10.14.2 Step back: WSGI
-----------------------

WSGI has already been mentioned several times, so it has to be something
important.  In fact it really is, and now it is time to explain it.

The `Web Server Gateway Interface',  or WSGI for short, is defined in PEP
333(1) and is currently the best way to do Python web programming.
While it is great for programmers writing frameworks, a normal web
developer does not need to get in direct contact with it.  When
choosing a framework for web development it is a good idea to choose
one which supports WSGI.

The big benefit of WSGI is the unification of the application
programming interface.  When your program is compatible with WSGI –
which at the outer level means that the framework you are using has
support for WSGI – your program can be deployed via any web server
interface for which there are WSGI wrappers.  You do not need to care
about whether the application user uses mod_python or FastCGI or
mod_wsgi – with WSGI your application will work on any gateway
interface.  The Python standard library contains its own WSGI server,
*Note wsgiref: 199, which is a small web server that can be used for
testing.

A really great WSGI feature is middleware.  Middleware is a layer
around your program which can add various functionality to it.  There
is quite a bit of middleware(2) already available.  For example,
instead of writing your own session management (HTTP is a stateless
protocol, so to associate multiple HTTP requests with a single user
your application must create and manage such state via a session), you
can just download middleware which does that, plug it in, and get on
with coding the unique parts of your application.  The same thing with
compression – there is existing middleware which handles compressing
your HTML using gzip to save on your server’s bandwidth.
Authentication is another problem that is easily solved using existing
middleware.

Although WSGI may seem complex, the initial phase of learning can be
very rewarding because WSGI and the associated middleware already have
solutions to many problems that might arise while developing web sites.

* Menu:

* WSGI Servers::
* Case study; MoinMoin: Case study MoinMoin.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0333

(2) https://wsgi.readthedocs.org/en/latest/libraries.html


File: python.info,  Node: WSGI Servers,  Next: Case study MoinMoin,  Up: Step back WSGI

10.14.2.1 WSGI Servers
......................

The code that is used to connect to various low level gateways like CGI
or mod_python is called a `WSGI server'.  One of these servers is
`flup', which supports FastCGI and SCGI, as well as AJP(1).  Some of
these servers are written in Python, as `flup' is, but there also exist
others which are written in C and can be used as drop-in replacements.

There are many servers already available, so a Python web application
can be deployed nearly anywhere.  This is one big advantage that Python
has compared with other web technologies.

See also
........

A good overview of WSGI-related code can be found in the WSGI
homepage(2), which contains an extensive list of WSGI servers(3) which
can be used by `any' application supporting WSGI.

You might be interested in some WSGI-supporting modules already
contained in the standard library, namely:

   * *Note wsgiref: 199. – some tiny utilities and servers for WSGI

---------- Footnotes ----------

(1) https://en.wikipedia.org/wiki/Apache_JServ_Protocol

(2) https://wsgi.readthedocs.org/

(3) https://wsgi.readthedocs.org/en/latest/servers.html


File: python.info,  Node: Case study MoinMoin,  Prev: WSGI Servers,  Up: Step back WSGI

10.14.2.2 Case study: MoinMoin
..............................

What does WSGI give the web application developer?  Let’s take a look
at an application that’s been around for a while, which was written in
Python without using WSGI.

One of the most widely used wiki software packages is MoinMoin(1).  It
was created in 2000, so it predates WSGI by about three years.  Older
versions needed separate code to run on CGI, mod_python, FastCGI and
standalone.

It now includes support for WSGI.  Using WSGI, it is possible to deploy
MoinMoin on any WSGI compliant server, with no additional glue code.
Unlike the pre-WSGI versions, this could include WSGI servers that the
authors of MoinMoin know nothing about.

---------- Footnotes ----------

(1) https://moinmo.in/


File: python.info,  Node: Model-View-Controller,  Next: Ingredients for Websites,  Prev: Step back WSGI,  Up: HOWTO Use Python in the web

10.14.3 Model-View-Controller
-----------------------------

The term `MVC' is often encountered in statements such as “framework
`foo' supports MVC”.  MVC is more about the overall organization of
code, rather than any particular API.  Many web frameworks use this
model to help the developer bring structure to their program.  Bigger
web applications can have lots of code, so it is a good idea to have an
effective structure right from the beginning.  That way, even users of
other frameworks (or even other languages, since MVC is not
Python-specific) can easily understand the code, given that they are
already familiar with the MVC structure.

MVC stands for three components:

   * The `model'.  This is the data that will be displayed and
     modified.  In Python frameworks, this component is often
     represented by the classes used by an object-relational mapper.

   * The `view'.  This component’s job is to display the data of the
     model to the user.  Typically this component is implemented via
     templates.

   * The `controller'.  This is the layer between the user and the
     model.  The controller reacts to user actions (like opening some
     specific URL), tells the model to modify the data if necessary,
     and tells the view code what to display,

While one might think that MVC is a complex design pattern, in fact it
is not.  It is used in Python because it has turned out to be useful
for creating clean, maintainable web sites.

     Note: While not all Python frameworks explicitly support MVC, it
     is often trivial to create a web site which uses the MVC pattern
     by separating the data logic (the model) from the user interaction
     logic (the controller) and the templates (the view).  That’s why
     it is important not to write unnecessary Python code in the
     templates – it works against the MVC model and creates chaos in
     the code base, making it harder to understand and modify.

See also
........

The English Wikipedia has an article about the Model-View-Controller
pattern(1).  It includes a long list of web frameworks for various
programming languages.

---------- Footnotes ----------

(1) https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller


File: python.info,  Node: Ingredients for Websites,  Next: Frameworks,  Prev: Model-View-Controller,  Up: HOWTO Use Python in the web

10.14.4 Ingredients for Websites
--------------------------------

Websites are complex constructs, so tools have been created to help web
developers make their code easier to write and more maintainable.
Tools like these exist for all web frameworks in all languages.
Developers are not forced to use these tools, and often there is no
“best” tool.  It is worth learning about the available tools
because they can greatly simplify the process of developing a web site.

See also
........

There are far more components than can be presented here.  The Python
wiki has a page about these components, called Web Components(1).

* Menu:

* Templates::
* Data persistence::

---------- Footnotes ----------

(1) https://wiki.python.org/moin/WebComponents


File: python.info,  Node: Templates,  Next: Data persistence,  Up: Ingredients for Websites

10.14.4.1 Templates
...................

Mixing of HTML and Python code is made possible by a few libraries.
While convenient at first, it leads to horribly unmaintainable code.
That’s why templates exist.  Templates are, in the simplest case,
just HTML files with placeholders.  The HTML is sent to the user’s
browser after filling in the placeholders.

Python already includes two ways to build simple templates:

    >>> template = "<html><body><h1>Hello %s!</h1></body></html>"
    >>> print template % "Reader"
    <html><body><h1>Hello Reader!</h1></body></html>

    >>> from string import Template
    >>> template = Template("<html><body><h1>Hello ${name}</h1></body></html>")
    >>> print template.substitute(dict(name='Dinsdale'))
    <html><body><h1>Hello Dinsdale!</h1></body></html>

To generate complex HTML based on non-trivial model data, conditional
and looping constructs like Python’s `for' and `if' are generally
needed.  `Template engines' support templates of this complexity.

There are a lot of template engines available for Python which can be
used with or without a *Note framework: 3055.  Some of these define a
plain-text programming language which is easy to learn, partly because
it is limited in scope.  Others use XML, and the template output is
guaranteed to be always be valid XML.  There are many other variations.

Some *Note frameworks: 3056. ship their own template engine or
recommend one in particular.  In the absence of a reason to use a
different template engine, using the one provided by or recommended by
the framework is a good idea.

Popular template engines include:

        * Mako(1)

        * Genshi(2)

        * Jinja(3)

See also
........

There are many template engines competing for attention, because it is
pretty easy to create them in Python.  The page Templating(4) in the
wiki lists a big, ever-growing number of these.  The three listed above
are considered “second generation” template engines and are a good
place to start.

---------- Footnotes ----------

(1) http://www.makotemplates.org/

(2) http://genshi.edgewall.org/

(3) http://jinja.pocoo.org/

(4) https://wiki.python.org/moin/Templating


File: python.info,  Node: Data persistence,  Prev: Templates,  Up: Ingredients for Websites

10.14.4.2 Data persistence
..........................

`Data persistence', while sounding very complicated, is just about
storing data.  This data might be the text of blog entries, the
postings on a bulletin board or the text of a wiki page.  There are, of
course, a number of different ways to store information on a web server.

Often, relational database engines like MySQL(1) or PostgreSQL(2) are
used because of their good performance when handling very large
databases consisting of millions of entries.  There is also a small
database engine called SQLite(3), which is bundled with Python in the
*Note sqlite3: 15f.  module, and which uses only one file.  It has no
other dependencies.  For smaller sites SQLite is just enough.

Relational databases are `queried' using a language called SQL(4).
Python programmers in general do not like SQL too much, as they prefer
to work with objects.  It is possible to save Python objects into a
database using a technology called ORM(5) (Object Relational Mapping).
ORM translates all object-oriented access into SQL code under the hood,
so the developer does not need to think about it.  Most *Note
frameworks: 3056. use ORMs, and it works quite well.

A second possibility is storing data in normal, plain text files (some
times called “flat files”).  This is very easy for simple sites,
but can be difficult to get right if the web site is performing many
updates to the stored data.

A third possibility are object oriented databases (also called “object
databases”).  These databases store the object data in a form that
closely parallels the way the objects are structured in memory during
program execution.  (By contrast, ORMs store the object data as rows of
data in tables and relations between those rows.)  Storing the objects
directly has the advantage that nearly all objects can be saved in a
straightforward way, unlike in relational databases where some objects
are very hard to represent.

*Note Frameworks: 3056. often give hints on which data storage method
to choose.  It is usually a good idea to stick to the data store
recommended by the framework unless the application has special
requirements better satisfied by an alternate storage mechanism.

See also
........

   * Persistence Tools(6) lists possibilities on how to save data in
     the file system.  Some of these modules are part of the standard
     library

   * Database Programming(7) helps with choosing a method for saving
     data

   * SQLAlchemy(8), the most powerful OR-Mapper for Python, and
     Elixir(9), which makes SQLAlchemy easier to use

   * SQLObject(10), another popular OR-Mapper

   * ZODB(11) and Durus(12), two object oriented databases

---------- Footnotes ----------

(1) http://www.mysql.com/

(2) http://www.postgresql.org/

(3) http://www.sqlite.org/

(4) https://en.wikipedia.org/wiki/SQL

(5) https://en.wikipedia.org/wiki/Object-relational_mapping

(6) https://wiki.python.org/moin/PersistenceTools

(7) https://wiki.python.org/moin/DatabaseProgramming

(8) http://www.sqlalchemy.org/

(9) https://pypi.python.org/pypi/Elixir

(10) http://www.sqlobject.org/

(11) https://launchpad.net/zodb

(12) https://www.mems-exchange.org/software/


File: python.info,  Node: Frameworks,  Prev: Ingredients for Websites,  Up: HOWTO Use Python in the web

10.14.5 Frameworks
------------------

The process of creating code to run web sites involves writing code to
provide various services.  The code to provide a particular service
often works the same way regardless of the complexity or purpose of the
web site in question.  Abstracting these common solutions into reusable
code produces what are called “frameworks” for web development.
Perhaps the most well-known framework for web development is Ruby on
Rails, but Python has its own frameworks.  Some of these were partly
inspired by Rails, or borrowed ideas from Rails, but many existed a
long time before Rails.

Originally Python web frameworks tended to incorporate all of the
services needed to develop web sites as a giant, integrated set of
tools.  No two web frameworks were interoperable:  a program developed
for one could not be deployed on a different one without considerable
re-engineering work.  This led to the development of “minimalist”
web frameworks that provided just the tools to communicate between the
Python code and the http protocol, with all other services to be added
on top via separate components.  Some ad hoc standards were developed
that allowed for limited interoperability between frameworks, such as a
standard that allowed different template engines to be used
interchangeably.

Since the advent of WSGI, the Python web framework world has been
evolving toward interoperability based on the WSGI standard.  Now many
web frameworks, whether “full stack” (providing all the tools one
needs to deploy the most complex web sites) or minimalist, or anything
in between, are built from collections of reusable components that can
be used with more than one framework.

The majority of users will probably want to select a “full stack”
framework that has an active community.  These frameworks tend to be
well documented, and provide the easiest path to producing a fully
functional web site in minimal time.

* Menu:

* Some notable frameworks::


File: python.info,  Node: Some notable frameworks,  Up: Frameworks

10.14.5.1 Some notable frameworks
.................................

There are an incredible number of frameworks, so they cannot all be
covered here.  Instead we will briefly touch on some of the most
popular.

* Menu:

* Django::
* TurboGears::
* Zope::
* Other notable frameworks::


File: python.info,  Node: Django,  Next: TurboGears,  Up: Some notable frameworks

10.14.5.2 Django
................

Django(1) is a framework consisting of several tightly coupled elements
which were written from scratch and work together very well.  It
includes an ORM which is quite powerful while being simple to use, and
has a great online administration interface which makes it possible to
edit the data in the database with a browser.  The template engine is
text-based and is designed to be usable for page designers who cannot
write Python.  It supports template inheritance and filters (which work
like Unix pipes).  Django has many handy features bundled, such as
creation of RSS feeds or generic views, which make it possible to
create web sites almost without writing any Python code.

It has a big, international community, the members of which have
created many web sites.  There are also a lot of add-on projects which
extend Django’s normal functionality.  This is partly due to
Django’s well written online documentation(2) and the Django book(3).

     Note: Although Django is an MVC-style framework, it names the
     elements differently, which is described in the Django FAQ(4).

---------- Footnotes ----------

(1) https://www.djangoproject.com/

(2) https://docs.djangoproject.com/

(3) http://www.djangobook.com/

(4)
https://docs.djangoproject.com/en/dev/faq/general/#django-appears-to-be-a-mvc-framework-but-you-call-the-controller-the-view-and-the-view-the-template-how-come-you-don-t-use-the-standard-names


File: python.info,  Node: TurboGears,  Next: Zope,  Prev: Django,  Up: Some notable frameworks

10.14.5.3 TurboGears
....................

Another popular web framework for Python is TurboGears(1).  TurboGears
takes the approach of using already existing components and combining
them with glue code to create a seamless experience.  TurboGears gives
the user flexibility in choosing components. For example the ORM and
template engine can be changed to use packages different from those
used by default.

The documentation can be found in the TurboGears documentation(2),
where links to screencasts can be found.  TurboGears has also an active
user community which can respond to most related questions.  There is
also a TurboGears book(3) published, which is a good starting point.

The newest version of TurboGears, version 2.0, moves even further in
direction of WSGI support and a component-based architecture.
TurboGears 2 is based on the WSGI stack of another popular
component-based web framework, Pylons(4).

---------- Footnotes ----------

(1) http://www.turbogears.org/

(2) https://turbogears.readthedocs.org/

(3) http://turbogears.org/1.0/docs/TGBooks.html

(4) http://www.pylonsproject.org/


File: python.info,  Node: Zope,  Next: Other notable frameworks,  Prev: TurboGears,  Up: Some notable frameworks

10.14.5.4 Zope
..............

The Zope framework is one of the “old original” frameworks.  Its
current incarnation in Zope2 is a tightly integrated full-stack
framework.  One of its most interesting feature is its tight
integration with a powerful object database called the ZODB(1) (Zope
Object Database).  Because of its highly integrated nature, Zope wound
up in a somewhat isolated ecosystem:  code written for Zope wasn’t
very usable outside of Zope, and vice-versa.  To solve this problem the
Zope 3 effort was started.  Zope 3 re-engineers Zope as a set of more
cleanly isolated components.  This effort was started before the advent
of the WSGI standard, but there is WSGI support for Zope 3 from the
Repoze(2) project.  Zope components have many years of production use
behind them, and the Zope 3 project gives access to these components to
the wider Python community.  There is even a separate framework based
on the Zope components: Grok(3).

Zope is also the infrastructure used by the Plone(4) content management
system, one of the most powerful and popular content management systems
available.

---------- Footnotes ----------

(1) https://launchpad.net/zodb

(2) http://repoze.org/

(3) http://grok.zope.org/

(4) https://plone.org/


File: python.info,  Node: Other notable frameworks,  Prev: Zope,  Up: Some notable frameworks

10.14.5.5 Other notable frameworks
..................................

Of course these are not the only frameworks that are available.  There
are many other frameworks worth mentioning.

Another framework that’s already been mentioned is Pylons(1).  Pylons
is much like TurboGears, but with an even stronger emphasis on
flexibility, which comes at the cost of being more difficult to use.
Nearly every component can be exchanged, which makes it necessary to
use the documentation of every single component, of which there are
many.  Pylons builds upon Paste(2), an extensive set of tools which are
handy for WSGI.

And that’s still not everything.  The most up-to-date information can
always be found in the Python wiki.

See also
........

The Python wiki contains an extensive list of web frameworks(3).

Most frameworks also have their own mailing lists and IRC channels,
look out for these on the projects’ web sites.

---------- Footnotes ----------

(1) http://www.pylonsproject.org/

(2) http://pythonpaste.org/

(3) https://wiki.python.org/moin/WebFrameworks


File: python.info,  Node: Argparse Tutorial,  Prev: HOWTO Use Python in the web,  Up: Python HOWTOs

10.15 Argparse Tutorial
=======================

author: Tshepang Lekhonkhobe

This tutorial is intended to be a gentle introduction to *Note
argparse: d, the recommended command-line parsing module in the Python
standard library.  This was written for argparse in Python 3. A few
details are different in 2.x, especially some exception messages, which
were improved in 3.x.

     Note: There are two other modules that fulfill the same task,
     namely *Note getopt: df. (an equivalent for `getopt()' from the C
     language) and the deprecated *Note optparse: 128.  Note also that
     *Note argparse: d. is based on *Note optparse: 128, and therefore
     very similar in terms of usage.

* Menu:

* Concepts::
* The basics::
* Introducing Positional arguments::
* Introducing Optional arguments::
* Combining Positional and Optional arguments::
* Getting a little more advanced::
* Conclusion::


File: python.info,  Node: Concepts,  Next: The basics,  Up: Argparse Tutorial

10.15.1 Concepts
----------------

Let’s show the sort of functionality that we are going to explore in
this introductory tutorial by making use of the `ls' command:

    $ ls
    cpython  devguide  prog.py  pypy  rm-unused-function.patch
    $ ls pypy
    ctypes_configure  demo  dotviewer  include  lib_pypy  lib-python ...
    $ ls -l
    total 20
    drwxr-xr-x 19 wena wena 4096 Feb 18 18:51 cpython
    drwxr-xr-x  4 wena wena 4096 Feb  8 12:04 devguide
    -rwxr-xr-x  1 wena wena  535 Feb 19 00:05 prog.py
    drwxr-xr-x 14 wena wena 4096 Feb  7 00:59 pypy
    -rw-r--r--  1 wena wena  741 Feb 18 01:01 rm-unused-function.patch
    $ ls --help
    Usage: ls [OPTION]... [FILE]...
    List information about the FILEs (the current directory by default).
    Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.
    ...

A few concepts we can learn from the four commands:

   * The `ls' command is useful when run without any options at all. It
     defaults to displaying the contents of the current directory.

   * If we want beyond what it provides by default, we tell it a bit
     more. In this case, we want it to display a different directory,
     `pypy'.  What we did is specify what is known as a positional
     argument. It’s named so because the program should know what to
     do with the value, solely based on where it appears on the command
     line. This concept is more relevant to a command like `cp', whose
     most basic usage is `cp SRC DEST'.  The first position is `what
     you want copied,' and the second position is `where you want it
     copied to'.

   * Now, say we want to change behaviour of the program. In our
     example, we display more info for each file instead of just
     showing the file names.  The `-l' in that case is known as an
     optional argument.

   * That’s a snippet of the help text. It’s very useful in that
     you can come across a program you have never used before, and can
     figure out how it works simply by reading its help text.


File: python.info,  Node: The basics,  Next: Introducing Positional arguments,  Prev: Concepts,  Up: Argparse Tutorial

10.15.2 The basics
------------------

Let us start with a very simple example which does (almost) nothing:

    import argparse
    parser = argparse.ArgumentParser()
    parser.parse_args()

Following is a result of running the code:

    $ python prog.py
    $ python prog.py --help
    usage: prog.py [-h]

    optional arguments:
      -h, --help  show this help message and exit
    $ python prog.py --verbose
    usage: prog.py [-h]
    prog.py: error: unrecognized arguments: --verbose
    $ python prog.py foo
    usage: prog.py [-h]
    prog.py: error: unrecognized arguments: foo

Here is what is happening:

   * Running the script without any options results in nothing
     displayed to stdout. Not so useful.

   * The second one starts to display the usefulness of the *Note
     argparse: d.  module. We have done almost nothing, but already we
     get a nice help message.

   * The `--help' option, which can also be shortened to `-h', is the
     only option we get for free (i.e. no need to specify it).
     Specifying anything else results in an error. But even then, we do
     get a useful usage message, also for free.


File: python.info,  Node: Introducing Positional arguments,  Next: Introducing Optional arguments,  Prev: The basics,  Up: Argparse Tutorial

10.15.3 Introducing Positional arguments
----------------------------------------

An example:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("echo")
    args = parser.parse_args()
    print args.echo

And running the code:

    $ python prog.py
    usage: prog.py [-h] echo
    prog.py: error: the following arguments are required: echo
    $ python prog.py --help
    usage: prog.py [-h] echo

    positional arguments:
      echo

    optional arguments:
      -h, --help  show this help message and exit
    $ python prog.py foo
    foo

Here is what’s happening:

   * We’ve added the `add_argument()' method, which is what we use to
     specify which command-line options the program is willing to
     accept. In this case, I’ve named it `echo' so that it’s in
     line with its function.

   * Calling our program now requires us to specify an option.

   * The `parse_args()' method actually returns some data from the
     options specified, in this case, `echo'.

   * The variable is some form of ‘magic’ that *Note argparse: d.
     performs for free (i.e. no need to specify which variable that
     value is stored in).  You will also notice that its name matches
     the string argument given to the method, `echo'.

Note however that, although the help display looks nice and all, it
currently is not as helpful as it can be. For example we see that we
got `echo' as a positional argument, but we don’t know what it does,
other than by guessing or by reading the source code. So, let’s make
it a bit more useful:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("echo", help="echo the string you use here")
    args = parser.parse_args()
    print args.echo

And we get:

    $ python prog.py -h
    usage: prog.py [-h] echo

    positional arguments:
      echo        echo the string you use here

    optional arguments:
      -h, --help  show this help message and exit

Now, how about doing something even more useful:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("square", help="display a square of a given number")
    args = parser.parse_args()
    print args.square**2

Following is a result of running the code:

    $ python prog.py 4
    Traceback (most recent call last):
      File "prog.py", line 5, in <module>
        print args.square**2
    TypeError: unsupported operand type(s) for ** or pow(): 'str' and 'int'

That didn’t go so well. That’s because *Note argparse: d. treats
the options we give it as strings, unless we tell it otherwise. So,
let’s tell *Note argparse: d. to treat that input as an integer:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("square", help="display a square of a given number",
                        type=int)
    args = parser.parse_args()
    print args.square**2

Following is a result of running the code:

    $ python prog.py 4
    16
    $ python prog.py four
    usage: prog.py [-h] square
    prog.py: error: argument square: invalid int value: 'four'

That went well. The program now even helpfully quits on bad illegal
input before proceeding.


File: python.info,  Node: Introducing Optional arguments,  Next: Combining Positional and Optional arguments,  Prev: Introducing Positional arguments,  Up: Argparse Tutorial

10.15.4 Introducing Optional arguments
--------------------------------------

So far we, have been playing with positional arguments. Let us have a
look on how to add optional ones:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbosity", help="increase output verbosity")
    args = parser.parse_args()
    if args.verbosity:
        print "verbosity turned on"

And the output:

    $ python prog.py --verbosity 1
    verbosity turned on
    $ python prog.py
    $ python prog.py --help
    usage: prog.py [-h] [--verbosity VERBOSITY]

    optional arguments:
      -h, --help            show this help message and exit
      --verbosity VERBOSITY
                            increase output verbosity
    $ python prog.py --verbosity
    usage: prog.py [-h] [--verbosity VERBOSITY]
    prog.py: error: argument --verbosity: expected one argument

Here is what is happening:

   * The program is written so as to display something when
     `--verbosity' is specified and display nothing when not.

   * To show that the option is actually optional, there is no error
     when running the program without it. Note that by default, if an
     optional argument isn’t used, the relevant variable, in this
     case `args.verbosity', is given `None' as a value, which is the
     reason it fails the truth test of the *Note if: 445. statement.

   * The help message is a bit different.

   * When using the `--verbosity' option, one must also specify some
     value, any value.

The above example accepts arbitrary integer values for `--verbosity',
but for our simple program, only two values are actually useful, `True'
or `False'.  Let’s modify the code accordingly:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--verbose", help="increase output verbosity",
                        action="store_true")
    args = parser.parse_args()
    if args.verbose:
       print "verbosity turned on"

And the output:

    $ python prog.py --verbose
    verbosity turned on
    $ python prog.py --verbose 1
    usage: prog.py [-h] [--verbose]
    prog.py: error: unrecognized arguments: 1
    $ python prog.py --help
    usage: prog.py [-h] [--verbose]

    optional arguments:
      -h, --help  show this help message and exit
      --verbose   increase output verbosity

Here is what is happening:

   * The option is now more of a flag than something that requires a
     value.  We even changed the name of the option to match that idea.
     Note that we now specify a new keyword, `action', and give it the
     value `"store_true"'. This means that, if the option is specified,
     assign the value `True' to `args.verbose'.  Not specifying it
     implies `False'.

   * It complains when you specify a value, in true spirit of what flags
     actually are.

   * Notice the different help text.

* Menu:

* Short options::


File: python.info,  Node: Short options,  Up: Introducing Optional arguments

10.15.4.1 Short options
.......................

If you are familiar with command line usage, you will notice that I
haven’t yet touched on the topic of short versions of the options.
It’s quite simple:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", help="increase output verbosity",
                        action="store_true")
    args = parser.parse_args()
    if args.verbose:
        print "verbosity turned on"

And here goes:

    $ python prog.py -v
    verbosity turned on
    $ python prog.py --help
    usage: prog.py [-h] [-v]

    optional arguments:
      -h, --help     show this help message and exit
      -v, --verbose  increase output verbosity

Note that the new ability is also reflected in the help text.


File: python.info,  Node: Combining Positional and Optional arguments,  Next: Getting a little more advanced,  Prev: Introducing Optional arguments,  Up: Argparse Tutorial

10.15.5 Combining Positional and Optional arguments
---------------------------------------------------

Our program keeps growing in complexity:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("square", type=int,
                        help="display a square of a given number")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="increase output verbosity")
    args = parser.parse_args()
    answer = args.square**2
    if args.verbose:
        print "the square of {} equals {}".format(args.square, answer)
    else:
        print answer

And now the output:

    $ python prog.py
    usage: prog.py [-h] [-v] square
    prog.py: error: the following arguments are required: square
    $ python prog.py 4
    16
    $ python prog.py 4 --verbose
    the square of 4 equals 16
    $ python prog.py --verbose 4
    the square of 4 equals 16

   * We’ve brought back a positional argument, hence the complaint.

   * Note that the order does not matter.

How about we give this program of ours back the ability to have
multiple verbosity values, and actually get to use them:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("square", type=int,
                        help="display a square of a given number")
    parser.add_argument("-v", "--verbosity", type=int,
                        help="increase output verbosity")
    args = parser.parse_args()
    answer = args.square**2
    if args.verbosity == 2:
        print "the square of {} equals {}".format(args.square, answer)
    elif args.verbosity == 1:
        print "{}^2 == {}".format(args.square, answer)
    else:
        print answer

And the output:

    $ python prog.py 4
    16
    $ python prog.py 4 -v
    usage: prog.py [-h] [-v VERBOSITY] square
    prog.py: error: argument -v/--verbosity: expected one argument
    $ python prog.py 4 -v 1
    4^2 == 16
    $ python prog.py 4 -v 2
    the square of 4 equals 16
    $ python prog.py 4 -v 3
    16

These all look good except the last one, which exposes a bug in our
program.  Let’s fix it by restricting the values the `--verbosity'
option can accept:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("square", type=int,
                        help="display a square of a given number")
    parser.add_argument("-v", "--verbosity", type=int, choices=[0, 1, 2],
                        help="increase output verbosity")
    args = parser.parse_args()
    answer = args.square**2
    if args.verbosity == 2:
        print "the square of {} equals {}".format(args.square, answer)
    elif args.verbosity == 1:
        print "{}^2 == {}".format(args.square, answer)
    else:
        print answer

And the output:

    $ python prog.py 4 -v 3
    usage: prog.py [-h] [-v {0,1,2}] square
    prog.py: error: argument -v/--verbosity: invalid choice: 3 (choose from 0, 1, 2)
    $ python prog.py 4 -h
    usage: prog.py [-h] [-v {0,1,2}] square

    positional arguments:
      square                display a square of a given number

    optional arguments:
      -h, --help            show this help message and exit
      -v {0,1,2}, --verbosity {0,1,2}
                            increase output verbosity

Note that the change also reflects both in the error message as well as
the help string.

Now, let’s use a different approach of playing with verbosity, which
is pretty common. It also matches the way the CPython executable
handles its own verbosity argument (check the output of `python
--help'):

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("square", type=int,
                        help="display the square of a given number")
    parser.add_argument("-v", "--verbosity", action="count",
                        help="increase output verbosity")
    args = parser.parse_args()
    answer = args.square**2
    if args.verbosity == 2:
        print "the square of {} equals {}".format(args.square, answer)
    elif args.verbosity == 1:
        print "{}^2 == {}".format(args.square, answer)
    else:
        print answer

We have introduced another action, “count”, to count the number of
occurrences of a specific optional arguments:

    $ python prog.py 4
    16
    $ python prog.py 4 -v
    4^2 == 16
    $ python prog.py 4 -vv
    the square of 4 equals 16
    $ python prog.py 4 --verbosity --verbosity
    the square of 4 equals 16
    $ python prog.py 4 -v 1
    usage: prog.py [-h] [-v] square
    prog.py: error: unrecognized arguments: 1
    $ python prog.py 4 -h
    usage: prog.py [-h] [-v] square

    positional arguments:
      square           display a square of a given number

    optional arguments:
      -h, --help       show this help message and exit
      -v, --verbosity  increase output verbosity
    $ python prog.py 4 -vvv
    16

   * Yes, it’s now more of a flag (similar to `action="store_true"')
     in the previous version of our script. That should explain the
     complaint.

   * It also behaves similar to “store_true” action.

   * Now here’s a demonstration of what the “count” action gives.
     You’ve probably seen this sort of usage before.

   * And, just like the “store_true” action, if you don’t specify
     the `-v' flag, that flag is considered to have `None' value.

   * As should be expected, specifying the long form of the flag, we
     should get the same output.

   * Sadly, our help output isn’t very informative on the new ability
     our script has acquired, but that can always be fixed by improving
     the documentation for our script (e.g. via the `help' keyword
     argument).

   * That last output exposes a bug in our program.

Let’s fix:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("square", type=int,
                        help="display a square of a given number")
    parser.add_argument("-v", "--verbosity", action="count",
                        help="increase output verbosity")
    args = parser.parse_args()
    answer = args.square**2

    # bugfix: replace == with >=
    if args.verbosity >= 2:
        print "the square of {} equals {}".format(args.square, answer)
    elif args.verbosity >= 1:
        print "{}^2 == {}".format(args.square, answer)
    else:
        print answer

And this is what it gives:

    $ python prog.py 4 -vvv
    the square of 4 equals 16
    $ python prog.py 4 -vvvv
    the square of 4 equals 16
    $ python prog.py 4
    Traceback (most recent call last):
      File "prog.py", line 11, in <module>
        if args.verbosity >= 2:
    TypeError: unorderable types: NoneType() >= int()

   * First output went well, and fixes the bug we had before.  That is,
     we want any value >= 2 to be as verbose as possible.

   * Third output not so good.

Let’s fix that bug:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("square", type=int,
                        help="display a square of a given number")
    parser.add_argument("-v", "--verbosity", action="count", default=0,
                        help="increase output verbosity")
    args = parser.parse_args()
    answer = args.square**2
    if args.verbosity >= 2:
        print "the square of {} equals {}".format(args.square, answer)
    elif args.verbosity >= 1:
        print "{}^2 == {}".format(args.square, answer)
    else:
        print answer

We’ve just introduced yet another keyword, `default'.  We’ve set it
to `0' in order to make it comparable to the other int values.
Remember that by default, if an optional argument isn’t specified, it
gets the `None' value, and that cannot be compared to an int value
(hence the *Note TypeError: 218. exception).

And:

    $ python prog.py 4
    16

You can go quite far just with what we’ve learned so far, and we have
only scratched the surface.  The *Note argparse: d. module is very
powerful, and we’ll explore a bit more of it before we end this
tutorial.


File: python.info,  Node: Getting a little more advanced,  Next: Conclusion,  Prev: Combining Positional and Optional arguments,  Up: Argparse Tutorial

10.15.6 Getting a little more advanced
--------------------------------------

What if we wanted to expand our tiny program to perform other powers,
not just squares:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("x", type=int, help="the base")
    parser.add_argument("y", type=int, help="the exponent")
    parser.add_argument("-v", "--verbosity", action="count", default=0)
    args = parser.parse_args()
    answer = args.x**args.y
    if args.verbosity >= 2:
        print "{} to the power {} equals {}".format(args.x, args.y, answer)
    elif args.verbosity >= 1:
        print "{}^{} == {}".format(args.x, args.y, answer)
    else:
        print answer

Output:

    $ python prog.py
    usage: prog.py [-h] [-v] x y
    prog.py: error: the following arguments are required: x, y
    $ python prog.py -h
    usage: prog.py [-h] [-v] x y

    positional arguments:
      x                the base
      y                the exponent

    optional arguments:
      -h, --help       show this help message and exit
      -v, --verbosity
    $ python prog.py 4 2 -v
    4^2 == 16

Notice that so far we’ve been using verbosity level to `change' the
text that gets displayed. The following example instead uses verbosity
level to display `more' text instead:

    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("x", type=int, help="the base")
    parser.add_argument("y", type=int, help="the exponent")
    parser.add_argument("-v", "--verbosity", action="count", default=0)
    args = parser.parse_args()
    answer = args.x**args.y
    if args.verbosity >= 2:
        print "Running '{}'".format(__file__)
    if args.verbosity >= 1:
        print "{}^{} ==".format(args.x, args.y),
    print answer

Output:

    $ python prog.py 4 2
    16
    $ python prog.py 4 2 -v
    4^2 == 16
    $ python prog.py 4 2 -vv
    Running 'prog.py'
    4^2 == 16

* Menu:

* Conflicting options::


File: python.info,  Node: Conflicting options,  Up: Getting a little more advanced

10.15.6.1 Conflicting options
.............................

So far, we have been working with two methods of an *Note
argparse.ArgumentParser: 1232. instance. Let’s introduce a third one,
`add_mutually_exclusive_group()'. It allows for us to specify options
that conflict with each other. Let’s also change the rest of the
program so that the new functionality makes more sense: we’ll
introduce the `--quiet' option, which will be the opposite of the
`--verbose' one:

    import argparse

    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-v", "--verbose", action="store_true")
    group.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument("x", type=int, help="the base")
    parser.add_argument("y", type=int, help="the exponent")
    args = parser.parse_args()
    answer = args.x**args.y

    if args.quiet:
        print answer
    elif args.verbose:
        print "{} to the power {} equals {}".format(args.x, args.y, answer)
    else:
        print "{}^{} == {}".format(args.x, args.y, answer)

Our program is now simpler, and we’ve lost some functionality for the
sake of demonstration. Anyways, here’s the output:

    $ python prog.py 4 2
    4^2 == 16
    $ python prog.py 4 2 -q
    16
    $ python prog.py 4 2 -v
    4 to the power 2 equals 16
    $ python prog.py 4 2 -vq
    usage: prog.py [-h] [-v | -q] x y
    prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose
    $ python prog.py 4 2 -v --quiet
    usage: prog.py [-h] [-v | -q] x y
    prog.py: error: argument -q/--quiet: not allowed with argument -v/--verbose

That should be easy to follow. I’ve added that last output so you can
see the sort of flexibility you get, i.e. mixing long form options with
short form ones.

Before we conclude, you probably want to tell your users the main
purpose of your program, just in case they don’t know:

    import argparse

    parser = argparse.ArgumentParser(description="calculate X to the power of Y")
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-v", "--verbose", action="store_true")
    group.add_argument("-q", "--quiet", action="store_true")
    parser.add_argument("x", type=int, help="the base")
    parser.add_argument("y", type=int, help="the exponent")
    args = parser.parse_args()
    answer = args.x**args.y

    if args.quiet:
        print answer
    elif args.verbose:
        print "{} to the power {} equals {}".format(args.x, args.y, answer)
    else:
        print "{}^{} == {}".format(args.x, args.y, answer)

Note that slight difference in the usage text. Note the `[-v | -q]',
which tells us that we can either use `-v' or `-q', but not both at the
same time:

    $ python prog.py --help
    usage: prog.py [-h] [-v | -q] x y

    calculate X to the power of Y

    positional arguments:
      x              the base
      y              the exponent

    optional arguments:
      -h, --help     show this help message and exit
      -v, --verbose
      -q, --quiet


File: python.info,  Node: Conclusion,  Prev: Getting a little more advanced,  Up: Argparse Tutorial

10.15.7 Conclusion
------------------

The *Note argparse: d. module offers a lot more than shown here.  Its
docs are quite detailed and thorough, and full of examples.  Having
gone through this tutorial, you should easily digest them without
feeling overwhelmed.


File: python.info,  Node: Python Frequently Asked Questions,  Next: Glossary,  Prev: Python HOWTOs,  Up: Top

11 Python Frequently Asked Questions
************************************

* Menu:

* General Python FAQ::
* Programming FAQ::
* Design and History FAQ::
* Library and Extension FAQ::
* Extending/Embedding FAQ::
* Python on Windows FAQ::
* Graphic User Interface FAQ::
* “Why is Python Installed on my Computer?” FAQ::


File: python.info,  Node: General Python FAQ,  Next: Programming FAQ,  Up: Python Frequently Asked Questions

11.1 General Python FAQ
=======================

* Menu:

* General Information::
* Python in the real world::
* Upgrading Python::


File: python.info,  Node: General Information,  Next: Python in the real world,  Up: General Python FAQ

11.1.1 General Information
--------------------------

* Menu:

* What is Python?::
* What is the Python Software Foundation?::
* Are there copyright restrictions on the use of Python?::
* Why was Python created in the first place?::
* What is Python good for?::
* How does the Python version numbering scheme work?::
* How do I obtain a copy of the Python source?::
* How do I get documentation on Python?::
* I’ve never programmed before. Is there a Python tutorial?: I’ve never programmed before Is there a Python tutorial?.
* Is there a newsgroup or mailing list devoted to Python?::
* How do I get a beta test version of Python?::
* How do I submit bug reports and patches for Python?::
* Are there any published articles about Python that I can reference?::
* Are there any books on Python?::
* Where in the world is www.python.org located?: Where in the world is www python org located?.
* Why is it called Python?::
* Do I have to like “Monty Python’s Flying Circus”?::


File: python.info,  Node: What is Python?,  Next: What is the Python Software Foundation?,  Up: General Information

11.1.1.1 What is Python?
........................

Python is an interpreted, interactive, object-oriented programming
language.  It incorporates modules, exceptions, dynamic typing, very
high level dynamic data types, and classes.  Python combines remarkable
power with very clear syntax.  It has interfaces to many system calls
and libraries, as well as to various window systems, and is extensible
in C or C++.  It is also usable as an extension language for
applications that need a programmable interface.  Finally, Python is
portable: it runs on many Unix variants, on the Mac, and on PCs under
MS-DOS, Windows, Windows NT, and OS/2.

To find out more, start with *Note The Python Tutorial: 514.  The
Beginner's Guide to Python(1) links to other introductory tutorials and
resources for learning Python.

---------- Footnotes ----------

(1) https://wiki.python.org/moin/BeginnersGuide


File: python.info,  Node: What is the Python Software Foundation?,  Next: Are there copyright restrictions on the use of Python?,  Prev: What is Python?,  Up: General Information

11.1.1.2 What is the Python Software Foundation?
................................................

The Python Software Foundation is an independent non-profit
organization that holds the copyright on Python versions 2.1 and newer.
The PSF’s mission is to advance open source technology related to
the Python programming language and to publicize the use of Python.
The PSF’s home page is at <https://www.python.org/psf/>.

Donations to the PSF are tax-exempt in the US.  If you use Python and
find it helpful, please contribute via the PSF donation page(1).

---------- Footnotes ----------

(1) https://www.python.org/psf/donations/


File: python.info,  Node: Are there copyright restrictions on the use of Python?,  Next: Why was Python created in the first place?,  Prev: What is the Python Software Foundation?,  Up: General Information

11.1.1.3 Are there copyright restrictions on the use of Python?
...............................................................

You can do anything you want with the source, as long as you leave the
copyrights in and display those copyrights in any documentation about
Python that you produce.  If you honor the copyright rules, it’s OK
to use Python for commercial use, to sell copies of Python in source or
binary form (modified or unmodified), or to sell products that
incorporate Python in some form.  We would still like to know about all
commercial use of Python, of course.

See the PSF license page(1) to find further explanations and a link to
the full text of the license.

The Python logo is trademarked, and in certain cases permission is
required to use it.  Consult the Trademark Usage Policy(2) for more
information.

---------- Footnotes ----------

(1) https://www.python.org/psf/license/

(2) https://www.python.org/psf/trademarks/


File: python.info,  Node: Why was Python created in the first place?,  Next: What is Python good for?,  Prev: Are there copyright restrictions on the use of Python?,  Up: General Information

11.1.1.4 Why was Python created in the first place?
...................................................

Here’s a `very' brief summary of what started it all, written by
Guido van Rossum:

     I had extensive experience with implementing an interpreted
     language in the ABC group at CWI, and from working with this group
     I had learned a lot about language design.  This is the origin of
     many Python features, including the use of indentation for
     statement grouping and the inclusion of very-high-level data types
     (although the details are all different in Python).

     I had a number of gripes about the ABC language, but also liked
     many of its features.  It was impossible to extend the ABC
     language (or its implementation) to remedy my complaints – in
     fact its lack of extensibility was one of its biggest problems.  I
     had some experience with using Modula-2+ and talked with the
     designers of Modula-3 and read the Modula-3 report.  Modula-3 is
     the origin of the syntax and semantics used for exceptions, and
     some other Python features.

     I was working in the Amoeba distributed operating system group at
     CWI.  We needed a better way to do system administration than by
     writing either C programs or Bourne shell scripts, since Amoeba
     had its own system call interface which wasn’t easily accessible
     from the Bourne shell.  My experience with error handling in
     Amoeba made me acutely aware of the importance of exceptions as a
     programming language feature.

     It occurred to me that a scripting language with a syntax like ABC
     but with access to the Amoeba system calls would fill the need.  I
     realized that it would be foolish to write an Amoeba-specific
     language, so I decided that I needed a language that was generally
     extensible.

     During the 1989 Christmas holidays, I had a lot of time on my
     hand, so I decided to give it a try.  During the next year, while
     still mostly working on it in my own time, Python was used in the
     Amoeba project with increasing success, and the feedback from
     colleagues made me add many early improvements.

     In February 1991, after just over a year of development, I decided
     to post to USENET.  The rest is in the `Misc/HISTORY' file.


File: python.info,  Node: What is Python good for?,  Next: How does the Python version numbering scheme work?,  Prev: Why was Python created in the first place?,  Up: General Information

11.1.1.5 What is Python good for?
.................................

Python is a high-level general-purpose programming language that can be
applied to many different classes of problems.

The language comes with a large standard library that covers areas such
as string processing (regular expressions, Unicode, calculating
differences between files), Internet protocols (HTTP, FTP, SMTP,
XML-RPC, POP, IMAP, CGI programming), software engineering (unit
testing, logging, profiling, parsing Python code), and operating system
interfaces (system calls, filesystems, TCP/IP sockets).  Look at the
table of contents for *Note The Python Standard Library: 515. to get an
idea of what’s available.  A wide variety of third-party extensions
are also available.  Consult the Python Package Index(1) to find
packages of interest to you.

---------- Footnotes ----------

(1) https://pypi.python.org/pypi


File: python.info,  Node: How does the Python version numbering scheme work?,  Next: How do I obtain a copy of the Python source?,  Prev: What is Python good for?,  Up: General Information

11.1.1.6 How does the Python version numbering scheme work?
...........................................................

Python versions are numbered A.B.C or A.B.  A is the major version
number – it is only incremented for really major changes in the
language.  B is the minor version number, incremented for less
earth-shattering changes.  C is the micro-level – it is incremented
for each bugfix release.  See PEP 6(1) for more information about
bugfix releases.

Not all releases are bugfix releases.  In the run-up to a new major
release, a series of development releases are made, denoted as alpha,
beta, or release candidate.  Alphas are early releases in which
interfaces aren’t yet finalized; it’s not unexpected to see an
interface change between two alpha releases.  Betas are more stable,
preserving existing interfaces but possibly adding new modules, and
release candidates are frozen, making no changes except as needed to
fix critical bugs.

Alpha, beta and release candidate versions have an additional suffix.
The suffix for an alpha version is “aN” for some small number N,
the suffix for a beta version is “bN” for some small number N, and
the suffix for a release candidate version is “cN” for some small
number N.  In other words, all versions labeled 2.0aN precede the
versions labeled 2.0bN, which precede versions labeled 2.0cN, and
`those' precede 2.0.

You may also find version numbers with a “+” suffix, e.g.
“2.2+”.  These are unreleased versions, built directly from the
CPython development repository.  In practice, after a final minor
release is made, the version is incremented to the next minor version,
which becomes the “a0” version, e.g. “2.4a0”.

See also the documentation for *Note sys.version: 2494, *Note
sys.hexversion: 2487, and *Note sys.version_info: 2495.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0006


File: python.info,  Node: How do I obtain a copy of the Python source?,  Next: How do I get documentation on Python?,  Prev: How does the Python version numbering scheme work?,  Up: General Information

11.1.1.7 How do I obtain a copy of the Python source?
.....................................................

The latest Python source distribution is always available from
python.org, at <https://www.python.org/downloads/>.  The latest
development sources can be obtained via anonymous Mercurial access at
<https://hg.python.org/cpython>.

The source distribution is a gzipped tar file containing the complete C
source, Sphinx-formatted documentation, Python library modules, example
programs, and several useful pieces of freely distributable software.
The source will compile and run out of the box on most UNIX platforms.

Consult the Getting Started section of the Python Developer's Guide(1)
for more information on getting the source code and compiling it.

---------- Footnotes ----------

(1) https://docs.python.org/devguide/setup.html


File: python.info,  Node: How do I get documentation on Python?,  Next: I’ve never programmed before Is there a Python tutorial?,  Prev: How do I obtain a copy of the Python source?,  Up: General Information

11.1.1.8 How do I get documentation on Python?
..............................................

The standard documentation for the current stable version of Python is
available at <https://docs.python.org/3/>.  PDF, plain text, and
downloadable HTML versions are also available at
<https://docs.python.org/3/download.html>.

The documentation is written in reStructuredText and processed by the
Sphinx documentation tool(1).  The reStructuredText source for the
documentation is part of the Python source distribution.

---------- Footnotes ----------

(1) http://sphinx-doc.org/


File: python.info,  Node: I’ve never programmed before Is there a Python tutorial?,  Next: Is there a newsgroup or mailing list devoted to Python?,  Prev: How do I get documentation on Python?,  Up: General Information

11.1.1.9 I’ve never programmed before. Is there a Python tutorial?
....................................................................

There are numerous tutorials and books available.  The standard
documentation includes *Note The Python Tutorial: 514.

Consult the Beginner's Guide(1) to find information for beginning
Python programmers, including lists of tutorials.

---------- Footnotes ----------

(1) https://wiki.python.org/moin/BeginnersGuide


File: python.info,  Node: Is there a newsgroup or mailing list devoted to Python?,  Next: How do I get a beta test version of Python?,  Prev: I’ve never programmed before Is there a Python tutorial?,  Up: General Information

11.1.1.10 Is there a newsgroup or mailing list devoted to Python?
.................................................................

There is a newsgroup, `comp.lang.python', and a mailing list,
python-list(1).  The newsgroup and mailing list are gatewayed into each
other – if you can read news it’s unnecessary to subscribe to the
mailing list.  `comp.lang.python' is high-traffic, receiving hundreds
of postings every day, and Usenet readers are often more able to cope
with this volume.

Announcements of new software releases and events can be found in
comp.lang.python.announce, a low-traffic moderated list that receives
about five postings per day.  It’s available as the python-announce
mailing list(2).

More info about other mailing lists and newsgroups can be found at
<https://www.python.org/community/lists/>.

---------- Footnotes ----------

(1) https://mail.python.org/mailman/listinfo/python-list

(2) https://mail.python.org/mailman/listinfo/python-announce-list


File: python.info,  Node: How do I get a beta test version of Python?,  Next: How do I submit bug reports and patches for Python?,  Prev: Is there a newsgroup or mailing list devoted to Python?,  Up: General Information

11.1.1.11 How do I get a beta test version of Python?
.....................................................

Alpha and beta releases are available from
<https://www.python.org/downloads/>.  All releases are announced on the
comp.lang.python and comp.lang.python.announce newsgroups and on the
Python home page at <https://www.python.org/>; an RSS feed of news is
available.

You can also access the development version of Python through
Mercurial.  See <https://docs.python.org/devguide/faq.html> for details.


File: python.info,  Node: How do I submit bug reports and patches for Python?,  Next: Are there any published articles about Python that I can reference?,  Prev: How do I get a beta test version of Python?,  Up: General Information

11.1.1.12 How do I submit bug reports and patches for Python?
.............................................................

To report a bug or submit a patch, please use the Roundup installation
at <https://bugs.python.org/>.

You must have a Roundup account to report bugs; this makes it possible
for us to contact you if we have follow-up questions.  It will also
enable Roundup to send you updates as we act on your bug. If you had
previously used SourceForge to report bugs to Python, you can obtain
your Roundup password through Roundup’s password reset procedure(1).

For more information on how Python is developed, consult the Python
Developer's Guide(2).

---------- Footnotes ----------

(1) https://bugs.python.org/user?@template=forgotten

(2) https://docs.python.org/devguide/


File: python.info,  Node: Are there any published articles about Python that I can reference?,  Next: Are there any books on Python?,  Prev: How do I submit bug reports and patches for Python?,  Up: General Information

11.1.1.13 Are there any published articles about Python that I can reference?
.............................................................................

It’s probably best to cite your favorite book about Python.

The very first article about Python was written in 1991 and is now quite
outdated.

     Guido van Rossum and Jelke de Boer, “Interactively Testing
     Remote Servers Using the Python Programming Language”, CWI
     Quarterly, Volume 4, Issue 4 (December 1991), Amsterdam, pp
     283–303.


File: python.info,  Node: Are there any books on Python?,  Next: Where in the world is www python org located?,  Prev: Are there any published articles about Python that I can reference?,  Up: General Information

11.1.1.14 Are there any books on Python?
........................................

Yes, there are many, and more are being published.  See the python.org
wiki at <https://wiki.python.org/moin/PythonBooks> for a list.

You can also search online bookstores for “Python” and filter out
the Monty Python references; or perhaps search for “Python” and
“language”.


File: python.info,  Node: Where in the world is www python org located?,  Next: Why is it called Python?,  Prev: Are there any books on Python?,  Up: General Information

11.1.1.15 Where in the world is www.python.org located?
.......................................................

The Python project’s infrastructure is located all over the world.
www.python.org(1) is graciously hosted by Rackspace(2), with CDN
caching provided by Fastly(3).  Upfront Systems(4) hosts
bugs.python.org(5).  Many other Python services like the Wiki(6) are
hosted by Oregon State University Open Source Lab(7).

---------- Footnotes ----------

(1) https://www.python.org

(2) https://www.rackspace.com

(3) https://www.fastly.com

(4) http://www.upfrontsystems.co.za/

(5) https://bugs.python.org

(6) https://wiki.python.org

(7) https://osuosl.org


File: python.info,  Node: Why is it called Python?,  Next: Do I have to like “Monty Python’s Flying Circus”?,  Prev: Where in the world is www python org located?,  Up: General Information

11.1.1.16 Why is it called Python?
..................................

When he began implementing Python, Guido van Rossum was also reading the
published scripts from "Monty Python's Flying Circus"(1), a BBC comedy
series from the 1970s.  Van Rossum thought he needed a name that was
short, unique, and slightly mysterious, so he decided to call the
language Python.

---------- Footnotes ----------

(1) https://en.wikipedia.org/wiki/Monty_Python


File: python.info,  Node: Do I have to like “Monty Python’s Flying Circus”?,  Prev: Why is it called Python?,  Up: General Information

11.1.1.17 Do I have to like “Monty Python’s Flying Circus”?
.................................................................

No, but it helps.  :)


File: python.info,  Node: Python in the real world,  Next: Upgrading Python,  Prev: General Information,  Up: General Python FAQ

11.1.2 Python in the real world
-------------------------------

* Menu:

* How stable is Python?::
* How many people are using Python?::
* Have any significant projects been done in Python?::
* What new developments are expected for Python in the future?::
* Is it reasonable to propose incompatible changes to Python?::
* Is Python a good language for beginning programmers?::


File: python.info,  Node: How stable is Python?,  Next: How many people are using Python?,  Up: Python in the real world

11.1.2.1 How stable is Python?
..............................

Very stable.  New, stable releases have been coming out roughly every 6
to 18 months since 1991, and this seems likely to continue.  Currently
there are usually around 18 months between major releases.

The developers issue “bugfix” releases of older versions, so the
stability of existing releases gradually improves.  Bugfix releases,
indicated by a third component of the version number (e.g. 2.5.3,
2.6.2), are managed for stability; only fixes for known problems are
included in a bugfix release, and it’s guaranteed that interfaces
will remain the same throughout a series of bugfix releases.

The latest stable releases can always be found on the Python download
page(1).  There are two recommended production-ready versions at this
point in time, because at the moment there are two branches of stable
releases: 2.x and 3.x.  Python 3.x may be less useful than 2.x, since
currently there is more third party software available for Python 2
than for Python 3.  Python 2 code will generally not run unchanged in
Python 3.

---------- Footnotes ----------

(1) https://www.python.org/downloads/


File: python.info,  Node: How many people are using Python?,  Next: Have any significant projects been done in Python?,  Prev: How stable is Python?,  Up: Python in the real world

11.1.2.2 How many people are using Python?
..........................................

There are probably tens of thousands of users, though it’s difficult
to obtain an exact count.

Python is available for free download, so there are no sales figures,
and it’s available from many different sites and packaged with many
Linux distributions, so download statistics don’t tell the whole
story either.

The comp.lang.python newsgroup is very active, but not all Python users
post to the group or even read it.


File: python.info,  Node: Have any significant projects been done in Python?,  Next: What new developments are expected for Python in the future?,  Prev: How many people are using Python?,  Up: Python in the real world

11.1.2.3 Have any significant projects been done in Python?
...........................................................

See <https://www.python.org/about/success> for a list of projects that
use Python.  Consulting the proceedings for past Python conferences(1)
will reveal contributions from many different companies and
organizations.

High-profile Python projects include the Mailman mailing list
manager(2) and the Zope application server(3).  Several Linux
distributions, most notably Red Hat(4), have written part or all of
their installer and system administration software in Python.
Companies that use Python internally include Google, Yahoo, and
Lucasfilm Ltd.

---------- Footnotes ----------

(1) https://www.python.org/community/workshops/

(2) http://www.list.org

(3) http://www.zope.org

(4) https://www.redhat.com


File: python.info,  Node: What new developments are expected for Python in the future?,  Next: Is it reasonable to propose incompatible changes to Python?,  Prev: Have any significant projects been done in Python?,  Up: Python in the real world

11.1.2.4 What new developments are expected for Python in the future?
.....................................................................

See <https://www.python.org/dev/peps/> for the Python Enhancement
Proposals (PEPs). PEPs are design documents describing a suggested new
feature for Python, providing a concise technical specification and a
rationale.  Look for a PEP titled “Python X.Y Release Schedule”,
where X.Y is a version that hasn’t been publicly released yet.

New development is discussed on the python-dev mailing list(1).

---------- Footnotes ----------

(1) https://mail.python.org/mailman/listinfo/python-dev/


File: python.info,  Node: Is it reasonable to propose incompatible changes to Python?,  Next: Is Python a good language for beginning programmers?,  Prev: What new developments are expected for Python in the future?,  Up: Python in the real world

11.1.2.5 Is it reasonable to propose incompatible changes to Python?
....................................................................

In general, no.  There are already millions of lines of Python code
around the world, so any change in the language that invalidates more
than a very small fraction of existing programs has to be frowned upon.
Even if you can provide a conversion program, there’s still the
problem of updating all documentation; many books have been written
about Python, and we don’t want to invalidate them all at a single
stroke.

Providing a gradual upgrade path is necessary if a feature has to be
changed.  PEP 5(1) describes the procedure followed for introducing
backward-incompatible changes while minimizing disruption for users.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0005


File: python.info,  Node: Is Python a good language for beginning programmers?,  Prev: Is it reasonable to propose incompatible changes to Python?,  Up: Python in the real world

11.1.2.6 Is Python a good language for beginning programmers?
.............................................................

Yes.

It is still common to start students with a procedural and statically
typed language such as Pascal, C, or a subset of C++ or Java.  Students
may be better served by learning Python as their first language.
Python has a very simple and consistent syntax and a large standard
library and, most importantly, using Python in a beginning programming
course lets students concentrate on important programming skills such
as problem decomposition and data type design.  With Python, students
can be quickly introduced to basic concepts such as loops and
procedures.  They can probably even work with user-defined objects in
their very first course.

For a student who has never programmed before, using a statically typed
language seems unnatural.  It presents additional complexity that the
student must master and slows the pace of the course.  The students are
trying to learn to think like a computer, decompose problems, design
consistent interfaces, and encapsulate data.  While learning to use a
statically typed language is important in the long term, it is not
necessarily the best topic to address in the students’ first
programming course.

Many other aspects of Python make it a good first language.  Like Java,
Python has a large standard library so that students can be assigned
programming projects very early in the course that `do' something.
Assignments aren’t restricted to the standard four-function
calculator and check balancing programs.  By using the standard
library, students can gain the satisfaction of working on realistic
applications as they learn the fundamentals of programming.  Using the
standard library also teaches students about code reuse.  Third-party
modules such as PyGame are also helpful in extending the students’
reach.

Python’s interactive interpreter enables students to test language
features while they’re programming.  They can keep a window with the
interpreter running while they enter their program’s source in
another window.  If they can’t remember the methods for a list, they
can do something like this:

    >>> L = []
    >>> dir(L) # doctest: +NORMALIZE_WHITESPACE
    ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',
    '__delslice__', '__doc__', '__eq__', '__format__', '__ge__',
    '__getattribute__', '__getitem__', '__getslice__', '__gt__',
    '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__',
    '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__',
    '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',
    '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__',
    '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert',
    'pop', 'remove', 'reverse', 'sort']
    >>> help(L.append)
    Help on built-in function append:
    <BLANKLINE>
    append(...)
        L.append(object) -- append object to end
    <BLANKLINE>
    >>> L.append(1)
    >>> L
    [1]

With the interpreter, documentation is never far from the student as
he’s programming.

There are also good IDEs for Python.  IDLE is a cross-platform IDE for
Python that is written in Python using Tkinter.  PythonWin is a
Windows-specific IDE.  Emacs users will be happy to know that there is
a very good Python mode for Emacs.  All of these programming
environments provide syntax highlighting, auto-indenting, and access to
the interactive interpreter while coding.  Consult the Python wiki(1)
for a full list of Python editing environments.

If you want to discuss Python’s use in education, you may be
interested in joining the edu-sig mailing list(2).

---------- Footnotes ----------

(1) https://wiki.python.org/moin/PythonEditors

(2) https://www.python.org/community/sigs/current/edu-sig


File: python.info,  Node: Upgrading Python,  Prev: Python in the real world,  Up: General Python FAQ

11.1.3 Upgrading Python
-----------------------

* Menu:

* What is this bsddb185 module my application keeps complaining about?::


File: python.info,  Node: What is this bsddb185 module my application keeps complaining about?,  Up: Upgrading Python

11.1.3.1 What is this bsddb185 module my application keeps complaining about?
.............................................................................

Starting with Python2.3, the distribution includes the `PyBSDDB package
<http://pybsddb.sf.net/>' as a replacement for the old bsddb module.  It
includes functions which provide backward compatibility at the API
level, but requires a newer version of the underlying Berkeley DB(1)
library.  Files created with the older bsddb module can’t be opened
directly using the new module.

Using your old version of Python and a pair of scripts which are part
of Python 2.3 (db2pickle.py and pickle2db.py, in the Tools/scripts
directory) you can convert your old database files to the new format.
Using your old Python version, run the db2pickle.py script to convert
it to a pickle, e.g.:

    python2.2 <pathto>/db2pickley.py database.db database.pck

Rename your database file:

    mv database.db olddatabase.db

Now convert the pickle file to a new format database:

    python <pathto>/pickle2db.py database.db database.pck

The precise commands you use will vary depending on the particulars of
your installation.  For full details about operation of these two
scripts check the doc string at the start of each one.

---------- Footnotes ----------

(1) http://www.sleepycat.com


File: python.info,  Node: Programming FAQ,  Next: Design and History FAQ,  Prev: General Python FAQ,  Up: Python Frequently Asked Questions

11.2 Programming FAQ
====================

* Menu:

* General Questions::
* Core Language::
* Numbers and strings::
* Sequences (Tuples/Lists): Sequences Tuples/Lists.
* Dictionaries: Dictionaries<2>.
* Objects::
* Modules: Modules<3>.


File: python.info,  Node: General Questions,  Next: Core Language,  Up: Programming FAQ

11.2.1 General Questions
------------------------

* Menu:

* Is there a source code level debugger with breakpoints, single-stepping, etc.?: Is there a source code level debugger with breakpoints single-stepping etc ?.
* Is there a tool to help find bugs or perform static analysis?::
* How can I create a stand-alone binary from a Python script?::
* Are there coding standards or a style guide for Python programs?::
* My program is too slow. How do I speed it up?: My program is too slow How do I speed it up?.


File: python.info,  Node: Is there a source code level debugger with breakpoints single-stepping etc ?,  Next: Is there a tool to help find bugs or perform static analysis?,  Up: General Questions

11.2.1.1 Is there a source code level debugger with breakpoints, single-stepping, etc.?
.......................................................................................

Yes.

The pdb module is a simple but adequate console-mode debugger for
Python. It is part of the standard Python library, and is *Note
documented in the Library Reference Manual: 12d. You can also write
your own debugger by using the code for pdb as an example.

The IDLE interactive development environment, which is part of the
standard Python distribution (normally available as
Tools/scripts/idle), includes a graphical debugger.

PythonWin is a Python IDE that includes a GUI debugger based on pdb.
The Pythonwin debugger colors breakpoints and has quite a few cool
features such as debugging non-Pythonwin programs.  Pythonwin is
available as part of the Python for Windows Extensions(1) project and
as a part of the ActivePython distribution (see
<https://www.activestate.com/activepython>).

Boa Constructor(2) is an IDE and GUI builder that uses wxWidgets.  It
offers visual frame creation and manipulation, an object inspector,
many views on the source like object browsers, inheritance hierarchies,
doc string generated html documentation, an advanced debugger,
integrated help, and Zope support.

Eric(3) is an IDE built on PyQt and the Scintilla editing component.

Pydb is a version of the standard Python debugger pdb, modified for use
with DDD (Data Display Debugger), a popular graphical debugger front
end.  Pydb can be found at <http://bashdb.sourceforge.net/pydb/> and
DDD can be found at <https://www.gnu.org/software/ddd>.

There are a number of commercial Python IDEs that include graphical
debuggers.  They include:

   * Wing IDE (<https://wingware.com/>)

   * Komodo IDE (<https://komodoide.com/>)

   * PyCharm (<https://www.jetbrains.com/pycharm/>)

---------- Footnotes ----------

(1) https://sourceforge.net/projects/pywin32/

(2) http://boa-constructor.sourceforge.net/

(3) http://eric-ide.python-projects.org/


File: python.info,  Node: Is there a tool to help find bugs or perform static analysis?,  Next: How can I create a stand-alone binary from a Python script?,  Prev: Is there a source code level debugger with breakpoints single-stepping etc ?,  Up: General Questions

11.2.1.2 Is there a tool to help find bugs or perform static analysis?
......................................................................

Yes.

PyChecker is a static analysis tool that finds bugs in Python source
code and warns about code complexity and style.  You can get PyChecker
from <http://pychecker.sourceforge.net/>.

Pylint(1) is another tool that checks if a module satisfies a coding
standard, and also makes it possible to write plug-ins to add a custom
feature.  In addition to the bug checking that PyChecker performs,
Pylint offers some additional features such as checking line length,
whether variable names are well-formed according to your coding
standard, whether declared interfaces are fully implemented, and more.
<https://docs.pylint.org/> provides a full list of Pylint’s features.

---------- Footnotes ----------

(1) https://www.pylint.org/


File: python.info,  Node: How can I create a stand-alone binary from a Python script?,  Next: Are there coding standards or a style guide for Python programs?,  Prev: Is there a tool to help find bugs or perform static analysis?,  Up: General Questions

11.2.1.3 How can I create a stand-alone binary from a Python script?
....................................................................

You don’t need the ability to compile Python to C code if all you
want is a stand-alone program that users can download and run without
having to install the Python distribution first.  There are a number of
tools that determine the set of modules required by a program and bind
these modules together with a Python binary to produce a single
executable.

One is to use the freeze tool, which is included in the Python source
tree as `Tools/freeze'. It converts Python byte code to C arrays; a C
compiler you can embed all your modules into a new program, which is
then linked with the standard Python modules.

It works by scanning your source recursively for import statements (in
both forms) and looking for the modules in the standard Python path as
well as in the source directory (for built-in modules).  It then turns
the bytecode for modules written in Python into C code (array
initializers that can be turned into code objects using the marshal
module) and creates a custom-made config file that only contains those
built-in modules which are actually used in the program.  It then
compiles the generated C code and links it with the rest of the Python
interpreter to form a self-contained binary which acts exactly like
your script.

Obviously, freeze requires a C compiler.  There are several other
utilities which don’t. One is Thomas Heller’s py2exe (Windows only)
at

     <http://www.py2exe.org/>

Another tool is Anthony Tuininga’s cx_Freeze(1).

---------- Footnotes ----------

(1) http://cx-freeze.sourceforge.net/


File: python.info,  Node: Are there coding standards or a style guide for Python programs?,  Next: My program is too slow How do I speed it up?,  Prev: How can I create a stand-alone binary from a Python script?,  Up: General Questions

11.2.1.4 Are there coding standards or a style guide for Python programs?
.........................................................................

Yes.  The coding style required for standard library modules is
documented as PEP 8(1).

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0008


File: python.info,  Node: My program is too slow How do I speed it up?,  Prev: Are there coding standards or a style guide for Python programs?,  Up: General Questions

11.2.1.5 My program is too slow. How do I speed it up?
......................................................

That’s a tough one, in general.  There are many tricks to speed up
Python code; consider rewriting parts in C as a last resort.

In some cases it’s possible to automatically translate Python to C or
x86 assembly language, meaning that you don’t have to modify your
code to gain increased speed.

Pyrex(1) can compile a slightly modified version of Python code into a
C extension, and can be used on many different platforms.

Psyco(2) is a just-in-time compiler that translates Python code into
x86 assembly language.  If you can use it, Psyco can provide dramatic
speedups for critical functions.

The rest of this answer will discuss various tricks for squeezing a bit
more speed out of Python code.  `Never' apply any optimization tricks
unless you know you need them, after profiling has indicated that a
particular function is the heavily executed hot spot in the code.
Optimizations almost always make the code less clear, and you
shouldn’t pay the costs of reduced clarity (increased development
time, greater likelihood of bugs) unless the resulting performance
benefit is worth it.

There is a page on the wiki devoted to performance tips(3).

Guido van Rossum has written up an anecdote related to optimization at
<https://www.python.org/doc/essays/list2str>.

One thing to notice is that function and (especially) method calls are
rather expensive; if you have designed a purely OO interface with lots
of tiny functions that don’t do much more than get or set an instance
variable or call another method, you might consider using a more direct
way such as directly accessing instance variables.  Also see the
standard module *Note profile: 13a. which makes it possible to find out
where your program is spending most of its time (if you have some
patience – the profiling itself can slow your program down by an
order of magnitude).

Remember that many standard optimization heuristics you may know from
other programming experience may well apply to Python.  For example it
may be faster to send output to output devices using larger writes
rather than smaller ones in order to reduce the overhead of kernel
system calls.  Thus CGI scripts that write all output in “one shot”
may be faster than those that write lots of small pieces of output.

Also, be sure to use Python’s core features where appropriate.  For
example, slicing allows programs to chop up lists and other sequence
objects in a single tick of the interpreter’s mainloop using highly
optimized C implementations.  Thus to get the same effect as:

    L2 = []
    for i in range(3):
        L2.append(L1[i])

it is much shorter and far faster to use

    L2 = list(L1[:3])  # "list" is redundant if L1 is a list.

Note that the functionally-oriented built-in functions such as *Note
map(): 318, *Note zip(): 41e, and friends can be a convenient
accelerator for loops that perform a single task.  For example to pair
the elements of two lists together:

    >>> zip([1, 2, 3], [4, 5, 6])
    [(1, 4), (2, 5), (3, 6)]

or to compute a number of sines:

    >>> map(math.sin, (1, 2, 3, 4))
    [0.841470984808, 0.909297426826, 0.14112000806, -0.756802495308]

The operation completes very quickly in such cases.

Other examples include the `join()' and `split()' *Note methods of
string objects: 53e.  For example if s1..s7 are large (10K+) strings
then `"".join([s1,s2,s3,s4,s5,s6,s7])' may be far faster than the more
obvious `s1+s2+s3+s4+s5+s6+s7', since the “summation” will compute
many subexpressions, whereas `join()' does all the copying in one pass.
For manipulating strings, use the `replace()' and the `format()' *Note
methods on string objects: 53e.  Use regular expressions only when
you’re not dealing with constant string patterns.  You may still use
*Note the old % operations: 53f. `string % tuple' and `string %
dictionary'.

Be sure to use the `list.sort()' built-in method to do sorting, and see
the sorting mini-HOWTO(4) for examples of moderately advanced usage.
`list.sort()' beats other techniques for sorting in all but the most
extreme circumstances.

Another common trick is to “push loops into functions or methods.”
For example suppose you have a program that runs slowly and you use the
profiler to determine that a Python function `ff()' is being called
lots of times.  If you notice that `ff()':

    def ff(x):
        ... # do something with x computing result...
        return result

tends to be called in loops like:

    list = map(ff, oldlist)

or:

    for x in sequence:
        value = ff(x)
        ... # do something with value...

then you can often eliminate function call overhead by rewriting `ff()'
to:

    def ffseq(seq):
        resultseq = []
        for x in seq:
            ... # do something with x computing result...
            resultseq.append(result)
        return resultseq

and rewrite the two examples to `list = ffseq(oldlist)' and to:

    for value in ffseq(sequence):
        ... # do something with value...

Single calls to `ff(x)' translate to `ffseq([x])[0]' with little
penalty.  Of course this technique is not always appropriate and there
are other variants which you can figure out.

You can gain some performance by explicitly storing the results of a
function or method lookup into a local variable.  A loop like:

    for key in token:
        dict[key] = dict.get(key, 0) + 1

resolves `dict.get' every iteration.  If the method isn’t going to
change, a slightly faster implementation is:

    dict_get = dict.get  # look up the method once
    for key in token:
        dict[key] = dict_get(key, 0) + 1

Default arguments can be used to determine values once, at compile time
instead of at run time.  This can only be done for functions or objects
which will not be changed during program execution, such as replacing

    def degree_sin(deg):
        return math.sin(deg * math.pi / 180.0)

with

    def degree_sin(deg, factor=math.pi/180.0, sin=math.sin):
        return sin(deg * factor)

Because this trick uses default arguments for terms which should not be
changed, it should only be used when you are not concerned with
presenting a possibly confusing API to your users.

---------- Footnotes ----------

(1) http://www.cosc.canterbury.ac.nz/~greg/python/Pyrex/

(2) http://psyco.sourceforge.net

(3) https://wiki.python.org/moin/PythonSpeed/PerformanceTips

(4) https://wiki.python.org/moin/HowTo/Sorting


File: python.info,  Node: Core Language,  Next: Numbers and strings,  Prev: General Questions,  Up: Programming FAQ

11.2.2 Core Language
--------------------

* Menu:

* Why am I getting an UnboundLocalError when the variable has a value?::
* What are the rules for local and global variables in Python?::
* Why do lambdas defined in a loop with different values all return the same result?::
* How do I share global variables across modules?::
* What are the “best practices” for using import in a module?::
* Why are default values shared between objects?::
* How can I pass optional or keyword parameters from one function to another?::
* What is the difference between arguments and parameters?::
* Why did changing list ‘y’ also change list ‘x’?::
* How do I write a function with output parameters (call by reference)?: How do I write a function with output parameters call by reference ?.
* How do you make a higher order function in Python?::
* How do I copy an object in Python?::
* How can I find the methods or attributes of an object?::
* How can my code discover the name of an object?::
* What’s up with the comma operator’s precedence?::
* Is there an equivalent of C’s “?;” ternary operator?: Is there an equivalent of C’s “? ” ternary operator?.
* Is it possible to write obfuscated one-liners in Python?::


File: python.info,  Node: Why am I getting an UnboundLocalError when the variable has a value?,  Next: What are the rules for local and global variables in Python?,  Up: Core Language

11.2.2.1 Why am I getting an UnboundLocalError when the variable has a value?
.............................................................................

It can be a surprise to get the UnboundLocalError in previously working
code when it is modified by adding an assignment statement somewhere in
the body of a function.

This code:

    >>> x = 10
    >>> def bar():
    ...     print x
    >>> bar()
    10

works, but this code:

    >>> x = 10
    >>> def foo():
    ...     print x
    ...     x += 1

results in an UnboundLocalError:

    >>> foo()
    Traceback (most recent call last):
      ...
    UnboundLocalError: local variable 'x' referenced before assignment

This is because when you make an assignment to a variable in a scope,
that variable becomes local to that scope and shadows any similarly
named variable in the outer scope.  Since the last statement in foo
assigns a new value to `x', the compiler recognizes it as a local
variable.  Consequently when the earlier `print x' attempts to print
the uninitialized local variable and an error results.

In the example above you can access the outer scope variable by
declaring it global:

    >>> x = 10
    >>> def foobar():
    ...     global x
    ...     print x
    ...     x += 1
    >>> foobar()
    10

This explicit declaration is required in order to remind you that
(unlike the superficially analogous situation with class and instance
variables) you are actually modifying the value of the variable in the
outer scope:

    >>> print x
    11


File: python.info,  Node: What are the rules for local and global variables in Python?,  Next: Why do lambdas defined in a loop with different values all return the same result?,  Prev: Why am I getting an UnboundLocalError when the variable has a value?,  Up: Core Language

11.2.2.2 What are the rules for local and global variables in Python?
.....................................................................

In Python, variables that are only referenced inside a function are
implicitly global.  If a variable is assigned a value anywhere within
the function’s body, it’s assumed to be a local unless explicitly
declared as global.

Though a bit surprising at first, a moment’s consideration explains
this.  On one hand, requiring *Note global: 560. for assigned variables
provides a bar against unintended side-effects.  On the other hand, if
`global' was required for all global references, you’d be using
`global' all the time.  You’d have to declare as global every
reference to a built-in function or to a component of an imported
module.  This clutter would defeat the usefulness of the `global'
declaration for identifying side-effects.


File: python.info,  Node: Why do lambdas defined in a loop with different values all return the same result?,  Next: How do I share global variables across modules?,  Prev: What are the rules for local and global variables in Python?,  Up: Core Language

11.2.2.3 Why do lambdas defined in a loop with different values all return the same result?
...........................................................................................

Assume you use a for loop to define a few different lambdas (or even
plain functions), e.g.:

    >>> squares = []
    >>> for x in range(5):
    ...     squares.append(lambda: x**2)

This gives you a list that contains 5 lambdas that calculate `x**2'.
You might expect that, when called, they would return, respectively,
`0', `1', `4', `9', and `16'.  However, when you actually try you will
see that they all return `16':

    >>> squares[2]()
    16
    >>> squares[4]()
    16

This happens because `x' is not local to the lambdas, but is defined in
the outer scope, and it is accessed when the lambda is called — not
when it is defined.  At the end of the loop, the value of `x' is `4',
so all the functions now return `4**2', i.e. `16'.  You can also verify
this by changing the value of `x' and see how the results of the
lambdas change:

    >>> x = 8
    >>> squares[2]()
    64

In order to avoid this, you need to save the values in variables local
to the lambdas, so that they don’t rely on the value of the global
`x':

    >>> squares = []
    >>> for x in range(5):
    ...     squares.append(lambda n=x: n**2)

Here, `n=x' creates a new variable `n' local to the lambda and computed
when the lambda is defined so that it has the same value that `x' had at
that point in the loop.  This means that the value of `n' will be `0'
in the first lambda, `1' in the second, `2' in the third, and so on.
Therefore each lambda will now return the correct result:

    >>> squares[2]()
    4
    >>> squares[4]()
    16

Note that this behaviour is not peculiar to lambdas, but applies to
regular functions too.


File: python.info,  Node: How do I share global variables across modules?,  Next: What are the “best practices” for using import in a module?,  Prev: Why do lambdas defined in a loop with different values all return the same result?,  Up: Core Language

11.2.2.4 How do I share global variables across modules?
........................................................

The canonical way to share information across modules within a single
program is to create a special module (often called config or cfg).
Just import the config module in all modules of your application; the
module then becomes available as a global name.  Because there is only
one instance of each module, any changes made to the module object get
reflected everywhere.  For example:

config.py:

    x = 0   # Default value of the 'x' configuration setting

mod.py:

    import config
    config.x = 1

main.py:

    import config
    import mod
    print config.x

Note that using a module is also the basis for implementing the
Singleton design pattern, for the same reason.


File: python.info,  Node: What are the “best practices” for using import in a module?,  Next: Why are default values shared between objects?,  Prev: How do I share global variables across modules?,  Up: Core Language

11.2.2.5 What are the “best practices” for using import in a module?
........................................................................

In general, don’t use `from modulename import *'.  Doing so clutters
the importer’s namespace, and makes it much harder for linters to
detect undefined names.

Import modules at the top of a file.  Doing so makes it clear what
other modules your code requires and avoids questions of whether the
module name is in scope.  Using one import per line makes it easy to
add and delete module imports, but using multiple imports per line uses
less screen space.

It’s good practice if you import modules in the following order:

  1. standard library modules – e.g. `sys', `os', `getopt', `re'

  2. third-party library modules (anything installed in Python’s
     site-packages directory) – e.g. mx.DateTime, ZODB, PIL.Image,
     etc.

  3. locally-developed modules

Only use explicit relative package imports.  If you’re writing code
that’s in the `package.sub.m1' module and want to import
`package.sub.m2', do not just write `import m2', even though it’s
legal.  Write `from package.sub import m2' or `from . import m2'
instead.

It is sometimes necessary to move imports to a function or class to
avoid problems with circular imports.  Gordon McMillan says:

     Circular imports are fine where both modules use the “import
     <module>” form of import.  They fail when the 2nd module wants
     to grab a name out of the first (“from module import name”)
     and the import is at the top level.  That’s because names in the
     1st are not yet available, because the first module is busy
     importing the 2nd.

In this case, if the second module is only used in one function, then
the import can easily be moved into that function.  By the time the
import is called, the first module will have finished initializing, and
the second module can do its import.

It may also be necessary to move imports out of the top level of code
if some of the modules are platform-specific.  In that case, it may not
even be possible to import all of the modules at the top of the file.
In this case, importing the correct modules in the corresponding
platform-specific code is a good option.

Only move imports into a local scope, such as inside a function
definition, if it’s necessary to solve a problem such as avoiding a
circular import or are trying to reduce the initialization time of a
module.  This technique is especially helpful if many of the imports
are unnecessary depending on how the program executes.  You may also
want to move imports into a function if the modules are only ever used
in that function.  Note that loading a module the first time may be
expensive because of the one time initialization of the module, but
loading a module multiple times is virtually free, costing only a
couple of dictionary lookups.  Even if the module name has gone out of
scope, the module is probably available in *Note sys.modules: 84c.


File: python.info,  Node: Why are default values shared between objects?,  Next: How can I pass optional or keyword parameters from one function to another?,  Prev: What are the “best practices” for using import in a module?,  Up: Core Language

11.2.2.6 Why are default values shared between objects?
.......................................................

This type of bug commonly bites neophyte programmers.  Consider this
function:

    def foo(mydict={}):  # Danger: shared reference to one dict for all calls
        ... compute something ...
        mydict[key] = value
        return mydict

The first time you call this function, `mydict' contains a single item.
The second time, `mydict' contains two items because when `foo()'
begins executing, `mydict' starts out with an item already in it.

It is often expected that a function call creates new objects for
default values. This is not what happens. Default values are created
exactly once, when the function is defined.  If that object is changed,
like the dictionary in this example, subsequent calls to the function
will refer to this changed object.

By definition, immutable objects such as numbers, strings, tuples, and
`None', are safe from change. Changes to mutable objects such as
dictionaries, lists, and class instances can lead to confusion.

Because of this feature, it is good programming practice to not use
mutable objects as default values.  Instead, use `None' as the default
value and inside the function, check if the parameter is `None' and
create a new list/dictionary/whatever if it is.  For example, don’t
write:

    def foo(mydict={}):
        ...

but:

    def foo(mydict=None):
        if mydict is None:
            mydict = {}  # create a new dict for local namespace

This feature can be useful.  When you have a function that’s
time-consuming to compute, a common technique is to cache the
parameters and the resulting value of each call to the function, and
return the cached value if the same value is requested again.  This is
called “memoizing”, and can be implemented like this:

    # Callers will never provide a third parameter for this function.
    def expensive(arg1, arg2, _cache={}):
        if (arg1, arg2) in _cache:
            return _cache[(arg1, arg2)]

        # Calculate the value
        result = ... expensive computation ...
        _cache[(arg1, arg2)] = result           # Store result in the cache
        return result

You could use a global variable containing a dictionary instead of the
default value; it’s a matter of taste.


File: python.info,  Node: How can I pass optional or keyword parameters from one function to another?,  Next: What is the difference between arguments and parameters?,  Prev: Why are default values shared between objects?,  Up: Core Language

11.2.2.7 How can I pass optional or keyword parameters from one function to another?
....................................................................................

Collect the arguments using the `*' and `**' specifiers in the
function’s parameter list; this gives you the positional arguments as
a tuple and the keyword arguments as a dictionary.  You can then pass
these arguments when calling another function by using `*' and `**':

    def f(x, *args, **kwargs):
        ...
        kwargs['width'] = '14.3c'
        ...
        g(x, *args, **kwargs)

In the unlikely case that you care about Python versions older than
2.0, use *Note apply(): 317.:

    def f(x, *args, **kwargs):
        ...
        kwargs['width'] = '14.3c'
        ...
        apply(g, (x,)+args, kwargs)


File: python.info,  Node: What is the difference between arguments and parameters?,  Next: Why did changing list ‘y’ also change list ‘x’?,  Prev: How can I pass optional or keyword parameters from one function to another?,  Up: Core Language

11.2.2.8 What is the difference between arguments and parameters?
.................................................................

*Note Parameters: 7ef. are defined by the names that appear in a
function definition, whereas *Note arguments: 7e9. are the values
actually passed to a function when calling it.  Parameters define what
types of arguments a function can accept.  For example, given the
function definition:

    def func(foo, bar=None, **kwargs):
        pass

`foo', `bar' and `kwargs' are parameters of `func'.  However, when
calling `func', for example:

    func(42, bar=314, extra=somevar)

the values `42', `314', and `somevar' are arguments.


File: python.info,  Node: Why did changing list ‘y’ also change list ‘x’?,  Next: How do I write a function with output parameters call by reference ?,  Prev: What is the difference between arguments and parameters?,  Up: Core Language

11.2.2.9 Why did changing list ‘y’ also change list ‘x’?
................................................................

If you wrote code like:

    >>> x = []
    >>> y = x
    >>> y.append(10)
    >>> y
    [10]
    >>> x
    [10]

you might be wondering why appending an element to `y' changed `x' too.

There are two factors that produce this result:

  1. Variables are simply names that refer to objects.  Doing `y = x'
     doesn’t create a copy of the list – it creates a new variable
     `y' that refers to the same object `x' refers to.  This means that
     there is only one object (the list), and both `x' and `y' refer to
     it.

  2. Lists are *Note mutable: 545, which means that you can change
     their content.

After the call to `append()', the content of the mutable object has
changed from `[]' to `[10]'.  Since both the variables refer to the same
object, using either name accesses the modified value `[10]'.

If we instead assign an immutable object to `x':

    >>> x = 5  # ints are immutable
    >>> y = x
    >>> x = x + 1  # 5 can't be mutated, we are creating a new object here
    >>> x
    6
    >>> y
    5

we can see that in this case `x' and `y' are not equal anymore.  This is
because integers are *Note immutable: 53b, and when we do `x = x + 1'
we are not mutating the int `5' by incrementing its value; instead, we
are creating a new object (the int `6') and assigning it to `x' (that
is, changing which object `x' refers to).  After this assignment we
have two objects (the ints `6' and `5') and two variables that refer to
them (`x' now refers to `6' but `y' still refers to `5').

Some operations (for example `y.append(10)' and `y.sort()') mutate the
object, whereas superficially similar operations (for example `y = y +
[10]' and `sorted(y)') create a new object.  In general in Python (and
in all cases in the standard library) a method that mutates an object
will return `None' to help avoid getting the two types of operations
confused.  So if you mistakenly write `y.sort()' thinking it will give
you a sorted copy of `y', you’ll instead end up with `None', which
will likely cause your program to generate an easily diagnosed error.

However, there is one class of operations where the same operation
sometimes has different behaviors with different types:  the augmented
assignment operators.  For example, `+=' mutates lists but not tuples
or ints (`a_list += [1, 2, 3]' is equivalent to `a_list.extend([1, 2,
3])' and mutates `a_list', whereas `some_tuple += (1, 2, 3)' and
`some_int += 1' create new objects).

In other words:

   * If we have a mutable object (*Note list: 3d6, *Note dict: 319,
     *Note set: 382, etc.), we can use some specific operations to
     mutate it and all the variables that refer to it will see the
     change.

   * If we have an immutable object (*Note str: 1ea, *Note int: 1f2,
     *Note tuple: 421, etc.), all the variables that refer to it will
     always see the same value, but operations that transform that
     value into a new value always return a new object.

If you want to know if two variables refer to the same object or not,
you can use the *Note is: 717. operator, or the built-in function *Note
id(): 3ca.


File: python.info,  Node: How do I write a function with output parameters call by reference ?,  Next: How do you make a higher order function in Python?,  Prev: Why did changing list ‘y’ also change list ‘x’?,  Up: Core Language

11.2.2.10 How do I write a function with output parameters (call by reference)?
...............................................................................

Remember that arguments are passed by assignment in Python.  Since
assignment just creates references to objects, there’s no alias
between an argument name in the caller and callee, and so no
call-by-reference per se.  You can achieve the desired effect in a
number of ways.

  1. By returning a tuple of the results:

         def func2(a, b):
             a = 'new-value'        # a and b are local names
             b = b + 1              # assigned to new objects
             return a, b            # return new values

         x, y = 'old-value', 99
         x, y = func2(x, y)
         print x, y                 # output: new-value 100

     This is almost always the clearest solution.

  2. By using global variables.  This isn’t thread-safe, and is not
     recommended.

  3. By passing a mutable (changeable in-place) object:

         def func1(a):
             a[0] = 'new-value'     # 'a' references a mutable list
             a[1] = a[1] + 1        # changes a shared object

         args = ['old-value', 99]
         func1(args)
         print args[0], args[1]     # output: new-value 100

  4. By passing in a dictionary that gets mutated:

         def func3(args):
             args['a'] = 'new-value'     # args is a mutable dictionary
             args['b'] = args['b'] + 1   # change it in-place

         args = {'a': 'old-value', 'b': 99}
         func3(args)
         print args['a'], args['b']

  5. Or bundle up values in a class instance:

         class callByRef:
             def __init__(self, **args):
                 for (key, value) in args.items():
                     setattr(self, key, value)

         def func4(args):
             args.a = 'new-value'        # args is a mutable callByRef
             args.b = args.b + 1         # change object in-place

         args = callByRef(a='old-value', b=99)
         func4(args)
         print args.a, args.b

     There’s almost never a good reason to get this complicated.

Your best choice is to return a tuple containing the multiple results.


File: python.info,  Node: How do you make a higher order function in Python?,  Next: How do I copy an object in Python?,  Prev: How do I write a function with output parameters call by reference ?,  Up: Core Language

11.2.2.11 How do you make a higher order function in Python?
............................................................

You have two choices: you can use nested scopes or you can use callable
objects.  For example, suppose you wanted to define `linear(a,b)' which
returns a function `f(x)' that computes the value `a*x+b'.  Using
nested scopes:

    def linear(a, b):
        def result(x):
            return a * x + b
        return result

Or using a callable object:

    class linear:

        def __init__(self, a, b):
            self.a, self.b = a, b

        def __call__(self, x):
            return self.a * x + self.b

In both cases,

    taxes = linear(0.3, 2)

gives a callable object where `taxes(10e6) == 0.3 * 10e6 + 2'.

The callable object approach has the disadvantage that it is a bit
slower and results in slightly longer code.  However, note that a
collection of callables can share their signature via inheritance:

    class exponential(linear):
        # __init__ inherited
        def __call__(self, x):
            return self.a * (x ** self.b)

Object can encapsulate state for several methods:

    class counter:

        value = 0

        def set(self, x):
            self.value = x

        def up(self):
            self.value = self.value + 1

        def down(self):
            self.value = self.value - 1

    count = counter()
    inc, dec, reset = count.up, count.down, count.set

Here `inc()', `dec()' and `reset()' act like functions which share the
same counting variable.


File: python.info,  Node: How do I copy an object in Python?,  Next: How can I find the methods or attributes of an object?,  Prev: How do you make a higher order function in Python?,  Up: Core Language

11.2.2.12 How do I copy an object in Python?
............................................

In general, try *Note copy.copy(): c62. or *Note copy.deepcopy(): 20f.
for the general case.  Not all objects can be copied, but most can.

Some objects can be copied more easily.  Dictionaries have a *Note
copy(): 925.  method:

    newdict = olddict.copy()

Sequences can be copied by slicing:

    new_l = l[:]


File: python.info,  Node: How can I find the methods or attributes of an object?,  Next: How can my code discover the name of an object?,  Prev: How do I copy an object in Python?,  Up: Core Language

11.2.2.13 How can I find the methods or attributes of an object?
................................................................

For an instance x of a user-defined class, `dir(x)' returns an
alphabetized list of the names containing the instance attributes and
methods and attributes defined by its class.


File: python.info,  Node: How can my code discover the name of an object?,  Next: What’s up with the comma operator’s precedence?,  Prev: How can I find the methods or attributes of an object?,  Up: Core Language

11.2.2.14 How can my code discover the name of an object?
.........................................................

Generally speaking, it can’t, because objects don’t really have
names.  Essentially, assignment always binds a name to a value; The
same is true of `def' and `class' statements, but in that case the
value is a callable. Consider the following code:

    >>> class A:
    ...     pass
    ...
    >>> B = A
    >>> a = B()
    >>> b = a
    >>> print b
    <__main__.A instance at 0x16D07CC>
    >>> print a
    <__main__.A instance at 0x16D07CC>

Arguably the class has a name: even though it is bound to two names and
invoked through the name B the created instance is still reported as an
instance of class A.  However, it is impossible to say whether the
instance’s name is a or b, since both names are bound to the same
value.

Generally speaking it should not be necessary for your code to “know
the names” of particular values. Unless you are deliberately writing
introspective programs, this is usually an indication that a change of
approach might be beneficial.

In comp.lang.python, Fredrik Lundh once gave an excellent analogy in
answer to this question:

     The same way as you get the name of that cat you found on your
     porch: the cat (object) itself cannot tell you its name, and it
     doesn’t really care – so the only way to find out what it’s
     called is to ask all your neighbours (namespaces) if it’s their
     cat (object)…

     ….and don’t be surprised if you’ll find that it’s known by
     many names, or no name at all!


File: python.info,  Node: What’s up with the comma operator’s precedence?,  Next: Is there an equivalent of C’s “? ” ternary operator?,  Prev: How can my code discover the name of an object?,  Up: Core Language

11.2.2.15 What’s up with the comma operator’s precedence?
.............................................................

Comma is not an operator in Python.  Consider this session:

    >>> "a" in "b", "a"
    (False, 'a')

Since the comma is not an operator, but a separator between expressions
the above is evaluated as if you had entered:

    ("a" in "b"), "a"

not:

    "a" in ("b", "a")

The same is true of the various assignment operators (`=', `+=' etc).
They are not truly operators but syntactic delimiters in assignment
statements.


File: python.info,  Node: Is there an equivalent of C’s “? ” ternary operator?,  Next: Is it possible to write obfuscated one-liners in Python?,  Prev: What’s up with the comma operator’s precedence?,  Up: Core Language

11.2.2.16 Is there an equivalent of C’s “?:” ternary operator?
....................................................................

Yes, this feature was added in Python 2.5. The syntax would be as
follows:

    [on_true] if [expression] else [on_false]

    x, y = 50, 25

    small = x if x < y else y

For versions previous to 2.5 the answer would be ‘No’.


File: python.info,  Node: Is it possible to write obfuscated one-liners in Python?,  Prev: Is there an equivalent of C’s “? ” ternary operator?,  Up: Core Language

11.2.2.17 Is it possible to write obfuscated one-liners in Python?
..................................................................

Yes.  Usually this is done by nesting *Note lambda: 41c. within *Note
lambda: 41c.  See the following three examples, due to Ulf Bartelt:

    # Primes < 1000
    print filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,
    map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))

    # First 10 Fibonacci numbers
    print map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1: f(x,f),
    range(10))

    # Mandelbrot set
    print (lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+y,map(lambda y,
    Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,
    Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,
    i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y
    >=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(
    64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy
    ))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24)
    #    \___ ___/  \___ ___/  |   |   |__ lines on screen
    #        V          V      |   |______ columns on screen
    #        |          |      |__________ maximum of "iterations"
    #        |          |_________________ range on y axis
    #        |____________________________ range on x axis

Don’t try this at home, kids!


File: python.info,  Node: Numbers and strings,  Next: Sequences Tuples/Lists,  Prev: Core Language,  Up: Programming FAQ

11.2.3 Numbers and strings
--------------------------

* Menu:

* How do I specify hexadecimal and octal integers?::
* Why does -22 // 10 return -3?::
* How do I convert a string to a number?::
* How do I convert a number to a string?::
* How do I modify a string in place?::
* How do I use strings to call functions/methods?::
* Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings?: Is there an equivalent to Perl’s chomp for removing trailing newlines from strings?.
* Is there a scanf() or sscanf() equivalent?: Is there a scanf or sscanf equivalent?.
* What does ‘UnicodeError; ASCII [decoding,encoding] error; ordinal not in range(128)’ mean?: What does ‘UnicodeError ASCII [decoding encoding] error ordinal not in range 128 ’ mean?.


File: python.info,  Node: How do I specify hexadecimal and octal integers?,  Next: Why does -22 // 10 return -3?,  Up: Numbers and strings

11.2.3.1 How do I specify hexadecimal and octal integers?
.........................................................

To specify an octal digit, precede the octal value with a zero, and
then a lower or uppercase “o”.  For example, to set the variable
“a” to the octal value “10” (8 in decimal), type:

    >>> a = 0o10
    >>> a
    8

Hexadecimal is just as easy.  Simply precede the hexadecimal number
with a zero, and then a lower or uppercase “x”.  Hexadecimal digits
can be specified in lower or uppercase.  For example, in the Python
interpreter:

    >>> a = 0xa5
    >>> a
    165
    >>> b = 0XB2
    >>> b
    178


File: python.info,  Node: Why does -22 // 10 return -3?,  Next: How do I convert a string to a number?,  Prev: How do I specify hexadecimal and octal integers?,  Up: Numbers and strings

11.2.3.2 Why does -22 // 10 return -3?
......................................

It’s primarily driven by the desire that `i % j' have the same sign
as `j'.  If you want that, and also want:

    i == (i // j) * j + (i % j)

then integer division has to return the floor.  C also requires that
identity to hold, and then compilers that truncate `i // j' need to
make `i % j' have the same sign as `i'.

There are few real use cases for `i % j' when `j' is negative.  When `j'
is positive, there are many, and in virtually all of them it’s more
useful for `i % j' to be `>= 0'.  If the clock says 10 now, what did it
say 200 hours ago?  `-190 % 12 == 2' is useful; `-190 % 12 == -10' is a
bug waiting to bite.

     Note: On Python 2, `a / b' returns the same as `a // b' if
     `__future__.division' is not in effect.  This is also known as
     “classic” division.


File: python.info,  Node: How do I convert a string to a number?,  Next: How do I convert a number to a string?,  Prev: Why does -22 // 10 return -3?,  Up: Numbers and strings

11.2.3.3 How do I convert a string to a number?
...............................................

For integers, use the built-in *Note int(): 1f2. type constructor, e.g.
`int('144') == 144'.  Similarly, *Note float(): 1eb. converts to
floating-point, e.g. `float('144') == 144.0'.

By default, these interpret the number as decimal, so that `int('0144')
== 144' and `int('0x144')' raises *Note ValueError: 236. `int(string,
base)' takes the base to convert from as a second optional argument, so
`int('0x144', 16) == 324'.  If the base is specified as 0, the number
is interpreted using Python’s rules: a leading ‘0’ indicates
octal, and ‘0x’ indicates a hex number.

Do not use the built-in function *Note eval(): 378. if all you need is
to convert strings to numbers.  *Note eval(): 378. will be
significantly slower and it presents a security risk: someone could
pass you a Python expression that might have unwanted side effects.
For example, someone could pass `__import__('os').system("rm -rf
$HOME")' which would erase your home directory.

*Note eval(): 378. also has the effect of interpreting numbers as
Python expressions, so that e.g. `eval('09')' gives a syntax error
because Python regards numbers starting with ‘0’ as octal (base 8).


File: python.info,  Node: How do I convert a number to a string?,  Next: How do I modify a string in place?,  Prev: How do I convert a string to a number?,  Up: Numbers and strings

11.2.3.4 How do I convert a number to a string?
...............................................

To convert, e.g., the number 144 to the string ‘144’, use the
built-in type constructor *Note str(): 1ea.  If you want a hexadecimal
or octal representation, use the built-in functions *Note hex(): 348.
or *Note oct(): 339.  For fancy formatting, see the *Note Format String
Syntax: 31c. section, e.g. `"{:04d}".format(144)' yields `'0144'' and
`"{:.3f}".format(1/3)' yields `'0.333''.  You may also use *Note the %
operator: 53f. on strings.  See the library reference manual for
details.


File: python.info,  Node: How do I modify a string in place?,  Next: How do I use strings to call functions/methods?,  Prev: How do I convert a number to a string?,  Up: Numbers and strings

11.2.3.5 How do I modify a string in place?
...........................................

You can’t, because strings are immutable.  If you need an object with
this ability, try converting the string to a list or use the array
module:

    >>> import io
    >>> s = "Hello, world"
    >>> a = list(s)
    >>> print a
    ['H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd']
    >>> a[7:] = list("there!")
    >>> ''.join(a)
    'Hello, there!'

    >>> import array
    >>> a = array.array('c', s)
    >>> print a
    array('c', 'Hello, world')
    >>> a[0] = 'y'; print a
    array('c', 'yello, world')
    >>> a.tostring()
    'yello, world'


File: python.info,  Node: How do I use strings to call functions/methods?,  Next: Is there an equivalent to Perl’s chomp for removing trailing newlines from strings?,  Prev: How do I modify a string in place?,  Up: Numbers and strings

11.2.3.6 How do I use strings to call functions/methods?
........................................................

There are various techniques.

   * The best is to use a dictionary that maps strings to functions.
     The primary advantage of this technique is that the strings do not
     need to match the names of the functions.  This is also the
     primary technique used to emulate a case construct:

         def a():
             pass

         def b():
             pass

         dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs

         dispatch[get_input()]()  # Note trailing parens to call function

   * Use the built-in function *Note getattr(): 89d.:

         import foo
         getattr(foo, 'bar')()

     Note that *Note getattr(): 89d. works on any object, including
     classes, class instances, modules, and so on.

     This is used in several places in the standard library, like this:

         class Foo:
             def do_foo(self):
                 ...

             def do_bar(self):
                 ...

         f = getattr(foo_instance, 'do_' + opname)
         f()

   * Use *Note locals(): 350. or *Note eval(): 378. to resolve the
     function name:

         def myFunc():
             print "hello"

         fname = "myFunc"

         f = locals()[fname]
         f()

         f = eval(fname)
         f()

     Note: Using *Note eval(): 378. is slow and dangerous.  If you
     don’t have absolute control over the contents of the string,
     someone could pass a string that resulted in an arbitrary function
     being executed.


File: python.info,  Node: Is there an equivalent to Perl’s chomp for removing trailing newlines from strings?,  Next: Is there a scanf or sscanf equivalent?,  Prev: How do I use strings to call functions/methods?,  Up: Numbers and strings

11.2.3.7 Is there an equivalent to Perl’s chomp() for removing trailing newlines from strings?
................................................................................................

Starting with Python 2.2, you can use `S.rstrip("\r\n")' to remove all
occurrences of any line terminator from the end of the string `S'
without removing other trailing whitespace.  If the string `S'
represents more than one line, with several empty lines at the end, the
line terminators for all the blank lines will be removed:

    >>> lines = ("line 1 \r\n"
    ...          "\r\n"
    ...          "\r\n")
    >>> lines.rstrip("\n\r")
    'line 1 '

Since this is typically only desired when reading text one line at a
time, using `S.rstrip()' this way works well.

For older versions of Python, there are two partial substitutes:

   - If you want to remove all trailing whitespace, use the `rstrip()'
     method of string objects.  This removes all trailing whitespace,
     not just a single newline.

   - Otherwise, if there is only one line in the string `S', use
     `S.splitlines()[0]'.


File: python.info,  Node: Is there a scanf or sscanf equivalent?,  Next: What does ‘UnicodeError ASCII [decoding encoding] error ordinal not in range 128 ’ mean?,  Prev: Is there an equivalent to Perl’s chomp for removing trailing newlines from strings?,  Up: Numbers and strings

11.2.3.8 Is there a scanf() or sscanf() equivalent?
...................................................

Not as such.

For simple input parsing, the easiest approach is usually to split the
line into whitespace-delimited words using the *Note split(): 8fd.
method of string objects and then convert decimal strings to numeric
values using *Note int(): 1f2. or *Note float(): 1eb.  `split()'
supports an optional “sep” parameter which is useful if the line
uses something other than whitespace as a separator.

For more complicated input parsing, regular expressions are more
powerful than C’s `sscanf()' and better suited for the task.


File: python.info,  Node: What does ‘UnicodeError ASCII [decoding encoding] error ordinal not in range 128 ’ mean?,  Prev: Is there a scanf or sscanf equivalent?,  Up: Numbers and strings

11.2.3.9 What does ‘UnicodeError: ASCII [decoding,encoding] error: ordinal not in range(128)’ mean?
.......................................................................................................

This error indicates that your Python installation can handle only
7-bit ASCII strings.  There are a couple ways to fix or work around the
problem.

If your programs must handle data in arbitrary character set encodings,
the environment the application runs in will generally identify the
encoding of the data it is handing you.  You need to convert the input
to Unicode data using that encoding.  For example, a program that
handles email or web input will typically find character set encoding
information in Content-Type headers.  This can then be used to properly
convert input data to Unicode. Assuming the string referred to by
`value' is encoded as UTF-8:

    value = unicode(value, "utf-8")

will return a Unicode object.  If the data is not correctly encoded as
UTF-8, the above call will raise a *Note UnicodeError: 44c. exception.

If you only want strings converted to Unicode which have non-ASCII
data, you can try converting them first assuming an ASCII encoding, and
then generate Unicode objects if that fails:

    try:
        x = unicode(value, "ascii")
    except UnicodeError:
        value = unicode(value, "utf-8")
    else:
        # value was valid ASCII data
        pass

It’s possible to set a default encoding in a file called
`sitecustomize.py' that’s part of the Python library.  However, this
isn’t recommended because changing the Python-wide default encoding
may cause third-party extension modules to fail.

Note that on Windows, there is an encoding known as “mbcs”, which
uses an encoding specific to your current locale.  In many cases, and
particularly when working with COM, this may be an appropriate default
encoding to use.


File: python.info,  Node: Sequences Tuples/Lists,  Next: Dictionaries<2>,  Prev: Numbers and strings,  Up: Programming FAQ

11.2.4 Sequences (Tuples/Lists)
-------------------------------

* Menu:

* How do I convert between tuples and lists?::
* What’s a negative index?::
* How do I iterate over a sequence in reverse order?::
* How do you remove duplicates from a list?::
* How do you make an array in Python?::
* How do I create a multidimensional list?::
* How do I apply a method to a sequence of objects?::
* Why does a_tuple[i] += [‘item’] raise an exception when the addition works?::


File: python.info,  Node: How do I convert between tuples and lists?,  Next: What’s a negative index?,  Up: Sequences Tuples/Lists

11.2.4.1 How do I convert between tuples and lists?
...................................................

The type constructor `tuple(seq)' converts any sequence (actually, any
iterable) into a tuple with the same items in the same order.

For example, `tuple([1, 2, 3])' yields `(1, 2, 3)' and `tuple('abc')'
yields `('a', 'b', 'c')'.  If the argument is a tuple, it does not make
a copy but returns the same object, so it is cheap to call *Note
tuple(): 421. when you aren’t sure that an object is already a tuple.

The type constructor `list(seq)' converts any sequence or iterable into
a list with the same items in the same order.  For example, `list((1,
2, 3))' yields `[1, 2, 3]' and `list('abc')' yields `['a', 'b', 'c']'.
If the argument is a list, it makes a copy just like `seq[:]' would.


File: python.info,  Node: What’s a negative index?,  Next: How do I iterate over a sequence in reverse order?,  Prev: How do I convert between tuples and lists?,  Up: Sequences Tuples/Lists

11.2.4.2 What’s a negative index?
...................................

Python sequences are indexed with positive numbers and negative
numbers.  For positive numbers 0 is the first index 1 is the second
index and so forth.  For negative indices -1 is the last index and -2
is the penultimate (next to last) index and so forth.  Think of
`seq[-n]' as the same as `seq[len(seq)-n]'.

Using negative indices can be very convenient.  For example `S[:-1]' is
all of the string except for its last character, which is useful for
removing the trailing newline from a string.


File: python.info,  Node: How do I iterate over a sequence in reverse order?,  Next: How do you remove duplicates from a list?,  Prev: What’s a negative index?,  Up: Sequences Tuples/Lists

11.2.4.3 How do I iterate over a sequence in reverse order?
...........................................................

Use the *Note reversed(): 411. built-in function, which is new in
Python 2.4:

    for x in reversed(sequence):
        ...  # do something with x ...

This won’t touch your original sequence, but build a new copy with
reversed order to iterate over.

With Python 2.3, you can use an extended slice syntax:

    for x in sequence[::-1]:
        ...  # do something with x ...


File: python.info,  Node: How do you remove duplicates from a list?,  Next: How do you make an array in Python?,  Prev: How do I iterate over a sequence in reverse order?,  Up: Sequences Tuples/Lists

11.2.4.4 How do you remove duplicates from a list?
..................................................

See the Python Cookbook for a long discussion of many ways to do this:

     <https://code.activestate.com/recipes/52560/>

If you don’t mind reordering the list, sort it and then scan from the
end of the list, deleting duplicates as you go:

    if mylist:
        mylist.sort()
        last = mylist[-1]
        for i in range(len(mylist)-2, -1, -1):
            if last == mylist[i]:
                del mylist[i]
            else:
                last = mylist[i]

If all elements of the list may be used as dictionary keys (i.e. they
are all hashable) this is often faster

    d = {}
    for x in mylist:
        d[x] = 1
    mylist = list(d.keys())

In Python 2.5 and later, the following is possible instead:

    mylist = list(set(mylist))

This converts the list into a set, thereby removing duplicates, and
then back into a list.


File: python.info,  Node: How do you make an array in Python?,  Next: How do I create a multidimensional list?,  Prev: How do you remove duplicates from a list?,  Up: Sequences Tuples/Lists

11.2.4.5 How do you make an array in Python?
............................................

Use a list:

    ["this", 1, "is", "an", "array"]

Lists are equivalent to C or Pascal arrays in their time complexity;
the primary difference is that a Python list can contain objects of
many different types.

The `array' module also provides methods for creating arrays of fixed
types with compact representations, but they are slower to index than
lists.  Also note that the Numeric extensions and others define
array-like structures with various characteristics as well.

To get Lisp-style linked lists, you can emulate cons cells using tuples:

    lisp_list = ("like",  ("this",  ("example", None) ) )

If mutability is desired, you could use lists instead of tuples.  Here
the analogue of lisp car is `lisp_list[0]' and the analogue of cdr is
`lisp_list[1]'.  Only do this if you’re sure you really need to,
because it’s usually a lot slower than using Python lists.


File: python.info,  Node: How do I create a multidimensional list?,  Next: How do I apply a method to a sequence of objects?,  Prev: How do you make an array in Python?,  Up: Sequences Tuples/Lists

11.2.4.6 How do I create a multidimensional list?
.................................................

You probably tried to make a multidimensional array like this:

    >>> A = [[None] * 2] * 3

This looks correct if you print it:

    >>> A
    [[None, None], [None, None], [None, None]]

But when you assign a value, it shows up in multiple places:

    >>> A[0][0] = 5
    >>> A
    [[5, None], [5, None], [5, None]]

The reason is that replicating a list with `*' doesn’t create copies,
it only creates references to the existing objects.  The `*3' creates a
list containing 3 references to the same list of length two.  Changes
to one row will show in all rows, which is almost certainly not what
you want.

The suggested approach is to create a list of the desired length first
and then fill in each element with a newly created list:

    A = [None] * 3
    for i in range(3):
        A[i] = [None] * 2

This generates a list containing 3 different lists of length two.  You
can also use a list comprehension:

    w, h = 2, 3
    A = [[None] * w for i in range(h)]

Or, you can use an extension that provides a matrix datatype; NumPy(1)
is the best known.

---------- Footnotes ----------

(1) http://www.numpy.org/


File: python.info,  Node: How do I apply a method to a sequence of objects?,  Next: Why does a_tuple[i] += [‘item’] raise an exception when the addition works?,  Prev: How do I create a multidimensional list?,  Up: Sequences Tuples/Lists

11.2.4.7 How do I apply a method to a sequence of objects?
..........................................................

Use a list comprehension:

    result = [obj.method() for obj in mylist]

More generically, you can try the following function:

    def method_map(objects, method, arguments):
        """method_map([a,b], "meth", (1,2)) gives [a.meth(1,2), b.meth(1,2)]"""
        nobjects = len(objects)
        methods = map(getattr, objects, [method]*nobjects)
        return map(apply, methods, [arguments]*nobjects)


File: python.info,  Node: Why does a_tuple[i] += [‘item’] raise an exception when the addition works?,  Prev: How do I apply a method to a sequence of objects?,  Up: Sequences Tuples/Lists

11.2.4.8 Why does a_tuple[i] += [‘item’] raise an exception when the addition works?
........................................................................................

This is because of a combination of the fact that augmented assignment
operators are `assignment' operators, and the difference between
mutable and immutable objects in Python.

This discussion applies in general when augmented assignment operators
are applied to elements of a tuple that point to mutable objects, but
we’ll use a `list' and `+=' as our exemplar.

If you wrote:

    >>> a_tuple = (1, 2)
    >>> a_tuple[0] += 1
    Traceback (most recent call last):
       ...
    TypeError: 'tuple' object does not support item assignment

The reason for the exception should be immediately clear: `1' is added
to the object `a_tuple[0]' points to (`1'), producing the result
object, `2', but when we attempt to assign the result of the
computation, `2', to element `0' of the tuple, we get an error because
we can’t change what an element of a tuple points to.

Under the covers, what this augmented assignment statement is doing is
approximately this:

    >>> result = a_tuple[0] + 1
    >>> a_tuple[0] = result
    Traceback (most recent call last):
      ...
    TypeError: 'tuple' object does not support item assignment

It is the assignment part of the operation that produces the error,
since a tuple is immutable.

When you write something like:

    >>> a_tuple = (['foo'], 'bar')
    >>> a_tuple[0] += ['item']
    Traceback (most recent call last):
      ...
    TypeError: 'tuple' object does not support item assignment

The exception is a bit more surprising, and even more surprising is the
fact that even though there was an error, the append worked:

    >>> a_tuple[0]
    ['foo', 'item']

To see why this happens, you need to know that (a) if an object
implements an `__iadd__' magic method, it gets called when the `+='
augmented assignment is executed, and its return value is what gets
used in the assignment statement; and (b) for lists, `__iadd__' is
equivalent to calling `extend' on the list and returning the list.
That’s why we say that for lists, `+=' is a “shorthand” for
`list.extend':

    >>> a_list = []
    >>> a_list += [1]
    >>> a_list
    [1]

This is equivalent to:

    >>> result = a_list.__iadd__([1])
    >>> a_list = result

The object pointed to by a_list has been mutated, and the pointer to the
mutated object is assigned back to `a_list'.  The end result of the
assignment is a no-op, since it is a pointer to the same object that
`a_list' was previously pointing to, but the assignment still happens.

Thus, in our tuple example what is happening is equivalent to:

    >>> result = a_tuple[0].__iadd__(['item'])
    >>> a_tuple[0] = result
    Traceback (most recent call last):
      ...
    TypeError: 'tuple' object does not support item assignment

The `__iadd__' succeeds, and thus the list is extended, but even though
`result' points to the same object that `a_tuple[0]' already points to,
that final assignment still results in an error, because tuples are
immutable.


File: python.info,  Node: Dictionaries<2>,  Next: Objects,  Prev: Sequences Tuples/Lists,  Up: Programming FAQ

11.2.5 Dictionaries
-------------------

* Menu:

* How can I get a dictionary to display its keys in a consistent order?::
* I want to do a complicated sort; can you do a Schwartzian Transform in Python?: I want to do a complicated sort can you do a Schwartzian Transform in Python?.
* How can I sort one list by values from another list?::


File: python.info,  Node: How can I get a dictionary to display its keys in a consistent order?,  Next: I want to do a complicated sort can you do a Schwartzian Transform in Python?,  Up: Dictionaries<2>

11.2.5.1 How can I get a dictionary to display its keys in a consistent order?
..............................................................................

You can’t.  Dictionaries store their keys in an unpredictable order,
so the display order of a dictionary’s elements will be similarly
unpredictable.

This can be frustrating if you want to save a printable version to a
file, make some changes and then compare it with some other printed
dictionary.  In this case, use the `pprint' module to pretty-print the
dictionary; the items will be presented in order sorted by the key.

A more complicated solution is to subclass `dict' to create a
`SortedDict' class that prints itself in a predictable order.  Here’s
one simpleminded implementation of such a class:

    class SortedDict(dict):
        def __repr__(self):
            keys = sorted(self.keys())
            result = ("{!r}: {!r}".format(k, self[k]) for k in keys)
            return "{{{}}}".format(", ".join(result))

        __str__ = __repr__

This will work for many common situations you might encounter, though
it’s far from a perfect solution. The largest flaw is that if some
values in the dictionary are also dictionaries, their values won’t be
presented in any particular order.


File: python.info,  Node: I want to do a complicated sort can you do a Schwartzian Transform in Python?,  Next: How can I sort one list by values from another list?,  Prev: How can I get a dictionary to display its keys in a consistent order?,  Up: Dictionaries<2>

11.2.5.2 I want to do a complicated sort: can you do a Schwartzian Transform in Python?
.......................................................................................

The technique, attributed to Randal Schwartz of the Perl community,
sorts the elements of a list by a metric which maps each element to its
“sort value”. In Python, use the `key' argument for the `sort()'
function:

    Isorted = L[:]
    Isorted.sort(key=lambda s: int(s[10:15]))


File: python.info,  Node: How can I sort one list by values from another list?,  Prev: I want to do a complicated sort can you do a Schwartzian Transform in Python?,  Up: Dictionaries<2>

11.2.5.3 How can I sort one list by values from another list?
.............................................................

Merge them into a single list of tuples, sort the resulting list, and
then pick out the element you want.

    >>> list1 = ["what", "I'm", "sorting", "by"]
    >>> list2 = ["something", "else", "to", "sort"]
    >>> pairs = zip(list1, list2)
    >>> pairs
    [('what', 'something'), ("I'm", 'else'), ('sorting', 'to'), ('by', 'sort')]
    >>> pairs.sort()
    >>> result = [ x[1] for x in pairs ]
    >>> result
    ['else', 'sort', 'to', 'something']

An alternative for the last step is:

    >>> result = []
    >>> for p in pairs: result.append(p[1])

If you find this more legible, you might prefer to use this instead of
the final list comprehension.  However, it is almost twice as slow for
long lists.  Why?  First, the `append()' operation has to reallocate
memory, and while it uses some tricks to avoid doing that each time, it
still has to do it occasionally, and that costs quite a bit.  Second,
the expression “result.append” requires an extra attribute lookup,
and third, there’s a speed reduction from having to make all those
function calls.


File: python.info,  Node: Objects,  Next: Modules<3>,  Prev: Dictionaries<2>,  Up: Programming FAQ

11.2.6 Objects
--------------

* Menu:

* What is a class?::
* What is a method?::
* What is self?::
* How do I check if an object is an instance of a given class or of a subclass of it?::
* What is delegation?::
* How do I call a method defined in a base class from a derived class that overrides it?::
* How can I organize my code to make it easier to change the base class?::
* How do I create static class data and static class methods?::
* How can I overload constructors (or methods) in Python?: How can I overload constructors or methods in Python?.
* I try to use __spam and I get an error about _SomeClassName__spam.: I try to use __spam and I get an error about _SomeClassName__spam.
* My class defines __del__ but it is not called when I delete the object.: My class defines __del__ but it is not called when I delete the object.
* How do I get a list of all instances of a given class?::
* Why does the result of id() appear to be not unique?: Why does the result of id appear to be not unique?.


File: python.info,  Node: What is a class?,  Next: What is a method?,  Up: Objects

11.2.6.1 What is a class?
.........................

A class is the particular object type created by executing a class
statement.  Class objects are used as templates to create instance
objects, which embody both the data (attributes) and code (methods)
specific to a datatype.

A class can be based on one or more other classes, called its base
class(es). It then inherits the attributes and methods of its base
classes. This allows an object model to be successively refined by
inheritance.  You might have a generic `Mailbox' class that provides
basic accessor methods for a mailbox, and subclasses such as
`MboxMailbox', `MaildirMailbox', `OutlookMailbox' that handle various
specific mailbox formats.


File: python.info,  Node: What is a method?,  Next: What is self?,  Prev: What is a class?,  Up: Objects

11.2.6.2 What is a method?
..........................

A method is a function on some object `x' that you normally call as
`x.name(arguments...)'.  Methods are defined as functions inside the
class definition:

    class C:
        def meth(self, arg):
            return arg * 2 + self.attribute


File: python.info,  Node: What is self?,  Next: How do I check if an object is an instance of a given class or of a subclass of it?,  Prev: What is a method?,  Up: Objects

11.2.6.3 What is self?
......................

Self is merely a conventional name for the first argument of a method.
A method defined as `meth(self, a, b, c)' should be called as
`x.meth(a, b, c)' for some instance `x' of the class in which the
definition occurs; the called method will think it is called as
`meth(x, a, b, c)'.

See also *Note Why must ‘self’ be used explicitly in method
definitions and calls?: 30bd.


File: python.info,  Node: How do I check if an object is an instance of a given class or of a subclass of it?,  Next: What is delegation?,  Prev: What is self?,  Up: Objects

11.2.6.4 How do I check if an object is an instance of a given class or of a subclass of it?
............................................................................................

Use the built-in function `isinstance(obj, cls)'.  You can check if an
object is an instance of any of a number of classes by providing a
tuple instead of a single class, e.g. `isinstance(obj, (class1, class2,
...))', and can also check whether an object is one of Python’s
built-in types, e.g.  `isinstance(obj, str)' or `isinstance(obj, (int,
long, float, complex))'.

Note that most programs do not use *Note isinstance(): 332. on
user-defined classes very often.  If you are developing the classes
yourself, a more proper object-oriented style is to define methods on
the classes that encapsulate a particular behaviour, instead of
checking the object’s class and doing a different thing based on what
class it is.  For example, if you have a function that does something:

    def search(obj):
        if isinstance(obj, Mailbox):
            ...  # code to search a mailbox
        elif isinstance(obj, Document):
            ...  # code to search a document
        elif ...

A better approach is to define a `search()' method on all the classes
and just call it:

    class Mailbox:
        def search(self):
            ...  # code to search a mailbox

    class Document:
        def search(self):
            ...  # code to search a document

    obj.search()


File: python.info,  Node: What is delegation?,  Next: How do I call a method defined in a base class from a derived class that overrides it?,  Prev: How do I check if an object is an instance of a given class or of a subclass of it?,  Up: Objects

11.2.6.5 What is delegation?
............................

Delegation is an object oriented technique (also called a design
pattern).  Let’s say you have an object `x' and want to change the
behaviour of just one of its methods.  You can create a new class that
provides a new implementation of the method you’re interested in
changing and delegates all other methods to the corresponding method of
`x'.

Python programmers can easily implement delegation.  For example, the
following class implements a class that behaves like a file but
converts all written data to uppercase:

    class UpperOut:

        def __init__(self, outfile):
            self._outfile = outfile

        def write(self, s):
            self._outfile.write(s.upper())

        def __getattr__(self, name):
            return getattr(self._outfile, name)

Here the `UpperOut' class redefines the `write()' method to convert the
argument string to uppercase before calling the underlying
`self.__outfile.write()' method.  All other methods are delegated to the
underlying `self.__outfile' object.  The delegation is accomplished via
the `__getattr__' method; consult *Note the language reference: 736.
for more information about controlling attribute access.

Note that for more general cases delegation can get trickier. When
attributes must be set as well as retrieved, the class must define a
*Note __setattr__(): 4a5.  method too, and it must do so carefully.
The basic implementation of *Note __setattr__(): 4a5. is roughly
equivalent to the following:

    class X:
        ...
        def __setattr__(self, name, value):
            self.__dict__[name] = value
        ...

Most *Note __setattr__(): 4a5. implementations must modify
`self.__dict__' to store local state for self without causing an
infinite recursion.


File: python.info,  Node: How do I call a method defined in a base class from a derived class that overrides it?,  Next: How can I organize my code to make it easier to change the base class?,  Prev: What is delegation?,  Up: Objects

11.2.6.6 How do I call a method defined in a base class from a derived class that overrides it?
...............................................................................................

If you’re using new-style classes, use the built-in *Note super():
395. function:

    class Derived(Base):
        def meth(self):
            super(Derived, self).meth()

If you’re using classic classes: For a class definition such as `class
Derived(Base): ...' you can call method `meth()' defined in `Base' (or
one of `Base'’s base classes) as `Base.meth(self, arguments...)'.
Here, `Base.meth' is an unbound method, so you need to provide the
`self' argument.


File: python.info,  Node: How can I organize my code to make it easier to change the base class?,  Next: How do I create static class data and static class methods?,  Prev: How do I call a method defined in a base class from a derived class that overrides it?,  Up: Objects

11.2.6.7 How can I organize my code to make it easier to change the base class?
...............................................................................

You could define an alias for the base class, assign the real base
class to it before your class definition, and use the alias throughout
your class.  Then all you have to change is the value assigned to the
alias.  Incidentally, this trick is also handy if you want to decide
dynamically (e.g. depending on availability of resources) which base
class to use.  Example:

    BaseAlias = <real base class>

    class Derived(BaseAlias):
        def meth(self):
            BaseAlias.meth(self)
            ...


File: python.info,  Node: How do I create static class data and static class methods?,  Next: How can I overload constructors or methods in Python?,  Prev: How can I organize my code to make it easier to change the base class?,  Up: Objects

11.2.6.8 How do I create static class data and static class methods?
....................................................................

Both static data and static methods (in the sense of C++ or Java) are
supported in Python.

For static data, simply define a class attribute.  To assign a new
value to the attribute, you have to explicitly use the class name in
the assignment:

    class C:
        count = 0   # number of times C.__init__ called

        def __init__(self):
            C.count = C.count + 1

        def getcount(self):
            return C.count  # or return self.count

`c.count' also refers to `C.count' for any `c' such that `isinstance(c,
C)' holds, unless overridden by `c' itself or by some class on the
base-class search path from `c.__class__' back to `C'.

Caution: within a method of C, an assignment like `self.count = 42'
creates a new and unrelated instance named “count” in `self'’s
own dict.  Rebinding of a class-static data name must always specify
the class whether inside a method or not:

    C.count = 314

Static methods are possible since Python 2.2:

    class C:
        def static(arg1, arg2, arg3):
            # No 'self' parameter!
            ...
        static = staticmethod(static)

With Python 2.4’s decorators, this can also be written as

    class C:
        @staticmethod
        def static(arg1, arg2, arg3):
            # No 'self' parameter!
            ...

However, a far more straightforward way to get the effect of a static
method is via a simple module-level function:

    def getcount():
        return C.count

If your code is structured so as to define one class (or tightly
related class hierarchy) per module, this supplies the desired
encapsulation.


File: python.info,  Node: How can I overload constructors or methods in Python?,  Next: I try to use __spam and I get an error about _SomeClassName__spam,  Prev: How do I create static class data and static class methods?,  Up: Objects

11.2.6.9 How can I overload constructors (or methods) in Python?
................................................................

This answer actually applies to all methods, but the question usually
comes up first in the context of constructors.

In C++ you’d write

    class C {
        C() { cout << "No arguments\n"; }
        C(int i) { cout << "Argument is " << i << "\n"; }
    }

In Python you have to write a single constructor that catches all cases
using default arguments.  For example:

    class C:
        def __init__(self, i=None):
            if i is None:
                print "No arguments"
            else:
                print "Argument is", i

This is not entirely equivalent, but close enough in practice.

You could also try a variable-length argument list, e.g.

    def __init__(self, *args):
        ...

The same approach works for all method definitions.


File: python.info,  Node: I try to use __spam and I get an error about _SomeClassName__spam,  Next: My class defines __del__ but it is not called when I delete the object,  Prev: How can I overload constructors or methods in Python?,  Up: Objects

11.2.6.10 I try to use __spam and I get an error about _SomeClassName__spam.
............................................................................

Variable names with double leading underscores are “mangled” to
provide a simple but effective way to define class private variables.
Any identifier of the form `__spam' (at least two leading underscores,
at most one trailing underscore) is textually replaced with
`_classname__spam', where `classname' is the current class name with
any leading underscores stripped.

This doesn’t guarantee privacy: an outside user can still
deliberately access the “_classname__spam” attribute, and private
values are visible in the object’s `__dict__'.  Many Python
programmers never bother to use private variable names at all.


File: python.info,  Node: My class defines __del__ but it is not called when I delete the object,  Next: How do I get a list of all instances of a given class?,  Prev: I try to use __spam and I get an error about _SomeClassName__spam,  Up: Objects

11.2.6.11 My class defines __del__ but it is not called when I delete the object.
.................................................................................

There are several possible reasons for this.

The del statement does not necessarily call *Note __del__(): 731. –
it simply decrements the object’s reference count, and if this
reaches zero *Note __del__(): 731. is called.

If your data structures contain circular links (e.g. a tree where each
child has a parent reference and each parent has a list of children)
the reference counts will never go back to zero.  Once in a while
Python runs an algorithm to detect such cycles, but the garbage
collector might run some time after the last reference to your data
structure vanishes, so your *Note __del__(): 731. method may be called
at an inconvenient and random time. This is inconvenient if you’re
trying to reproduce a problem. Worse, the order in which object’s
*Note __del__(): 731.  methods are executed is arbitrary.  You can run
*Note gc.collect(): 3da. to force a collection, but there `are'
pathological cases where objects will never be collected.

Despite the cycle collector, it’s still a good idea to define an
explicit `close()' method on objects to be called whenever you’re
done with them.  The `close()' method can then remove attributes that
refer to subobjecs.  Don’t call *Note __del__(): 731. directly –
*Note __del__(): 731. should call `close()' and `close()' should make
sure that it can be called more than once for the same object.

Another way to avoid cyclical references is to use the *Note weakref:
195. module, which allows you to point to objects without incrementing
their reference count.  Tree data structures, for instance, should use
weak references for their parent and sibling references (if they need
them!).

If the object has ever been a local variable in a function that caught
an expression in an except clause, chances are that a reference to the
object still exists in that function’s stack frame as contained in
the stack trace.  Normally, calling *Note sys.exc_clear(): 480. will
take care of this by clearing the last recorded exception.

Finally, if your *Note __del__(): 731. method raises an exception, a
warning message is printed to *Note sys.stderr: 672.


File: python.info,  Node: How do I get a list of all instances of a given class?,  Next: Why does the result of id appear to be not unique?,  Prev: My class defines __del__ but it is not called when I delete the object,  Up: Objects

11.2.6.12 How do I get a list of all instances of a given class?
................................................................

Python does not keep track of all instances of a class (or of a
built-in type).  You can program the class’s constructor to keep
track of all instances by keeping a list of weak references to each
instance.


File: python.info,  Node: Why does the result of id appear to be not unique?,  Prev: How do I get a list of all instances of a given class?,  Up: Objects

11.2.6.13 Why does the result of `id()' appear to be not unique?
................................................................

The *Note id(): 3ca. builtin returns an integer that is guaranteed to
be unique during the lifetime of the object.  Since in CPython, this is
the object’s memory address, it happens frequently that after an
object is deleted from memory, the next freshly created object is
allocated at the same position in memory.  This is illustrated by this
example:

    >>> id(1000)
    13901272
    >>> id(2000)
    13901272

The two ids belong to different integer objects that are created
before, and deleted immediately after execution of the `id()' call.  To
be sure that objects whose id you want to examine are still alive,
create another reference to the object:

    >>> a = 1000; b = 2000
    >>> id(a)
    13901272
    >>> id(b)
    13891296


File: python.info,  Node: Modules<3>,  Prev: Objects,  Up: Programming FAQ

11.2.7 Modules
--------------

* Menu:

* How do I create a .pyc file?: How do I create a pyc file?.
* How do I find the current module name?::
* How can I have modules that mutually import each other?::
* __import__(‘x.y.z’) returns <module ‘x’>; how do I get z?: __import__ ‘x y z’ returns <module ‘x’>; how do I get z?.
* When I edit an imported module and reimport it, the changes don’t show up. Why does this happen?: When I edit an imported module and reimport it the changes don’t show up Why does this happen?.


File: python.info,  Node: How do I create a pyc file?,  Next: How do I find the current module name?,  Up: Modules<3>

11.2.7.1 How do I create a .pyc file?
.....................................

When a module is imported for the first time (or when the source is
more recent than the current compiled file) a `.pyc' file containing
the compiled code should be created in the same directory as the `.py'
file.

One reason that a `.pyc' file may not be created is permissions
problems with the directory. This can happen, for example, if you
develop as one user but run as another, such as if you are testing with
a web server.  Creation of a .pyc file is automatic if you’re
importing a module and Python has the ability (permissions, free space,
etc…) to write the compiled module back to the directory.

Running Python on a top level script is not considered an import and no
`.pyc' will be created.  For example, if you have a top-level module
`foo.py' that imports another module `xyz.py', when you run `foo',
`xyz.pyc' will be created since `xyz' is imported, but no `foo.pyc' file
will be created since `foo.py' isn’t being imported.

If you need to create `foo.pyc' – that is, to create a `.pyc' file
for a module that is not imported – you can, using the *Note
py_compile: 13e. and *Note compileall: 69. modules.

The *Note py_compile: 13e. module can manually compile any module.  One
way is to use the `compile()' function in that module interactively:

    >>> import py_compile
    >>> py_compile.compile('foo.py')                 # doctest: +SKIP

This will write the `.pyc' to the same location as `foo.py' (or you can
override that with the optional parameter `cfile').

You can also automatically compile all files in a directory or
directories using the *Note compileall: 69. module.  You can do it from
the shell prompt by running `compileall.py' and providing the path of a
directory containing Python files to compile:

    python -m compileall .


File: python.info,  Node: How do I find the current module name?,  Next: How can I have modules that mutually import each other?,  Prev: How do I create a pyc file?,  Up: Modules<3>

11.2.7.2 How do I find the current module name?
...............................................

A module can find out its own module name by looking at the predefined
global variable `__name__'.  If this has the value `'__main__'', the
program is running as a script.  Many modules that are usually used by
importing them also provide a command-line interface or a self-test,
and only execute this code after checking `__name__':

    def main():
        print 'Running test...'
        ...

    if __name__ == '__main__':
        main()


File: python.info,  Node: How can I have modules that mutually import each other?,  Next: __import__ ‘x y z’ returns <module ‘x’>; how do I get z?,  Prev: How do I find the current module name?,  Up: Modules<3>

11.2.7.3 How can I have modules that mutually import each other?
................................................................

Suppose you have the following modules:

foo.py:

    from bar import bar_var
    foo_var = 1

bar.py:

    from foo import foo_var
    bar_var = 2

The problem is that the interpreter will perform the following steps:

   * main imports foo

   * Empty globals for foo are created

   * foo is compiled and starts executing

   * foo imports bar

   * Empty globals for bar are created

   * bar is compiled and starts executing

   * bar imports foo (which is a no-op since there already is a module
     named foo)

   * bar.foo_var = foo.foo_var

The last step fails, because Python isn’t done with interpreting
`foo' yet and the global symbol dictionary for `foo' is still empty.

The same thing happens when you use `import foo', and then try to access
`foo.foo_var' in global code.

There are (at least) three possible workarounds for this problem.

Guido van Rossum recommends avoiding all uses of `from <module> import
...', and placing all code inside functions.  Initializations of global
variables and class variables should use constants or built-in
functions only.  This means everything from an imported module is
referenced as `<module>.<name>'.

Jim Roskind suggests performing steps in the following order in each
module:

   * exports (globals, functions, and classes that don’t need
     imported base classes)

   * `import' statements

   * active code (including globals that are initialized from imported
     values).

van Rossum doesn’t like this approach much because the imports appear
in a strange place, but it does work.

Matthias Urlichs recommends restructuring your code so that the
recursive import is not necessary in the first place.

These solutions are not mutually exclusive.


File: python.info,  Node: __import__ ‘x y z’ returns <module ‘x’>; how do I get z?,  Next: When I edit an imported module and reimport it the changes don’t show up Why does this happen?,  Prev: How can I have modules that mutually import each other?,  Up: Modules<3>

11.2.7.4 __import__(‘x.y.z’) returns <module ‘x’>; how do I get z?
..........................................................................

Consider using the convenience function *Note import_module(): 272. from
*Note importlib: f7. instead:

    z = importlib.import_module('x.y.z')


File: python.info,  Node: When I edit an imported module and reimport it the changes don’t show up Why does this happen?,  Prev: __import__ ‘x y z’ returns <module ‘x’>; how do I get z?,  Up: Modules<3>

11.2.7.5 When I edit an imported module and reimport it, the changes don’t show up.  Why does this happen?
............................................................................................................

For reasons of efficiency as well as consistency, Python only reads the
module file on the first time a module is imported.  If it didn’t, in
a program consisting of many modules where each one imports the same
basic module, the basic module would be parsed and re-parsed many
times.  To force rereading of a changed module, do this:

    import modname
    reload(modname)

Warning: this technique is not 100% fool-proof.  In particular, modules
containing statements like

    from modname import some_objects

will continue to work with the old version of the imported objects.  If
the module contains class definitions, existing class instances will
`not' be updated to use the new class definition.  This can result in
the following paradoxical behaviour:

    >>> import cls
    >>> c = cls.C()                # Create an instance of C
    >>> reload(cls)
    <module 'cls' from 'cls.pyc'>
    >>> isinstance(c, cls.C)       # isinstance is false?!?
    False

The nature of the problem is made clear if you print out the class
objects:

    >>> c.__class__
    <class cls.C at 0x7352a0>
    >>> cls.C
    <class cls.C at 0x4198d0>


File: python.info,  Node: Design and History FAQ,  Next: Library and Extension FAQ,  Prev: Programming FAQ,  Up: Python Frequently Asked Questions

11.3 Design and History FAQ
===========================

* Menu:

* Why does Python use indentation for grouping of statements?::
* Why am I getting strange results with simple arithmetic operations?::
* Why are floating point calculations so inaccurate?::
* Why are Python strings immutable?::
* Why must ‘self’ be used explicitly in method definitions and calls?::
* Why can’t I use an assignment in an expression?::
* Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))?: Why does Python use methods for some functionality e g list index but functions for other e g len list ?.
* Why is join() a string method instead of a list or tuple method?: Why is join a string method instead of a list or tuple method?.
* How fast are exceptions?::
* Why isn’t there a switch or case statement in Python?::
* Can’t you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?::
* Why can’t lambda expressions contain statements?::
* Can Python be compiled to machine code, C or some other language?: Can Python be compiled to machine code C or some other language?.
* How does Python manage memory?::
* Why isn’t all memory freed when Python exits?::
* Why are there separate tuple and list data types?::
* How are lists implemented?::
* How are dictionaries implemented?::
* Why must dictionary keys be immutable?::
* Why doesn’t list.sort() return the sorted list?: Why doesn’t list sort return the sorted list?.
* How do you specify and enforce an interface spec in Python?::
* Why is there no goto?::
* Why can’t raw strings (r-strings) end with a backslash?: Why can’t raw strings r-strings end with a backslash?.
* Why doesn’t Python have a “with” statement for attribute assignments?::
* Why are colons required for the if/while/def/class statements?::
* Why does Python allow commas at the end of lists and tuples?::


File: python.info,  Node: Why does Python use indentation for grouping of statements?,  Next: Why am I getting strange results with simple arithmetic operations?,  Up: Design and History FAQ

11.3.1 Why does Python use indentation for grouping of statements?
------------------------------------------------------------------

Guido van Rossum believes that using indentation for grouping is
extremely elegant and contributes a lot to the clarity of the average
Python program.  Most people learn to love this feature after a while.

Since there are no begin/end brackets there cannot be a disagreement
between grouping perceived by the parser and the human reader.
Occasionally C programmers will encounter a fragment of code like this:

    if (x <= y)
            x++;
            y--;
    z++;

Only the `x++' statement is executed if the condition is true, but the
indentation leads you to believe otherwise.  Even experienced C
programmers will sometimes stare at it a long time wondering why `y' is
being decremented even for `x > y'.

Because there are no begin/end brackets, Python is much less prone to
coding-style conflicts.  In C there are many different ways to place
the braces.  If you’re used to reading and writing code that uses one
style, you will feel at least slightly uneasy when reading (or being
required to write) another style.

Many coding styles place begin/end brackets on a line by themselves.
This makes programs considerably longer and wastes valuable screen
space, making it harder to get a good overview of a program.  Ideally,
a function should fit on one screen (say, 20–30 lines).  20 lines of
Python can do a lot more work than 20 lines of C.  This is not solely
due to the lack of begin/end brackets – the lack of declarations and
the high-level data types are also responsible – but the
indentation-based syntax certainly helps.


File: python.info,  Node: Why am I getting strange results with simple arithmetic operations?,  Next: Why are floating point calculations so inaccurate?,  Prev: Why does Python use indentation for grouping of statements?,  Up: Design and History FAQ

11.3.2 Why am I getting strange results with simple arithmetic operations?
--------------------------------------------------------------------------

See the next question.


File: python.info,  Node: Why are floating point calculations so inaccurate?,  Next: Why are Python strings immutable?,  Prev: Why am I getting strange results with simple arithmetic operations?,  Up: Design and History FAQ

11.3.3 Why are floating point calculations so inaccurate?
---------------------------------------------------------

People are often very surprised by results like this:

    >>> 1.2 - 1.0
    0.19999999999999996

and think it is a bug in Python. It’s not.  This has nothing to do
with Python, but with how the underlying C platform handles floating
point numbers, and ultimately with the inaccuracies introduced when
writing down numbers as a string of a fixed number of digits.

The internal representation of floating point numbers uses a fixed
number of binary digits to represent a decimal number.  Some decimal
numbers can’t be represented exactly in binary, resulting in small
roundoff errors.

In decimal math, there are many numbers that can’t be represented
with a fixed number of decimal digits, e.g.  1/3 = 0.3333333333…….

In base 2, 1/2 = 0.1, 1/4 = 0.01, 1/8 = 0.001, etc.  .2 equals 2/10
equals 1/5, resulting in the binary fractional number
0.001100110011001…

Floating point numbers only have 32 or 64 bits of precision, so the
digits are cut off at some point, and the resulting number is
0.199999999999999996 in decimal, not 0.2.

A floating point number’s `repr()' function prints as many digits are
necessary to make `eval(repr(f)) == f' true for any float f.  The
`str()' function prints fewer digits and this often results in the more
sensible number that was probably intended:

    >>> 1.1 - 0.9
    0.20000000000000007
    >>> print 1.1 - 0.9
    0.2

One of the consequences of this is that it is error-prone to compare
the result of some computation to a float with `=='. Tiny inaccuracies
may mean that `==' fails.  Instead, you have to check that the
difference between the two numbers is less than a certain threshold:

    epsilon = 0.0000000000001  # Tiny allowed error
    expected_result = 0.4

    if expected_result-epsilon <= computation() <= expected_result+epsilon:
        ...

Please see the chapter on *Note floating point arithmetic: 640. in the
Python tutorial for more information.


File: python.info,  Node: Why are Python strings immutable?,  Next: Why must ‘self’ be used explicitly in method definitions and calls?,  Prev: Why are floating point calculations so inaccurate?,  Up: Design and History FAQ

11.3.4 Why are Python strings immutable?
----------------------------------------

There are several advantages.

One is performance: knowing that a string is immutable means we can
allocate space for it at creation time, and the storage requirements
are fixed and unchanging.  This is also one of the reasons for the
distinction between tuples and lists.

Another advantage is that strings in Python are considered as
“elemental” as numbers.  No amount of activity will change the
value 8 to anything else, and in Python, no amount of activity will
change the string “eight” to anything else.


File: python.info,  Node: Why must ‘self’ be used explicitly in method definitions and calls?,  Next: Why can’t I use an assignment in an expression?,  Prev: Why are Python strings immutable?,  Up: Design and History FAQ

11.3.5 Why must ‘self’ be used explicitly in method definitions and calls?
------------------------------------------------------------------------------

The idea was borrowed from Modula-3.  It turns out to be very useful,
for a variety of reasons.

First, it’s more obvious that you are using a method or instance
attribute instead of a local variable.  Reading `self.x' or
`self.meth()' makes it absolutely clear that an instance variable or
method is used even if you don’t know the class definition by heart.
In C++, you can sort of tell by the lack of a local variable
declaration (assuming globals are rare or easily recognizable) – but
in Python, there are no local variable declarations, so you’d have to
look up the class definition to be sure.  Some C++ and Java coding
standards call for instance attributes to have an `m_' prefix, so this
explicitness is still useful in those languages, too.

Second, it means that no special syntax is necessary if you want to
explicitly reference or call the method from a particular class.  In
C++, if you want to use a method from a base class which is overridden
in a derived class, you have to use the `::' operator – in Python you
can write `baseclass.methodname(self, <argument list>)'.  This is
particularly useful for *Note __init__(): 394. methods, and in general
in cases where a derived class method wants to extend the base class
method of the same name and thus has to call the base class method
somehow.

Finally, for instance variables it solves a syntactic problem with
assignment: since local variables in Python are (by definition!) those
variables to which a value is assigned in a function body (and that
aren’t explicitly declared global), there has to be some way to tell
the interpreter that an assignment was meant to assign to an instance
variable instead of to a local variable, and it should preferably be
syntactic (for efficiency reasons).  C++ does this through
declarations, but Python doesn’t have declarations and it would be a
pity having to introduce them just for this purpose.  Using the
explicit `self.var' solves this nicely.  Similarly, for using instance
variables, having to write `self.var' means that references to
unqualified names inside a method don’t have to search the
instance’s directories.  To put it another way, local variables and
instance variables live in two different namespaces, and you need to
tell Python which namespace to use.


File: python.info,  Node: Why can’t I use an assignment in an expression?,  Next: Why does Python use methods for some functionality e g list index but functions for other e g len list ?,  Prev: Why must ‘self’ be used explicitly in method definitions and calls?,  Up: Design and History FAQ

11.3.6 Why can’t I use an assignment in an expression?
--------------------------------------------------------

Many people used to C or Perl complain that they want to use this C
idiom:

    while (line = readline(f)) {
        // do something with line
    }

where in Python you’re forced to write this:

    while True:
        line = f.readline()
        if not line:
            break
        ...  # do something with line

The reason for not allowing assignment in Python expressions is a
common, hard-to-find bug in those other languages, caused by this
construct:

    if (x = 0) {
        // error handling
    }
    else {
        // code that only works for nonzero x
    }

The error is a simple typo: `x = 0', which assigns 0 to the variable
`x', was written while the comparison `x == 0' is certainly what was
intended.

Many alternatives have been proposed.  Most are hacks that save some
typing but use arbitrary or cryptic syntax or keywords, and fail the
simple criterion for language change proposals: it should intuitively
suggest the proper meaning to a human reader who has not yet been
introduced to the construct.

An interesting phenomenon is that most experienced Python programmers
recognize the `while True' idiom and don’t seem to be missing the
assignment in expression construct much; it’s only newcomers who
express a strong desire to add this to the language.

There’s an alternative way of spelling this that seems attractive but
is generally less robust than the “while True” solution:

    line = f.readline()
    while line:
        ...  # do something with line...
        line = f.readline()

The problem with this is that if you change your mind about exactly how
you get the next line (e.g. you want to change it into
`sys.stdin.readline()') you have to remember to change two places in
your program – the second occurrence is hidden at the bottom of the
loop.

The best approach is to use iterators, making it possible to loop
through objects using the `for' statement.  For example, in the current
version of Python file objects support the iterator protocol, so you
can now write simply:

    for line in f:
        ...  # do something with line...


File: python.info,  Node: Why does Python use methods for some functionality e g list index but functions for other e g len list ?,  Next: Why is join a string method instead of a list or tuple method?,  Prev: Why can’t I use an assignment in an expression?,  Up: Design and History FAQ

11.3.7 Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))?
-----------------------------------------------------------------------------------------------------------------------

The major reason is history. Functions were used for those operations
that were generic for a group of types and which were intended to work
even for objects that didn’t have methods at all (e.g. tuples).  It
is also convenient to have a function that can readily be applied to an
amorphous collection of objects when you use the functional features of
Python (`map()', `zip()' et al).

In fact, implementing `len()', `max()', `min()' as a built-in function
is actually less code than implementing them as methods for each type.
One can quibble about individual cases but it’s a part of Python, and
it’s too late to make such fundamental changes now. The functions
have to remain to avoid massive code breakage.

     Note: For string operations, Python has moved from external
     functions (the `string' module) to methods.  However, `len()' is
     still a function.


File: python.info,  Node: Why is join a string method instead of a list or tuple method?,  Next: How fast are exceptions?,  Prev: Why does Python use methods for some functionality e g list index but functions for other e g len list ?,  Up: Design and History FAQ

11.3.8 Why is join() a string method instead of a list or tuple method?
-----------------------------------------------------------------------

Strings became much more like other standard types starting in Python
1.6, when methods were added which give the same functionality that has
always been available using the functions of the string module.  Most
of these new methods have been widely accepted, but the one which
appears to make some programmers feel uncomfortable is:

    ", ".join(['1', '2', '4', '8', '16'])

which gives the result:

    "1, 2, 4, 8, 16"

There are two common arguments against this usage.

The first runs along the lines of: “It looks really ugly using a
method of a string literal (string constant)”, to which the answer is
that it might, but a string literal is just a fixed value. If the
methods are to be allowed on names bound to strings there is no logical
reason to make them unavailable on literals.

The second objection is typically cast as: “I am really telling a
sequence to join its members together with a string constant”.
Sadly, you aren’t.  For some reason there seems to be much less
difficulty with having *Note split(): 8fd. as a string method, since in
that case it is easy to see that

    "1, 2, 4, 8, 16".split(", ")

is an instruction to a string literal to return the substrings
delimited by the given separator (or, by default, arbitrary runs of
white space).  In this case a Unicode string returns a list of Unicode
strings, an ASCII string returns a list of ASCII strings, and everyone
is happy.

*Note join(): 8e2. is a string method because in using it you are
telling the separator string to iterate over a sequence of strings and
insert itself between adjacent elements.  This method can be used with
any argument which obeys the rules for sequence objects, including any
new classes you might define yourself.

Because this is a string method it can work for Unicode strings as well
as plain ASCII strings.  If `join()' were a method of the sequence
types then the sequence types would have to decide which type of string
to return depending on the type of the separator.

If none of these arguments persuade you, then for the moment you can
continue to use the `join()' function from the string module, which
allows you to write

    string.join(['1', '2', '4', '8', '16'], ", ")


File: python.info,  Node: How fast are exceptions?,  Next: Why isn’t there a switch or case statement in Python?,  Prev: Why is join a string method instead of a list or tuple method?,  Up: Design and History FAQ

11.3.9 How fast are exceptions?
-------------------------------

A try/except block is extremely efficient if no exceptions are raised.
Actually catching an exception is expensive.  In versions of Python
prior to 2.0 it was common to use this idiom:

    try:
        value = mydict[key]
    except KeyError:
        mydict[key] = getvalue(key)
        value = mydict[key]

This only made sense when you expected the dict to have the key almost
all the time.  If that wasn’t the case, you coded it like this:

    if key in mydict:
        value = mydict[key]
    else:
        value = mydict[key] = getvalue(key)

     Note: In Python 2.0 and higher, you can code this as `value =
     mydict.setdefault(key, getvalue(key))'.


File: python.info,  Node: Why isn’t there a switch or case statement in Python?,  Next: Can’t you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?,  Prev: How fast are exceptions?,  Up: Design and History FAQ

11.3.10 Why isn’t there a switch or case statement in Python?
---------------------------------------------------------------

You can do this easily enough with a sequence of `if... elif... elif...
else'.  There have been some proposals for switch statement syntax, but
there is no consensus (yet) on whether and how to do range tests.  See PEP
275(1) for complete details and the current status.

For cases where you need to choose from a very large number of
possibilities, you can create a dictionary mapping case values to
functions to call.  For example:

    def function_1(...):
        ...

    functions = {'a': function_1,
                 'b': function_2,
                 'c': self.method_1, ...}

    func = functions[value]
    func()

For calling methods on objects, you can simplify yet further by using
the *Note getattr(): 89d. built-in to retrieve methods with a
particular name:

    def visit_a(self, ...):
        ...
    ...

    def dispatch(self, value):
        method_name = 'visit_' + str(value)
        method = getattr(self, method_name)
        method()

It’s suggested that you use a prefix for the method names, such as
`visit_' in this example.  Without such a prefix, if values are coming
from an untrusted source, an attacker would be able to call any method
on your object.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0275


File: python.info,  Node: Can’t you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?,  Next: Why can’t lambda expressions contain statements?,  Prev: Why isn’t there a switch or case statement in Python?,  Up: Design and History FAQ

11.3.11 Can’t you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?
------------------------------------------------------------------------------------------------------------------

Answer 1: Unfortunately, the interpreter pushes at least one C stack
frame for each Python stack frame.  Also, extensions can call back into
Python at almost random moments.  Therefore, a complete threads
implementation requires thread support for C.

Answer 2: Fortunately, there is Stackless Python(1), which has a
completely redesigned interpreter loop that avoids the C stack.

---------- Footnotes ----------

(1) http://www.stackless.com

