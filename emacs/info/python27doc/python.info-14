This is python.info, produced by makeinfo version 4.8 from python.texi.

Generated by Sphinx 1.6.3.
INFO-DIR-SECTION Python
START-INFO-DIR-ENTRY
* Python: (python.info). The Python reference manual.
END-INFO-DIR-ENTRY

     Python 2.7.13, July 15, 2017

     Copyright (C) 1990-2017, Python Software Foundation


File: python.info,  Node: Message Objects,  Prev: Folder Objects,  Up: mhlib — Access to MH mailboxes

5.18.5.3 Message Objects
........................

The *Note Message: 19af. class adds one method to those of *Note
mimetools.Message: 19b0.:

 -- Method: Message.openmessage (n)
     Return a new open message object (costs a file descriptor).


File: python.info,  Node: mimetools — Tools for parsing MIME messages,  Next: mimetypes — Map filenames to MIME types,  Prev: mhlib — Access to MH mailboxes,  Up: Internet Data Handling

5.18.6 `mimetools' — Tools for parsing MIME messages
------------------------------------------------------

Deprecated since version 2.3: The *Note email: bb. package should be
used in preference to the *Note mimetools: 110.  module.  This module
is present only to maintain backward compatibility, and it has been
removed in 3.x.

This module defines a subclass of the *Note rfc822: 148. module’s
*Note Message: 19b0.  class and a number of utility functions that are
useful for the manipulation for MIME multipart or encoded message.

It defines the following items:

 -- Class: mimetools.Message (fp[, seekable])
     Return a new instance of the *Note Message: 19b0. class.  This is
     a subclass of the *Note rfc822.Message: 193a. class, with some
     additional methods (see below).  The `seekable' argument has the
     same meaning as for *Note rfc822.Message: 193a.

 -- Function: mimetools.choose_boundary ()
     Return a unique string that has a high likelihood of being usable
     as a part boundary.  The string has the form
     `'hostipaddr.uid.pid.timestamp.random''.

 -- Function: mimetools.decode (input, output, encoding)
     Read data encoded using the allowed MIME `encoding' from open file
     object `input' and write the decoded data to open file object
     `output'.  Valid values for `encoding' include `'base64'',
     `'quoted-printable'', `'uuencode'', `'x-uuencode'', `'uue'',
     `'x-uue'', `'7bit'', and  `'8bit''.  Decoding messages encoded in
     `'7bit'' or `'8bit'' has no effect.  The input is simply copied to
     the output.

 -- Function: mimetools.encode (input, output, encoding)
     Read data from open file object `input' and write it encoded using
     the allowed MIME `encoding' to open file object `output'. Valid
     values for `encoding' are the same as for *Note decode(): 19d7.

 -- Function: mimetools.copyliteral (input, output)
     Read lines from open file `input' until EOF and write them to open
     file `output'.

 -- Function: mimetools.copybinary (input, output)
     Read blocks until EOF from open file `input' and write them to
     open file `output'.  The block size is currently fixed at 8192.

See also
........

Module *Note email: bb.
     Comprehensive email handling package; supersedes the *Note
     mimetools: 110. module.

Module *Note rfc822: 148.
     Provides the base class for *Note mimetools.Message: 19b0.

Module *Note multifile: 119.
     Support for reading files which contain distinct parts, such as
     MIME data.

<http://faqs.cs.uu.nl/na-dir/mail/mime-faq/.html>
     The MIME Frequently Asked Questions document.  For an overview of
     MIME, see the answer to question 1.1 in Part 1 of this document.

* Menu:

* Additional Methods of Message Objects::


File: python.info,  Node: Additional Methods of Message Objects,  Up: mimetools — Tools for parsing MIME messages

5.18.6.1 Additional Methods of Message Objects
..............................................

The *Note Message: 19b0. class defines the following methods in
addition to the *Note rfc822.Message: 193a. methods:

 -- Method: Message.getplist ()
     Return the parameter list of the `Content-Type' header. This is a
     list of strings.  For parameters of the form `key=value', `key' is
     converted to lower case but `value' is not.  For example, if the
     message contains the header `Content-type: text/html; spam=1;
     Spam=2; Spam' then *Note getplist(): 19dd.  will return the Python
     list `['spam=1', 'spam=2', 'Spam']'.

 -- Method: Message.getparam (name)
     Return the `value' of the first parameter (as returned by *Note
     getplist(): 19dd.) of the form `name=value' for the given `name'.
     If `value' is surrounded by quotes of the form ‘`<'…`>'’ or
     ‘`"'…`"'’, these are removed.

 -- Method: Message.getencoding ()
     Return the encoding specified in the `Content-Transfer-Encoding'
     message header.  If no such header exists, return `'7bit''.  The
     encoding is converted to lower case.

 -- Method: Message.gettype ()
     Return the message type (of the form `type/subtype') as specified
     in the `Content-Type' header.  If no such header exists, return
     `'text/plain''.  The type is converted to lower case.

 -- Method: Message.getmaintype ()
     Return the main type as specified in the `Content-Type' header.  If
     no such header exists, return `'text''.  The main type is
     converted to lower case.

 -- Method: Message.getsubtype ()
     Return the subtype as specified in the `Content-Type' header.  If
     no such header exists, return `'plain''.  The subtype is converted
     to lower case.


File: python.info,  Node: mimetypes — Map filenames to MIME types,  Next: MimeWriter — Generic MIME file writer,  Prev: mimetools — Tools for parsing MIME messages,  Up: Internet Data Handling

5.18.7 `mimetypes' — Map filenames to MIME types
--------------------------------------------------

`Source code:' Lib/mimetypes.py(1)

__________________________________________________________________

The *Note mimetypes: 111. module converts between a filename or URL and
the MIME type associated with the filename extension.  Conversions are
provided from filename to MIME type and from MIME type to filename
extension; encodings are not supported for the latter conversion.

The module provides one class and a number of convenience functions. The
functions are the normal interface to this module, but some
applications may be interested in the class as well.

The functions described below provide the primary interface for this
module.  If the module has not been initialized, they will call *Note
init(): 19e5. if they rely on the information *Note init(): 19e5. sets
up.

 -- Function: mimetypes.guess_type (url, strict=True)
     Guess the type of a file based on its filename or URL, given by
     `url'.  The return value is a tuple `(type, encoding)' where
     `type' is `None' if the type can’t be guessed (missing or
     unknown suffix) or a string of the form `'type/subtype'', usable
     for a MIME `content-type' header.

     `encoding' is `None' for no encoding or the name of the program
     used to encode (e.g. `compress' or `gzip'). The encoding is
     suitable for use as a `Content-Encoding' header, `not' as a
     `Content-Transfer-Encoding' header. The mappings are table driven.
     Encoding suffixes are case sensitive; type suffixes are first
     tried case sensitively, then case insensitively.

     The optional `strict' argument is a flag specifying whether the
     list of known MIME types is limited to only the official types
     registered with IANA(2).  When `strict' is `True' (the default),
     only the IANA types are supported; when `strict' is `False', some
     additional non-standard but commonly used MIME types are also
     recognized.

 -- Function: mimetypes.guess_all_extensions (type, strict=True)
     Guess the extensions for a file based on its MIME type, given by
     `type'. The return value is a list of strings giving all possible
     filename extensions, including the leading dot (`'.'').  The
     extensions are not guaranteed to have been associated with any
     particular data stream, but would be mapped to the MIME type
     `type' by *Note guess_type(): 19e6.

     The optional `strict' argument has the same meaning as with the
     *Note guess_type(): 19e6. function.

 -- Function: mimetypes.guess_extension (type, strict=True)
     Guess the extension for a file based on its MIME type, given by
     `type'. The return value is a string giving a filename extension,
     including the leading dot (`'.'').  The extension is not
     guaranteed to have been associated with any particular data
     stream, but would be mapped to the MIME type `type' by *Note
     guess_type(): 19e6.  If no extension can be guessed for `type',
     `None' is returned.

     The optional `strict' argument has the same meaning as with the
     *Note guess_type(): 19e6. function.

Some additional functions and data items are available for controlling
the behavior of the module.

 -- Function: mimetypes.init (files=None)
     Initialize the internal data structures.  If given, `files' must
     be a sequence of file names which should be used to augment the
     default type map.  If omitted, the file names to use are taken
     from *Note knownfiles: 19e9.; on Windows, the current registry
     settings are loaded.  Each file named in `files' or *Note
     knownfiles: 19e9. takes precedence over those named before it.
     Calling *Note init(): 19e5. repeatedly is allowed.

     Specifying an empty list for `files' will prevent the system
     defaults from being applied: only the well-known values will be
     present from a built-in list.

     Changed in version 2.7: Previously, Windows registry settings were
     ignored.


 -- Function: mimetypes.read_mime_types (filename)
     Load the type map given in the file `filename', if it exists.  The
     type map is returned as a dictionary mapping filename extensions,
     including the leading dot (`'.''), to strings of the form
     `'type/subtype''.  If the file `filename' does not exist or cannot
     be read, `None' is returned.

 -- Function: mimetypes.add_type (type, ext, strict=True)
     Add a mapping from the MIME type `type' to the extension `ext'.
     When the extension is already known, the new type will replace the
     old one. When the type is already known the extension will be
     added to the list of known extensions.

     When `strict' is `True' (the default), the mapping will be added
     to the official MIME types, otherwise to the non-standard ones.

 -- Data: mimetypes.inited
     Flag indicating whether or not the global data structures have
     been initialized.  This is set to `True' by *Note init(): 19e5.

 -- Data: mimetypes.knownfiles
     List of type map file names commonly installed.  These files are
     typically named `mime.types' and are installed in different
     locations by different packages.

 -- Data: mimetypes.suffix_map
     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the `.tgz'
     extension is mapped to `.tar.gz' to allow the encoding and type to
     be recognized separately.

 -- Data: mimetypes.encodings_map
     Dictionary mapping filename extensions to encoding types.

 -- Data: mimetypes.types_map
     Dictionary mapping filename extensions to MIME types.

 -- Data: mimetypes.common_types
     Dictionary mapping filename extensions to non-standard, but
     commonly found MIME types.

An example usage of the module:

    >>> import mimetypes
    >>> mimetypes.init()
    >>> mimetypes.knownfiles
    ['/etc/mime.types', '/etc/httpd/mime.types', ... ]
    >>> mimetypes.suffix_map['.tgz']
    '.tar.gz'
    >>> mimetypes.encodings_map['.gz']
    'gzip'
    >>> mimetypes.types_map['.tgz']
    'application/x-tar-gz'

* Menu:

* MimeTypes Objects::

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/mimetypes.py

(2) https://www.iana.org/assignments/media-types/media-types.xhtml


File: python.info,  Node: MimeTypes Objects,  Up: mimetypes — Map filenames to MIME types

5.18.7.1 MimeTypes Objects
..........................

The *Note MimeTypes: 19f3. class may be useful for applications which
may want more than one MIME-type database; it provides an interface
similar to the one of the *Note mimetypes: 111. module.

 -- Class: mimetypes.MimeTypes (filenames=(), strict=True)
     This class represents a MIME-types database.  By default, it
     provides access to the same database as the rest of this module.
     The initial database is a copy of that provided by the module, and
     may be extended by loading additional `mime.types'-style files
     into the database using the *Note read(): 19f4. or *Note readfp():
     19f5. methods.  The mapping dictionaries may also be cleared before
     loading additional data if the default data is not desired.

     The optional `filenames' parameter can be used to cause additional
     files to be loaded “on top” of the default database.

 -- Attribute: MimeTypes.suffix_map
     Dictionary mapping suffixes to suffixes.  This is used to allow
     recognition of encoded files for which the encoding and the type
     are indicated by the same extension.  For example, the `.tgz'
     extension is mapped to `.tar.gz' to allow the encoding and type to
     be recognized separately.  This is initially a copy of the global
     *Note suffix_map: 19ed. defined in the module.

 -- Attribute: MimeTypes.encodings_map
     Dictionary mapping filename extensions to encoding types.  This is
     initially a copy of the global *Note encodings_map: 19ee. defined
     in the module.

 -- Attribute: MimeTypes.types_map
     Tuple containing two dictionaries, mapping filename extensions to
     MIME types: the first dictionary is for the non-standards types
     and the second one is for the standard types. They are initialized
     by *Note common_types: 19f0. and *Note types_map: 19ef.

 -- Attribute: MimeTypes.types_map_inv
     Tuple containing two dictionaries, mapping MIME types to a list of
     filename extensions: the first dictionary is for the non-standards
     types and the second one is for the standard types. They are
     initialized by *Note common_types: 19f0. and *Note types_map: 19ef.

 -- Method: MimeTypes.guess_extension (type, strict=True)
     Similar to the *Note guess_extension(): 19e8. function, using the
     tables stored as part of the object.

 -- Method: MimeTypes.guess_type (url, strict=True)
     Similar to the *Note guess_type(): 19e6. function, using the
     tables stored as part of the object.

 -- Method: MimeTypes.guess_all_extensions (type, strict=True)
     Similar to the *Note guess_all_extensions(): 19e7. function, using
     the tables stored as part of the object.

 -- Method: MimeTypes.read (filename, strict=True)
     Load MIME information from a file named `filename'.  This uses
     *Note readfp(): 19f5. to parse the file.

     If `strict' is `True', information will be added to list of
     standard types, else to the list of non-standard types.

 -- Method: MimeTypes.readfp (fp, strict=True)
     Load MIME type information from an open file `fp'.  The file must
     have the format of the standard `mime.types' files.

     If `strict' is `True', information will be added to the list of
     standard types, else to the list of non-standard types.

 -- Method: MimeTypes.read_windows_registry (strict=True)
     Load MIME type information from the Windows registry.
     Availability: Windows.

     If `strict' is `True', information will be added to the list of
     standard types, else to the list of non-standard types.

     New in version 2.7.



File: python.info,  Node: MimeWriter — Generic MIME file writer,  Next: mimify — MIME processing of mail messages,  Prev: mimetypes — Map filenames to MIME types,  Up: Internet Data Handling

5.18.8 `MimeWriter' — Generic MIME file writer
------------------------------------------------

Deprecated since version 2.3: The *Note email: bb. package should be
used in preference to the *Note MimeWriter: 112.  module.  This module
is present only to maintain backward compatibility.

This module defines the class *Note MimeWriter: 1a00.  The *Note
MimeWriter: 1a00.  class implements a basic formatter for creating MIME
multi-part files.  It doesn’t seek around the output file nor does it
use large amounts of buffer space. You must write the parts out in the
order that they should occur in the final file. *Note MimeWriter: 1a00.
does buffer the headers you add, allowing you to rearrange their order.

 -- Class: MimeWriter.MimeWriter (fp)
     Return a new instance of the *Note MimeWriter: 1a00. class.  The
     only argument passed, `fp', is a file object to be used for
     writing. Note that a *Note StringIO: 2df. object could also be
     used.

* Menu:

* MimeWriter Objects::


File: python.info,  Node: MimeWriter Objects,  Up: MimeWriter — Generic MIME file writer

5.18.8.1 MimeWriter Objects
...........................

*Note MimeWriter: 1a00. instances have the following methods:

 -- Method: MimeWriter.addheader (key, value[, prefix])
     Add a header line to the MIME message. The `key' is the name of
     the header, where the `value' obviously provides the value of the
     header. The optional argument `prefix' determines where the header
     is inserted; `0' means append at the end, `1' is insert at the
     start. The default is to append.

 -- Method: MimeWriter.flushheaders ()
     Causes all headers accumulated so far to be written out (and
     forgotten). This is useful if you don’t need a body part at all,
     e.g. for a subpart of type `message/rfc822' that’s (mis)used to
     store some header-like information.

 -- Method: MimeWriter.startbody (ctype[, plist[, prefix]])
     Returns a file-like object which can be used to write to the body
     of the message.  The content-type is set to the provided `ctype',
     and the optional parameter `plist' provides additional parameters
     for the content-type declaration. `prefix' functions as in *Note
     addheader(): 1a03. except that the default is to insert at the
     start.

 -- Method: MimeWriter.startmultipartbody (subtype[, boundary[, plist[,
          prefix]]])
     Returns a file-like object which can be used to write to the body
     of the message.  Additionally, this method initializes the
     multi-part code, where `subtype' provides the multipart subtype,
     `boundary' may provide a user-defined boundary specification, and
     `plist' provides optional parameters for the subtype. `prefix'
     functions as in *Note startbody(): 1a05.  Subparts should be
     created using *Note nextpart(): 1a07.

 -- Method: MimeWriter.nextpart ()
     Returns a new instance of *Note MimeWriter: 1a00. which represents
     an individual part in a multipart message.  This may be used to
     write the  part as well as used for creating recursively complex
     multipart messages. The message must first be initialized with
     *Note startmultipartbody(): 1a06. before using *Note nextpart():
     1a07.

 -- Method: MimeWriter.lastpart ()
     This is used to designate the last part of a multipart message,
     and should `always' be used when writing multipart messages.


File: python.info,  Node: mimify — MIME processing of mail messages,  Next: multifile — Support for files containing distinct parts,  Prev: MimeWriter — Generic MIME file writer,  Up: Internet Data Handling

5.18.9 `mimify' — MIME processing of mail messages
----------------------------------------------------

Deprecated since version 2.3: The *Note email: bb. package should be
used in preference to the *Note mimify: 113.  module.  This module is
present only to maintain backward compatibility.

The *Note mimify: 113. module defines two functions to convert mail
messages to and from MIME format.  The mail message can be either a
simple message or a so-called multipart message.  Each part is treated
separately. Mimifying (a part of) a message entails encoding the
message as quoted-printable if it contains any characters that cannot
be represented using 7-bit ASCII.  Unmimifying (a part of) a message
entails undoing the quoted-printable encoding.  Mimify and unmimify are
especially useful when a message has to be edited before being sent.
Typical use would be:

    unmimify message
    edit message
    mimify message
    send message

The modules defines the following user-callable functions and
user-settable variables:

 -- Function: mimify.mimify (infile, outfile)
     Copy the message in `infile' to `outfile', converting parts to
     quoted-printable and adding MIME mail headers when necessary.
     `infile' and `outfile' can be file objects (actually, any object
     that has a *Note readline(): 145. method (for `infile') or a
     `write()' method (for `outfile')) or strings naming the files. If
     `infile' and `outfile' are both strings, they may have the same
     value.

 -- Function: mimify.unmimify (infile, outfile[, decode_base64])
     Copy the message in `infile' to `outfile', decoding all
     quoted-printable parts.  `infile' and `outfile' can be file
     objects (actually, any object that has a *Note readline(): 145.
     method (for `infile') or a `write()' method (for `outfile')) or
     strings naming the files.  If `infile' and `outfile' are both
     strings, they may have the same value. If the `decode_base64'
     argument is provided and tests true, any parts that are coded in
     the base64 encoding are decoded as well.

 -- Function: mimify.mime_decode_header (line)
     Return a decoded version of the encoded header line in `line'.
     This only supports the ISO 8859-1 charset (Latin-1).

 -- Function: mimify.mime_encode_header (line)
     Return a MIME-encoded version of the header line in `line'.

 -- Data: mimify.MAXLEN
     By default, a part will be encoded as quoted-printable when it
     contains any non-ASCII characters (characters with the 8th bit
     set), or if there are any lines longer than *Note MAXLEN: 1a0f.
     characters (default value 200).

 -- Data: mimify.CHARSET
     When not specified in the mail headers, a character set must be
     filled in.  The string used is stored in *Note CHARSET: 1a10, and
     the default value is ISO-8859-1 (also known as Latin1 (latin-one)).

This module can also be used from the command line.  Usage is as
follows:

    mimify.py -e [-l length] [infile [outfile]]
    mimify.py -d [-b] [infile [outfile]]

to encode (mimify) and decode (unmimify) respectively.  `infile'
defaults to standard input, `outfile' defaults to standard output. The
same file can be specified for input and output.

If the `-l' option is given when encoding, if there are any lines
longer than the specified `length', the containing part will be encoded.

If the `-b' option is given when decoding, any base64 parts will be
decoded as well.

See also
........

Module *Note quopri: 142.
     Encode and decode MIME quoted-printable files.


File: python.info,  Node: multifile — Support for files containing distinct parts,  Next: rfc822 — Parse RFC 2822 mail headers,  Prev: mimify — MIME processing of mail messages,  Up: Internet Data Handling

5.18.10 `multifile' — Support for files containing distinct parts
-------------------------------------------------------------------

Deprecated since version 2.5: The *Note email: bb. package should be
used in preference to the *Note multifile: 119.  module. This module is
present only to maintain backward compatibility.

The *Note MultiFile: 1a13. object enables you to treat sections of a
text file as file-like input objects, with `''' being returned by *Note
readline(): 145. when a given delimiter pattern is encountered.  The
defaults of this class are designed to make it useful for parsing MIME
multipart messages, but by subclassing it and overriding methods  it
can be easily adapted for more general use.

 -- Class: multifile.MultiFile (fp[, seekable])
     Create a multi-file.  You must instantiate this class with an
     input object argument for the *Note MultiFile: 1a13. instance to
     get lines from, such as a file object returned by *Note open():
     2d9.

     *Note MultiFile: 1a13. only ever looks at the input object’s
     *Note readline(): 145, *Note seek(): 1a14. and *Note tell(): 1a15.
     methods, and the latter two are only needed if you want random
     access to the individual MIME parts. To use *Note MultiFile: 1a13.
     on a non-seekable stream object, set the optional `seekable'
     argument to false; this will prevent using the input object’s
     *Note seek(): 1a14. and *Note tell(): 1a15. methods.

It will be useful to know that in *Note MultiFile: 1a13.’s view of
the world, text is composed of three kinds of lines: data,
section-dividers, and end-markers.  MultiFile is designed to support
parsing of messages that may have multiple nested message parts, each
with its own pattern for section-divider and end-marker lines.

See also
........

Module *Note email: bb.
     Comprehensive email handling package; supersedes the *Note
     multifile: 119. module.

* Menu:

* MultiFile Objects::
* MultiFile Example::


File: python.info,  Node: MultiFile Objects,  Next: MultiFile Example,  Up: multifile — Support for files containing distinct parts

5.18.10.1 MultiFile Objects
...........................

A *Note MultiFile: 1a13. instance has the following methods:

 -- Method: MultiFile.readline (str)
     Read a line.  If the line is data (not a section-divider or
     end-marker or real EOF) return it.  If the line matches the
     most-recently-stacked boundary, return `''' and set `self.last' to
     1 or 0 according as the match is or is not an end-marker.  If the
     line matches any other stacked boundary, raise an error.  On
     encountering end-of-file on the underlying stream object, the
     method raises `Error' unless all boundaries have been popped.

 -- Method: MultiFile.readlines (str)
     Return all lines remaining in this part as a list of strings.

 -- Method: MultiFile.read ()
     Read all lines, up to the next section.  Return them as a single
     (multiline) string.  Note that this doesn’t take a size argument!

 -- Method: MultiFile.seek (pos[, whence])
     Seek.  Seek indices are relative to the start of the current
     section. The `pos' and `whence' arguments are interpreted as for a
     file seek.

 -- Method: MultiFile.tell ()
     Return the file position relative to the start of the current
     section.

 -- Method: MultiFile.next ()
     Skip lines to the next section (that is, read lines until a
     section-divider or end-marker has been consumed).  Return true if
     there is such a section, false if an end-marker is seen.
     Re-enable the most-recently-pushed boundary.

 -- Method: MultiFile.is_data (str)
     Return true if `str' is data and false if it might be a section
     boundary.  As written, it tests for a prefix other than `'-'`-''
     at start of line (which all MIME boundaries have) but it is
     declared so it can be overridden in derived classes.

     Note that this test is used intended as a fast guard for the real
     boundary tests; if it always returns false it will merely slow
     processing, not cause it to fail.

 -- Method: MultiFile.push (str)
     Push a boundary string.  When a decorated version of this boundary
     is found as an input line, it will be interpreted as a
     section-divider  or end-marker (depending on the decoration, see RFC
     2045(1)).  All subsequent reads will return the empty string to
     indicate end-of-file, until a call to *Note pop(): 1a1e.  removes
     the boundary a or *Note next(): 1a1b. call reenables it.

     It is possible to push more than one boundary.  Encountering the
     most-recently-pushed boundary will return EOF; encountering any
     other boundary will raise an error.

 -- Method: MultiFile.pop ()
     Pop a section boundary.  This boundary will no longer be
     interpreted as EOF.

 -- Method: MultiFile.section_divider (str)
     Turn a boundary into a section-divider line.  By default, this
     method prepends `'--'' (which MIME section boundaries have) but it
     is declared so it can be overridden in derived classes.  This
     method need not append LF or CR-LF, as comparison with the result
     ignores trailing whitespace.

 -- Method: MultiFile.end_marker (str)
     Turn a boundary string into an end-marker line.  By default, this
     method prepends `'--'' and appends `'--'' (like a MIME-multipart
     end-of-message marker) but it is declared so it can be overridden
     in derived classes.  This method need not append LF or CR-LF, as
     comparison with the result ignores trailing whitespace.

Finally, *Note MultiFile: 1a13. instances have two public instance
variables:

 -- Attribute: MultiFile.level
     Nesting depth of the current part.

 -- Attribute: MultiFile.last
     True if the last end-of-file was for an end-of-message marker.

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2045.html


File: python.info,  Node: MultiFile Example,  Prev: MultiFile Objects,  Up: multifile — Support for files containing distinct parts

5.18.10.2 `MultiFile' Example
.............................

    import mimetools
    import multifile
    import StringIO

    def extract_mime_part_matching(stream, mimetype):
        """Return the first element in a multipart MIME message on stream
        matching mimetype."""

        msg = mimetools.Message(stream)
        msgtype = msg.gettype()
        params = msg.getplist()

        data = StringIO.StringIO()
        if msgtype[:10] == "multipart/":

            file = multifile.MultiFile(stream)
            file.push(msg.getparam("boundary"))
            while file.next():
                submsg = mimetools.Message(file)
                try:
                    data = StringIO.StringIO()
                    mimetools.decode(file, data, submsg.getencoding())
                except ValueError:
                    continue
                if submsg.gettype() == mimetype:
                    break
            file.pop()
        return data.getvalue()


File: python.info,  Node: rfc822 — Parse RFC 2822 mail headers,  Next: base64 — RFC 3548 Base16 Base32 Base64 Data Encodings,  Prev: multifile — Support for files containing distinct parts,  Up: Internet Data Handling

5.18.11 `rfc822' — Parse RFC 2822 mail headers
------------------------------------------------

Deprecated since version 2.3: The *Note email: bb. package should be
used in preference to the *Note rfc822: 148.  module.  This module is
present only to maintain backward compatibility, and has been removed
in Python 3.

This module defines a class, *Note Message: 193a, which represents an
“email message” as defined by the Internet standard RFC 2822(1).
(2)  Such messages consist of a collection of message headers, and a
message body.  This module also defines a helper class *Note
AddressList: 1a27. for parsing RFC 2822(3) addresses.  Please refer to
the RFC for information on the specific syntax of RFC 2822(4) messages.

The *Note mailbox: 10a. module provides classes  to read mailboxes
produced by various end-user mail programs.

 -- Class: rfc822.Message (file[, seekable])
     A *Note Message: 193a. instance is instantiated with an input
     object as parameter.  Message relies only on the input object
     having a *Note readline(): 145. method; in particular, ordinary
     file objects qualify.  Instantiation reads headers from the input
     object up to a delimiter line (normally a blank line) and stores
     them in the instance.  The message body, following the headers, is
     not consumed.

     This class can work with any input object that supports a *Note
     readline(): 145.  method.  If the input object has seek and tell
     capability, the *Note rewindbody(): 1a28. method will work; also,
     illegal lines will be pushed back onto the input stream.  If the
     input object lacks seek but has an `unread()' method that can push
     back a line of input, *Note Message: 193a. will use that to push
     back illegal lines.  Thus this class can be used to parse messages
     coming from a buffered stream.

     The optional `seekable' argument is provided as a workaround for
     certain stdio libraries in which `tell()' discards buffered data
     before discovering that the `lseek()' system call doesn’t work.
     For maximum portability, you should set the seekable argument to
     zero to prevent that initial `tell()' when passing in an
     unseekable object such as a file object created from a socket
     object.

     Input lines as read from the file may either be terminated by
     CR-LF or by a single linefeed; a terminating CR-LF is replaced by
     a single linefeed before the line is stored.

     All header matching is done independent of upper or lower case;
     e.g.  `m['From']', `m['from']' and `m['FROM']' all yield the same
     result.

 -- Class: rfc822.AddressList (field)
     You may instantiate the *Note AddressList: 1a27. helper class
     using a single string parameter, a comma-separated list of RFC
     2822(5) addresses to be parsed.  (The parameter `None' yields an
     empty list.)

 -- Function: rfc822.quote (str)
     Return a new string with backslashes in `str' replaced by two
     backslashes and double quotes replaced by backslash-double quote.

 -- Function: rfc822.unquote (str)
     Return a new string which is an `unquoted' version of `str'. If
     `str' ends and begins with double quotes, they are stripped off.
     Likewise if `str' ends and begins with angle brackets, they are
     stripped off.

 -- Function: rfc822.parseaddr (address)
     Parse `address', which should be the value of some
     address-containing field such as `To' or `Cc', into its
     constituent “realname” and “email address” parts. Returns
     a tuple of that information, unless the parse fails, in which case
     a 2-tuple `(None, None)' is returned.

 -- Function: rfc822.dump_address_pair (pair)
     The inverse of *Note parseaddr(): 1a2b, this takes a 2-tuple of
     the form `(realname, email_address)' and returns the string value
     suitable for a `To' or `Cc' header.  If the first element of
     `pair' is false, then the second element is returned unmodified.

 -- Function: rfc822.parsedate (date)
     Attempts to parse a date according to the rules in RFC 2822(6).
     however, some mailers don’t follow that format as specified, so
     *Note parsedate(): 1a2d. tries to guess correctly in such cases.
     `date' is a string containing an RFC 2822(7) date, such as  `'Mon,
     20 Nov 1995 19:12:08 -0500''.  If it succeeds in parsing the date,
     *Note parsedate(): 1a2d. returns a 9-tuple that can be passed
     directly to *Note time.mktime(): 1225.; otherwise `None' will be
     returned.  Note that indexes 6, 7, and 8 of the result tuple are
     not usable.

 -- Function: rfc822.parsedate_tz (date)
     Performs the same function as *Note parsedate(): 1a2d, but returns
     either `None' or a 10-tuple; the first 9 elements make up a tuple
     that can be passed directly to *Note time.mktime(): 1225, and the
     tenth is the offset of the date’s timezone from UTC (which is
     the official term for Greenwich Mean Time).  (Note that the sign of
     the timezone offset is the opposite of the sign of the
     `time.timezone' variable for the same timezone; the latter
     variable follows the POSIX standard while this module follows RFC
     2822(8).)  If the input string has no timezone, the last element
     of the tuple returned is `None'.  Note that indexes 6, 7, and 8 of
     the result tuple are not usable.

 -- Function: rfc822.mktime_tz (tuple)
     Turn a 10-tuple as returned by *Note parsedate_tz(): 1a2e. into a
     UTC timestamp.  If the timezone item in the tuple is `None',
     assume local time.  Minor deficiency: this first interprets the
     first 8 elements as a local time and then compensates for the
     timezone difference; this may yield a slight error around daylight
     savings time switch dates.  Not enough to worry about for common
     use.

See also
........

Module *Note email: bb.
     Comprehensive email handling package; supersedes the *Note rfc822:
     148. module.

Module *Note mailbox: 10a.
     Classes to read various mailbox formats produced  by end-user mail
     programs.

Module *Note mimetools: 110.
     Subclass of *Note rfc822.Message: 193a. that handles MIME encoded
     messages.

* Menu:

* Message Objects: Message Objects<2>.
* AddressList Objects::

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2822.html

(2) This module originally conformed to RFC 822
(https://tools.ietf.org/html/rfc822.html), hence the name.  Since then, RFC
2822 (https://tools.ietf.org/html/rfc2822.html) has been released as an
update to RFC 822 (https://tools.ietf.org/html/rfc822.html).  This
module should be considered RFC 2822
(https://tools.ietf.org/html/rfc2822.html)-conformant, especially in
cases where the syntax or semantics have changed since RFC 822
(https://tools.ietf.org/html/rfc822.html).

(3) https://tools.ietf.org/html/rfc2822.html

(4) https://tools.ietf.org/html/rfc2822.html

(5) https://tools.ietf.org/html/rfc2822.html

(6) https://tools.ietf.org/html/rfc2822.html

(7) https://tools.ietf.org/html/rfc2822.html

(8) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: Message Objects<2>,  Next: AddressList Objects,  Up: rfc822 — Parse RFC 2822 mail headers

5.18.11.1 Message Objects
.........................

A *Note Message: 193a. instance has the following methods:

 -- Method: Message.rewindbody ()
     Seek to the start of the message body.  This only works if the
     file object is seekable.

 -- Method: Message.isheader (line)
     Returns a line’s canonicalized fieldname (the dictionary key
     that will be used to index it) if the line is a legal RFC 2822(1)
     header; otherwise returns `None' (implying that parsing should
     stop here and the line be pushed back on the input stream).  It is
     sometimes useful to override this method in a subclass.

 -- Method: Message.islast (line)
     Return true if the given line is a delimiter on which Message
     should stop.  The delimiter line is consumed, and the file
     object’s read location positioned immediately after it.  By
     default this method just checks that the line is blank, but you
     can override it in a subclass.

 -- Method: Message.iscomment (line)
     Return `True' if the given line should be ignored entirely, just
     skipped. By default this is a stub that always returns `False',
     but you can override it in a subclass.

 -- Method: Message.getallmatchingheaders (name)
     Return a list of lines consisting of all headers matching `name',
     if any.  Each physical line, whether it is a continuation line or
     not, is a separate list item.  Return the empty list if no header
     matches `name'.

 -- Method: Message.getfirstmatchingheader (name)
     Return a list of lines comprising the first header matching
     `name', and its continuation line(s), if any.  Return `None' if
     there is no header matching `name'.

 -- Method: Message.getrawheader (name)
     Return a single string consisting of the text after the colon in
     the first header matching `name'.  This includes leading
     whitespace, the trailing linefeed, and internal linefeeds and
     whitespace if there any continuation line(s) were present.  Return
     `None' if there is no header matching `name'.

 -- Method: Message.getheader (name[, default])
     Return a single string consisting of the last header matching
     `name', but strip leading and trailing whitespace.  Internal
     whitespace is not stripped.  The optional `default' argument can be
     used to specify a different default to be returned when there is
     no header matching `name'; it defaults to `None'.  This is the
     preferred way to get parsed headers.

 -- Method: Message.get (name[, default])
     An alias for *Note getheader(): 1a38, to make the interface more
     compatible  with regular dictionaries.

 -- Method: Message.getaddr (name)
     Return a pair `(full name, email address)' parsed from the string
     returned by `getheader(name)'.  If no header matching `name'
     exists, return `(None, None)'; otherwise both the full name and
     the address are (possibly empty) strings.

     Example: If `m'’s first `From' header contains the string
     `'jack@cwi.nl (Jack Jansen)'', then `m.getaddr('From')' will yield
     the pair `('Jack Jansen', 'jack@cwi.nl')'. If the header contained
     `'Jack Jansen <jack@cwi.nl>'' instead, it would yield the exact
     same result.

 -- Method: Message.getaddrlist (name)
     This is similar to `getaddr(list)', but parses a header containing
     a list of email addresses (e.g. a `To' header) and returns a list
     of `(full name, email address)' pairs (even if there was only one
     address in the header).  If there is no header matching `name',
     return an empty list.

     If multiple headers exist that match the named header (e.g. if
     there are several `Cc' headers), all are parsed for addresses. Any
     continuation lines the named headers contain are also parsed.

 -- Method: Message.getdate (name)
     Retrieve a header using *Note getheader(): 1a38. and parse it into
     a 9-tuple compatible with *Note time.mktime(): 1225.; note that
     fields 6, 7, and 8  are not usable.  If there is no header
     matching `name', or it is unparsable, return `None'.

     Date parsing appears to be a black art, and not all mailers adhere
     to the standard.  While it has been tested and found correct on a
     large collection of email from many sources, it is still possible
     that this function may occasionally yield an incorrect result.

 -- Method: Message.getdate_tz (name)
     Retrieve a header using *Note getheader(): 1a38. and parse it into
     a 10-tuple; the first 9 elements will make a tuple compatible with
     *Note time.mktime(): 1225, and the 10th is a number giving the
     offset of the date’s timezone from UTC.  Note that fields 6, 7,
     and 8  are not usable.  Similarly to *Note getdate(): 1a3c, if
     there is no header matching `name', or it is unparsable, return
     `None'.

*Note Message: 193a. instances also support a limited mapping
interface. In particular: `m[name]' is like `m.getheader(name)' but
raises *Note KeyError: 205.  if there is no matching header; and
`len(m)', `m.get(name[, default])', `name in m', `m.keys()',
`m.values()' `m.items()', and `m.setdefault(name[, default])' act as
expected, with the one difference that `setdefault()' uses an empty
string as the default value.  *Note Message: 193a. instances also
support the mapping writable interface `m[name] = value' and `del
m[name]'.  *Note Message: 193a. objects do not support the `clear()',
*Note copy(): 71, `popitem()', or `update()' methods of the mapping
interface.  (Support for `get()' and `setdefault()' was only added in
Python 2.2.)

Finally, *Note Message: 193a. instances have some public instance
variables:

 -- Attribute: Message.headers
     A list containing the entire set of header lines, in the order in
     which they were read (except that setitem calls may disturb this
     order). Each line contains a trailing newline.  The blank line
     terminating the headers is not contained in the list.

 -- Attribute: Message.fp
     The file or file-like object passed at instantiation time.  This
     can be used to read the message content.

 -- Attribute: Message.unixfrom
     The Unix `From' line, if the message had one, or an empty string.
     This is needed to regenerate the message in some contexts, such as
     an `mbox'-style mailbox file.

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: AddressList Objects,  Prev: Message Objects<2>,  Up: rfc822 — Parse RFC 2822 mail headers

5.18.11.2 AddressList Objects
.............................

An *Note AddressList: 1a27. instance has the following methods:

 -- Method: AddressList.__len__ ()
     Return the number of addresses in the address list.

 -- Method: AddressList.__str__ ()
     Return a canonicalized string representation of the address list.
     Addresses are rendered in “name” <<host@domain>> form,
     comma-separated.

 -- Method: AddressList.__add__ (alist)
     Return a new *Note AddressList: 1a27. instance that contains all
     addresses in both *Note AddressList: 1a27. operands, with
     duplicates removed (set union).

 -- Method: AddressList.__iadd__ (alist)
     In-place version of *Note __add__(): 1a45.; turns this *Note
     AddressList: 1a27. instance into the union of itself and the
     right-hand instance, `alist'.

 -- Method: AddressList.__sub__ (alist)
     Return a new *Note AddressList: 1a27. instance that contains every
     address in the left-hand *Note AddressList: 1a27. operand that is
     not present in the right-hand address operand (set difference).

 -- Method: AddressList.__isub__ (alist)
     In-place version of *Note __sub__(): 1a47, removing addresses in
     this list which are also in `alist'.

Finally, *Note AddressList: 1a27. instances have one public instance
variable:

 -- Attribute: AddressList.addresslist
     A list of tuple string pairs, one per address.  In each member,
     the first is the canonicalized name part, the second is the actual
     route-address (`'@''-separated username-host.domain pair).


File: python.info,  Node: base64 — RFC 3548 Base16 Base32 Base64 Data Encodings,  Next: binhex — Encode and decode binhex4 files,  Prev: rfc822 — Parse RFC 2822 mail headers,  Up: Internet Data Handling

5.18.12 `base64' — RFC 3548: Base16, Base32, Base64 Data Encodings
--------------------------------------------------------------------

This module provides data encoding and decoding as specified in RFC
3548(1).  This standard defines the Base16, Base32, and Base64
algorithms for encoding and decoding arbitrary binary strings into text
strings that can be safely sent by email, used as parts of URLs, or
included as part of an HTTP POST request.  The encoding algorithm is
not the same as the `uuencode' program.

There are two interfaces provided by this module.  The modern interface
supports encoding and decoding string objects using both base-64
alphabets defined in RFC 3548(2) (normal, and URL- and
filesystem-safe).  The legacy interface provides for encoding and
decoding to and from file-like objects as well as strings, but only
using the Base64 standard alphabet.

The modern interface, which was introduced in Python 2.4, provides:

 -- Function: base64.b64encode (s[, altchars])
     Encode a string using Base64.

     `s' is the string to encode.  Optional `altchars' must be a string
     of at least length 2 (additional characters are ignored) which
     specifies an alternative alphabet for the `+' and `/' characters.
     This allows an application to e.g.  generate URL or filesystem
     safe Base64 strings.  The default is `None', for which the
     standard Base64 alphabet is used.

     The encoded string is returned.

 -- Function: base64.b64decode (s[, altchars])
     Decode a Base64 encoded string.

     `s' is the string to decode.  Optional `altchars' must be a string
     of at least length 2 (additional characters are ignored) which
     specifies the alternative alphabet used instead of the `+' and `/'
     characters.

     The decoded string is returned.  A *Note TypeError: 218. is raised
     if `s' is incorrectly padded.  Characters that are neither in the
     normal base-64 alphabet nor the alternative alphabet are discarded
     prior to the padding check.

 -- Function: base64.standard_b64encode (s)
     Encode string `s' using the standard Base64 alphabet.

 -- Function: base64.standard_b64decode (s)
     Decode string `s' using the standard Base64 alphabet.

 -- Function: base64.urlsafe_b64encode (s)
     Encode string `s' using the URL- and filesystem-safe alphabet,
     which substitutes `-' instead of `+' and `_' instead of `/' in the
     standard Base64 alphabet.  The result can still contain `='.

 -- Function: base64.urlsafe_b64decode (s)
     Decode string `s' using the URL- and filesystem-safe alphabet,
     which substitutes `-' instead of `+' and `_' instead of `/' in the
     standard Base64 alphabet.

 -- Function: base64.b32encode (s)
     Encode a string using Base32.  `s' is the string to encode.  The
     encoded string is returned.

 -- Function: base64.b32decode (s[, casefold[, map01]])
     Decode a Base32 encoded string.

     `s' is the string to decode.  Optional `casefold' is a flag
     specifying whether a lowercase alphabet is acceptable as input.
     For security purposes, the default is `False'.

     RFC 3548(3) allows for optional mapping of the digit 0 (zero) to
     the letter O (oh), and for optional mapping of the digit 1 (one)
     to either the letter I (eye) or letter L (el).  The optional
     argument `map01' when not `None', specifies which letter the digit
     1 should be mapped to (when `map01' is not `None', the digit 0 is
     always mapped to the letter O).  For security purposes the default
     is `None', so that 0 and 1 are not allowed in the input.

     The decoded string is returned.  A *Note TypeError: 218. is raised
     if `s' is incorrectly padded or if there are non-alphabet
     characters present in the string.

 -- Function: base64.b16encode (s)
     Encode a string using Base16.

     `s' is the string to encode.  The encoded string is returned.

 -- Function: base64.b16decode (s[, casefold])
     Decode a Base16 encoded string.

     `s' is the string to decode.  Optional `casefold' is a flag
     specifying whether a lowercase alphabet is acceptable as input.
     For security purposes, the default is `False'.

     The decoded string is returned.  A *Note TypeError: 218. is raised
     if `s' were incorrectly padded or if there are non-alphabet
     characters present in the string.

The legacy interface:

 -- Function: base64.decode (input, output)
     Decode the contents of the `input' file and write the resulting
     binary data to the `output' file. `input' and `output' must either
     be file objects or objects that mimic the file object interface.
     `input' will be read until `input.read()' returns an empty string.

 -- Function: base64.decodestring (s)
     Decode the string `s', which must contain one or more lines of
     base64 encoded data, and return a string containing the resulting
     binary data.

 -- Function: base64.encode (input, output)
     Encode the contents of the `input' file and write the resulting
     base64 encoded data to the `output' file. `input' and `output'
     must either be file objects or objects that mimic the file object
     interface. `input' will be read until `input.read()' returns an
     empty string.  *Note encode(): 1a57. returns the encoded data plus
     a trailing newline character (`'\n'').

 -- Function: base64.encodestring (s)
     Encode the string `s', which can contain arbitrary binary data,
     and return a string containing one or more lines of base64-encoded
     data.  *Note encodestring(): ab7. returns a string containing one
     or more lines of base64-encoded data always including an extra
     trailing newline (`'\n'').

An example usage of the module:

    >>> import base64
    >>> encoded = base64.b64encode('data to be encoded')
    >>> encoded
    'ZGF0YSB0byBiZSBlbmNvZGVk'
    >>> data = base64.b64decode(encoded)
    >>> data
    'data to be encoded'

See also
........

Module *Note binascii: 19.
     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

RFC 1521(4) - MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies
     Section 5.2, “Base64 Content-Transfer-Encoding,” provides the
     definition of the base64 encoding.

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc3548.html

(2) https://tools.ietf.org/html/rfc3548.html

(3) https://tools.ietf.org/html/rfc3548.html

(4) https://tools.ietf.org/html/rfc1521.html


File: python.info,  Node: binhex — Encode and decode binhex4 files,  Next: binascii — Convert between binary and ASCII,  Prev: base64 — RFC 3548 Base16 Base32 Base64 Data Encodings,  Up: Internet Data Handling

5.18.13 `binhex' — Encode and decode binhex4 files
----------------------------------------------------

This module encodes and decodes files in binhex4 format, a format
allowing representation of Macintosh files in ASCII.  On the Macintosh,
both forks of a file and the finder information are encoded (or
decoded), on other platforms only the data fork is handled.

     Note: In Python 3.x, special Macintosh support has been removed.

The *Note binhex: 1a. module defines the following functions:

 -- Function: binhex.binhex (input, output)
     Convert a binary file with filename `input' to binhex file
     `output'. The `output' parameter can either be a filename or a
     file-like object (any object supporting a `write()' and `close()'
     method).

 -- Function: binhex.hexbin (input[, output])
     Decode a binhex file `input'. `input' may be a filename or a
     file-like object supporting `read()' and `close()' methods. The
     resulting file is written to a file named `output', unless the
     argument is omitted in which case the output filename is read from
     the binhex file.

The following exception is also defined:

 -- Exception: binhex.Error
     Exception raised when something can’t be encoded using the
     binhex format (for example, a filename is too long to fit in the
     filename field), or when input is not properly encoded binhex data.

See also
........

Module *Note binascii: 19.
     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

* Menu:

* Notes: Notes<2>.


File: python.info,  Node: Notes<2>,  Up: binhex — Encode and decode binhex4 files

5.18.13.1 Notes
...............

There is an alternative, more powerful interface to the coder and
decoder, see the source for details.

If you code or decode textfiles on non-Macintosh platforms they will
still use the old Macintosh newline convention (carriage-return as end
of line).

As of this writing, *Note hexbin(): 1a5b. appears to not work in all
cases.


File: python.info,  Node: binascii — Convert between binary and ASCII,  Next: quopri — Encode and decode MIME quoted-printable data,  Prev: binhex — Encode and decode binhex4 files,  Up: Internet Data Handling

5.18.14 `binascii' — Convert between binary and ASCII
-------------------------------------------------------

The *Note binascii: 19. module contains a number of methods to convert
between binary and various ASCII-encoded binary representations.
Normally, you will not use these functions directly but use wrapper
modules like *Note uu: 18f, *Note base64: 15, or *Note binhex: 1a.
instead. The *Note binascii: 19. module contains low-level functions
written in C for greater speed that are used by the higher-level
modules.

The *Note binascii: 19. module defines the following functions:

 -- Function: binascii.a2b_uu (string)
     Convert a single line of uuencoded data back to binary and return
     the binary data. Lines normally contain 45 (binary) bytes, except
     for the last line. Line data may be followed by whitespace.

 -- Function: binascii.b2a_uu (data)
     Convert binary data to a line of ASCII characters, the return
     value is the converted line, including a newline char. The length
     of `data' should be at most 45.

 -- Function: binascii.a2b_base64 (string)
     Convert a block of base64 data back to binary and return the
     binary data. More than one line may be passed at a time.

 -- Function: binascii.b2a_base64 (data)
     Convert binary data to a line of ASCII characters in base64
     coding. The return value is the converted line, including a
     newline char.  The newline is added because the original use case
     for this function was to feed it a series of 57 byte input lines
     to get output lines that conform to the MIME-base64 standard.
     Otherwise the output conforms to RFC 3548(1).

 -- Function: binascii.a2b_qp (string[, header])
     Convert a block of quoted-printable data back to binary and return
     the binary data. More than one line may be passed at a time. If
     the optional argument `header' is present and true, underscores
     will be decoded as spaces.

 -- Function: binascii.b2a_qp (data[, quotetabs, istext, header])
     Convert binary data to a line(s) of ASCII characters in
     quoted-printable encoding.  The return value is the converted
     line(s). If the optional argument `quotetabs' is present and true,
     all tabs and spaces will be encoded.   If the optional argument
     `istext' is present and true, newlines are not encoded but
     trailing whitespace will be encoded. If the optional argument
     `header' is present and true, spaces will be encoded as
     underscores per RFC1522. If the optional argument `header' is
     present and false, newline characters will be encoded as well;
     otherwise linefeed conversion might corrupt the binary data stream.

 -- Function: binascii.a2b_hqx (string)
     Convert binhex4 formatted ASCII data to binary, without doing
     RLE-decompression.  The string should contain a complete number of
     binary bytes, or (in case of the last portion of the binhex4 data)
     have the remaining bits zero.

 -- Function: binascii.rledecode_hqx (data)
     Perform RLE-decompression on the data, as per the binhex4
     standard. The algorithm uses `0x90' after a byte as a repeat
     indicator, followed by a count.  A count of `0' specifies a byte
     value of `0x90'. The routine returns the decompressed data, unless
     data input data ends in an orphaned repeat indicator, in which
     case the *Note Incomplete: 1a69. exception is raised.

 -- Function: binascii.rlecode_hqx (data)
     Perform binhex4 style RLE-compression on `data' and return the
     result.

 -- Function: binascii.b2a_hqx (data)
     Perform hexbin4 binary-to-ASCII translation and return the
     resulting string. The argument should already be RLE-coded, and
     have a length divisible by 3 (except possibly the last fragment).

 -- Function: binascii.crc_hqx (data, crc)
     Compute the binhex4 crc value of `data', starting with an initial
     `crc' and returning the result.

 -- Function: binascii.crc32 (data[, crc])
     Compute CRC-32, the 32-bit checksum of data, starting with an
     initial crc.  This is consistent with the ZIP file checksum.
     Since the algorithm is designed for use as a checksum algorithm,
     it is not suitable for use as a general hash algorithm.  Use as
     follows:

         print binascii.crc32("hello world")
         # Or, in two pieces:
         crc = binascii.crc32("hello")
         crc = binascii.crc32(" world", crc) & 0xffffffff
         print 'crc32 = 0x%08x' % crc

     Note: To generate the same numeric value across all Python
     versions and platforms use crc32(data) & 0xffffffff.  If you are
     only using the checksum in packed binary format this is not
     necessary as the return value is the correct 32bit binary
     representation regardless of sign.

Changed in version 2.6: The return value is in the range [-2**31,
2**31-1] regardless of platform.  In the past the value would be signed
on some platforms and unsigned on others.  Use & 0xffffffff on the
value if you want it to match Python 3 behavior.

Changed in version 3.0: The return value is unsigned and in the range
[0, 2**32-1] regardless of platform.

 -- Function: binascii.b2a_hex (data)
 -- Function: binascii.hexlify (data)
     Return the hexadecimal representation of the binary `data'.  Every
     byte of `data' is converted into the corresponding 2-digit hex
     representation.  The resulting string is therefore twice as long
     as the length of `data'.

 -- Function: binascii.a2b_hex (hexstr)
 -- Function: binascii.unhexlify (hexstr)
     Return the binary data represented by the hexadecimal string
     `hexstr'.  This function is the inverse of *Note b2a_hex(): abb.
     `hexstr' must contain an even number of hexadecimal digits (which
     can be upper or lower case), otherwise a *Note TypeError: 218. is
     raised.

 -- Exception: binascii.Error
     Exception raised on errors. These are usually programming errors.

 -- Exception: binascii.Incomplete
     Exception raised on incomplete data. These are usually not
     programming errors, but may be handled by reading a little more
     data and trying again.

See also
........

Module *Note base64: 15.
     Support for RFC compliant base64-style encoding in base 16, 32,
     and 64.

Module *Note binhex: 1a.
     Support for the binhex format used on the Macintosh.

Module *Note uu: 18f.
     Support for UU encoding used on Unix.

Module *Note quopri: 142.
     Support for quoted-printable encoding used in MIME email messages.

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc3548.html


File: python.info,  Node: quopri — Encode and decode MIME quoted-printable data,  Next: uu — Encode and decode uuencode files,  Prev: binascii — Convert between binary and ASCII,  Up: Internet Data Handling

5.18.15 `quopri' — Encode and decode MIME quoted-printable data
-----------------------------------------------------------------

`Source code:' Lib/quopri.py(1)

__________________________________________________________________

This module performs quoted-printable transport encoding and decoding,
as defined in RFC 1521(2): “MIME (Multipurpose Internet Mail
Extensions) Part One: Mechanisms for Specifying and Describing the
Format of Internet Message Bodies”.  The quoted-printable encoding is
designed for data where there are relatively few nonprintable
characters; the base64 encoding scheme available via the *Note base64:
15. module is more compact if there are many such characters, as when
sending a graphics file.

 -- Function: quopri.decode (input, output[, header])
     Decode the contents of the `input' file and write the resulting
     decoded binary data to the `output' file. `input' and `output'
     must either be file objects or objects that mimic the file object
     interface. `input' will be read until `input.readline()' returns
     an empty string. If the optional argument `header' is present and
     true, underscore will be decoded as space. This is used to decode
     “Q”-encoded headers as described in RFC 1522(3): “MIME
     (Multipurpose Internet Mail Extensions) Part Two: Message Header
     Extensions for Non-ASCII Text”.

 -- Function: quopri.encode (input, output, quotetabs)
     Encode the contents of the `input' file and write the resulting
     quoted-printable data to the `output' file. `input' and `output'
     must either be file objects or objects that mimic the file object
     interface. `input' will be read until `input.readline()' returns
     an empty string. `quotetabs' is a flag which controls whether to
     encode embedded spaces and tabs; when true it encodes such
     embedded whitespace, and when false it leaves them unencoded.
     Note that spaces and tabs appearing at the end of lines are always
     encoded, as per RFC 1521(4).

 -- Function: quopri.decodestring (s[, header])
     Like *Note decode(): abe, except that it accepts a source string
     and returns the corresponding decoded string.

 -- Function: quopri.encodestring (s[, quotetabs])
     Like *Note encode(): abd, except that it accepts a source string
     and returns the corresponding encoded string.  `quotetabs' is
     optional (defaulting to 0), and is passed straight through to
     *Note encode(): abd.

See also
........

Module *Note mimify: 113.
     General utilities for processing of MIME messages.

Module *Note base64: 15.
     Encode and decode MIME base64 data

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/quopri.py

(2) https://tools.ietf.org/html/rfc1521.html

(3) https://tools.ietf.org/html/rfc1522.html

(4) https://tools.ietf.org/html/rfc1521.html


File: python.info,  Node: uu — Encode and decode uuencode files,  Prev: quopri — Encode and decode MIME quoted-printable data,  Up: Internet Data Handling

5.18.16 `uu' — Encode and decode uuencode files
-------------------------------------------------

`Source code:' Lib/uu.py(1)

__________________________________________________________________

This module encodes and decodes files in uuencode format, allowing
arbitrary binary data to be transferred over ASCII-only connections.
Wherever a file argument is expected, the methods accept a file-like
object.  For backwards compatibility, a string containing a pathname is
also accepted, and the corresponding file will be opened for reading
and writing; the pathname `'-'' is understood to mean the standard
input or output.  However, this interface is deprecated; it’s better
for the caller to open the file itself, and be sure that, when
required, the mode is `'rb'' or `'wb'' on Windows.

This code was contributed by Lance Ellinghouse, and modified by Jack
Jansen.

The *Note uu: 18f. module defines the following functions:

 -- Function: uu.encode (in_file, out_file[, name[, mode]])
     Uuencode file `in_file' into file `out_file'.  The uuencoded file
     will have the header specifying `name' and `mode' as the defaults
     for the results of decoding the file. The default defaults are
     taken from `in_file', or `'-'' and `0666' respectively.

 -- Function: uu.decode (in_file[, out_file[, mode[, quiet]]])
     This call decodes uuencoded file `in_file' placing the result on
     file `out_file'. If `out_file' is a pathname, `mode' is used to
     set the permission bits if the file must be created. Defaults for
     `out_file' and `mode' are taken from the uuencode header.
     However, if the file specified in the header already exists, a
     *Note uu.Error: 1a77. is raised.

     *Note decode(): ac0. may print a warning to standard error if the
     input was produced by an incorrect uuencoder and Python could
     recover from that error.  Setting `quiet' to a true value silences
     this warning.

 -- Exception: uu.Error
     Subclass of *Note Exception: 34d, this can be raised by *Note
     uu.decode(): ac0. under various situations, such as described
     above, but also including a badly formatted header, or truncated
     input file.

See also
........

Module *Note binascii: 19.
     Support module containing ASCII-to-binary and binary-to-ASCII
     conversions.

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/uu.py


File: python.info,  Node: Structured Markup Processing Tools,  Next: Internet Protocols and Support,  Prev: Internet Data Handling,  Up: The Python Standard Library

5.19 Structured Markup Processing Tools
=======================================

Python supports a variety of modules to work with various forms of
structured data markup.  This includes modules to work with the
Standard Generalized Markup Language (SGML) and the Hypertext Markup
Language (HTML), and several interfaces for working with the Extensible
Markup Language (XML).

It is important to note that modules in the *Note xml: 1a0. package
require that there be at least one SAX-compliant XML parser available.
Starting with Python 2.3, the Expat parser is included with Python, so
the *Note xml.parsers.expat: 1a5.  module will always be available. You
may still want to be aware of the PyXML add-on package(1); that package
provides an extended set of XML libraries for Python.

The documentation for the *Note xml.dom: 1a1. and *Note xml.sax: 1a6.
packages are the definition of the Python bindings for the DOM and SAX
interfaces.

* Menu:

* HTMLParser — Simple HTML and XHTML parser::
* sgmllib — Simple SGML parser::
* htmllib — A parser for HTML documents::
* htmlentitydefs — Definitions of HTML general entities::
* XML Processing Modules::
* XML vulnerabilities::
* xml.etree.ElementTree — The ElementTree XML API: xml etree ElementTree — The ElementTree XML API.
* xml.dom — The Document Object Model API: xml dom — The Document Object Model API.
* xml.dom.minidom — Minimal DOM implementation: xml dom minidom — Minimal DOM implementation.
* xml.dom.pulldom — Support for building partial DOM trees: xml dom pulldom — Support for building partial DOM trees.
* xml.sax — Support for SAX2 parsers: xml sax — Support for SAX2 parsers.
* xml.sax.handler — Base classes for SAX handlers: xml sax handler — Base classes for SAX handlers.
* xml.sax.saxutils — SAX Utilities: xml sax saxutils — SAX Utilities.
* xml.sax.xmlreader — Interface for XML parsers: xml sax xmlreader — Interface for XML parsers.
* xml.parsers.expat — Fast XML parsing using Expat: xml parsers expat — Fast XML parsing using Expat.

---------- Footnotes ----------

(1) http://pyxml.sourceforge.net/


File: python.info,  Node: HTMLParser — Simple HTML and XHTML parser,  Next: sgmllib — Simple SGML parser,  Up: Structured Markup Processing Tools

5.19.1 `HTMLParser' — Simple HTML and XHTML parser
----------------------------------------------------

     Note: The *Note HTMLParser: ee. module has been renamed to
     `html.parser' in Python 3.  The *Note 2to3: c05. tool will
     automatically adapt imports when converting your sources to Python
     3.

New in version 2.2.

`Source code:' Lib/HTMLParser.py(1)

__________________________________________________________________

This module defines a class *Note HTMLParser: 1a7d. which serves as the
basis for parsing text files formatted in HTML (HyperText Mark-up
Language) and XHTML.  Unlike the parser in *Note htmllib: ed, this
parser is not based on the SGML parser in *Note sgmllib: 150.

 -- Class: HTMLParser.HTMLParser
     An *Note HTMLParser: 1a7d. instance is fed HTML data and calls
     handler methods when start tags, end tags, text, comments, and
     other markup elements are encountered.  The user should subclass
     *Note HTMLParser: 1a7d. and override its methods to implement the
     desired behavior.

     The *Note HTMLParser: 1a7d. class is instantiated without
     arguments.

     Unlike the parser in *Note htmllib: ed, this parser does not check
     that end tags match start tags or call the end-tag handler for
     elements which are closed implicitly by closing an outer element.

An exception is defined as well:

 -- Exception: HTMLParser.HTMLParseError
     *Note HTMLParser: 1a7d. is able to handle broken markup, but in
     some cases it might raise this exception when it encounters an
     error while parsing.  This exception provides three attributes:
     `msg' is a brief message explaining the error, `lineno' is the
     number of the line on which the broken construct was detected, and
     `offset' is the number of characters into the line at which the
     construct starts.

* Menu:

* Example HTML Parser Application::
* HTMLParser Methods::
* Examples: Examples<10>.

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/HTMLParser.py


File: python.info,  Node: Example HTML Parser Application,  Next: HTMLParser Methods,  Up: HTMLParser — Simple HTML and XHTML parser

5.19.1.1 Example HTML Parser Application
........................................

As a basic example, below is a simple HTML parser that uses the *Note
HTMLParser: 1a7d. class to print out start tags, end tags and data as
they are encountered:

    from HTMLParser import HTMLParser

    # create a subclass and override the handler methods
    class MyHTMLParser(HTMLParser):
        def handle_starttag(self, tag, attrs):
            print "Encountered a start tag:", tag

        def handle_endtag(self, tag):
            print "Encountered an end tag :", tag

        def handle_data(self, data):
            print "Encountered some data  :", data

    # instantiate the parser and fed it some HTML
    parser = MyHTMLParser()
    parser.feed('<html><head><title>Test</title></head>'
                '<body><h1>Parse me!</h1></body></html>')

The output will then be:

    Encountered a start tag: html
    Encountered a start tag: head
    Encountered a start tag: title
    Encountered some data  : Test
    Encountered an end tag : title
    Encountered an end tag : head
    Encountered a start tag: body
    Encountered a start tag: h1
    Encountered some data  : Parse me!
    Encountered an end tag : h1
    Encountered an end tag : body
    Encountered an end tag : html


File: python.info,  Node: HTMLParser Methods,  Next: Examples<10>,  Prev: Example HTML Parser Application,  Up: HTMLParser — Simple HTML and XHTML parser

5.19.1.2 `HTMLParser' Methods
.............................

*Note HTMLParser: 1a7d. instances have the following methods:

 -- Method: HTMLParser.feed (data)
     Feed some text to the parser.  It is processed insofar as it
     consists of complete elements; incomplete data is buffered until
     more data is fed or *Note close(): 1a82. is called.  `data' can be
     either *Note unicode: 1f5. or *Note str: 1ea, but passing *Note
     unicode: 1f5. is advised.

 -- Method: HTMLParser.close ()
     Force processing of all buffered data as if it were followed by an
     end-of-file mark.  This method may be redefined by a derived class
     to define additional processing at the end of the input, but the
     redefined version should always call the *Note HTMLParser: 1a7d.
     base class method *Note close(): 1a82.

 -- Method: HTMLParser.reset ()
     Reset the instance.  Loses all unprocessed data.  This is called
     implicitly at instantiation time.

 -- Method: HTMLParser.getpos ()
     Return current line number and offset.

 -- Method: HTMLParser.get_starttag_text ()
     Return the text of the most recently opened start tag.  This
     should not normally be needed for structured processing, but may
     be useful in dealing with HTML “as deployed” or for
     re-generating input with minimal changes (whitespace between
     attributes can be preserved, etc.).

The following methods are called when data or markup elements are
encountered and they are meant to be overridden in a subclass.  The
base class implementations do nothing (except for *Note
handle_startendtag(): 1a86.):

 -- Method: HTMLParser.handle_starttag (tag, attrs)
     This method is called to handle the start of a tag (e.g. `<div
     id="main">').

     The `tag' argument is the name of the tag converted to lower case.
     The `attrs' argument is a list of `(name, value)' pairs containing
     the attributes found inside the tag’s `<>' brackets.  The `name'
     will be translated to lower case, and quotes in the `value' have
     been removed, and character and entity references have been
     replaced.

     For instance, for the tag `<A HREF="https://www.cwi.nl/">', this
     method would be called as `handle_starttag('a', [('href',
     'https://www.cwi.nl/')])'.

     Changed in version 2.6: All entity references from *Note
     htmlentitydefs: ec. are now replaced in the attribute values.


 -- Method: HTMLParser.handle_endtag (tag)
     This method is called to handle the end tag of an element (e.g.
     `</div>').

     The `tag' argument is the name of the tag converted to lower case.

 -- Method: HTMLParser.handle_startendtag (tag, attrs)
     Similar to *Note handle_starttag(): 1a87, but called when the
     parser encounters an XHTML-style empty tag (`<img ... />').  This
     method may be overridden by subclasses which require this
     particular lexical information; the default implementation simply
     calls *Note handle_starttag(): 1a87. and *Note handle_endtag():
     1a88.

 -- Method: HTMLParser.handle_data (data)
     This method is called to process arbitrary data (e.g. text nodes
     and the content of `<script>...</script>' and
     `<style>...</style>').

 -- Method: HTMLParser.handle_entityref (name)
     This method is called to process a named character reference of
     the form `&name;' (e.g. `&gt;'), where `name' is a general entity
     reference (e.g. `'gt'').

 -- Method: HTMLParser.handle_charref (name)
     This method is called to process decimal and hexadecimal numeric
     character references of the form `&#NNN;' and `&#xNNN;'.  For
     example, the decimal equivalent for `&gt;' is `&#62;', whereas the
     hexadecimal is `&#x3E;'; in this case the method will receive
     `'62'' or `'x3E''.

 -- Method: HTMLParser.handle_comment (data)
     This method is called when a comment is encountered (e.g.
     `<!--comment-->').

     For example, the comment `<!-- comment -->' will cause this method
     to be called with the argument `' comment ''.

     The content of Internet Explorer conditional comments (condcoms)
     will also be sent to this method, so, for `<!--[if IE
     9]>IE9-specific content<![endif]-->', this method will receive
     `'[if IE 9]>IE9-specific content<![endif]''.

 -- Method: HTMLParser.handle_decl (decl)
     This method is called to handle an HTML doctype declaration (e.g.
     `<!DOCTYPE html>').

     The `decl' parameter will be the entire contents of the
     declaration inside the `<!...>' markup (e.g. `'DOCTYPE html'').

 -- Method: HTMLParser.handle_pi (data)
     This method is called when a processing instruction is
     encountered.  The `data' parameter will contain the entire
     processing instruction.  For example, for the processing
     instruction `<?proc color='red'>', this method would be called as
     `handle_pi("proc color='red'")'.

          Note: The *Note HTMLParser: 1a7d. class uses the SGML
          syntactic rules for processing instructions.  An XHTML
          processing instruction using the trailing `'?'' will cause
          the `'?'' to be included in `data'.

 -- Method: HTMLParser.unknown_decl (data)
     This method is called when an unrecognized declaration is read by
     the parser.

     The `data' parameter will be the entire contents of the
     declaration inside the `<![...]>' markup.  It is sometimes useful
     to be overridden by a derived class.


File: python.info,  Node: Examples<10>,  Prev: HTMLParser Methods,  Up: HTMLParser — Simple HTML and XHTML parser

5.19.1.3 Examples
.................

The following class implements a parser that will be used to illustrate
more examples:

    from HTMLParser import HTMLParser
    from htmlentitydefs import name2codepoint

    class MyHTMLParser(HTMLParser):
        def handle_starttag(self, tag, attrs):
            print "Start tag:", tag
            for attr in attrs:
                print "     attr:", attr

        def handle_endtag(self, tag):
            print "End tag  :", tag

        def handle_data(self, data):
            print "Data     :", data

        def handle_comment(self, data):
            print "Comment  :", data

        def handle_entityref(self, name):
            c = unichr(name2codepoint[name])
            print "Named ent:", c

        def handle_charref(self, name):
            if name.startswith('x'):
                c = unichr(int(name[1:], 16))
            else:
                c = unichr(int(name))
            print "Num ent  :", c

        def handle_decl(self, data):
            print "Decl     :", data

    parser = MyHTMLParser()

Parsing a doctype:

    >>> parser.feed('<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" '
    ...             '"http://www.w3.org/TR/html4/strict.dtd">')
    Decl     : DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"

Parsing an element with a few attributes and a title:

    >>> parser.feed('<img src="python-logo.png" alt="The Python logo">')
    Start tag: img
         attr: ('src', 'python-logo.png')
         attr: ('alt', 'The Python logo')
    >>>
    >>> parser.feed('<h1>Python</h1>')
    Start tag: h1
    Data     : Python
    End tag  : h1

The content of `script' and `style' elements is returned as is, without
further parsing:

    >>> parser.feed('<style type="text/css">#python { color: green }</style>')
    Start tag: style
         attr: ('type', 'text/css')
    Data     : #python { color: green }
    End tag  : style

    >>> parser.feed('<script type="text/javascript">'
    ...             'alert("<strong>hello!</strong>");</script>')
    Start tag: script
         attr: ('type', 'text/javascript')
    Data     : alert("<strong>hello!</strong>");
    End tag  : script

Parsing comments:

    >>> parser.feed('<!-- a comment -->'
    ...             '<!--[if IE 9]>IE-specific content<![endif]-->')
    Comment  :  a comment
    Comment  : [if IE 9]>IE-specific content<![endif]

Parsing named and numeric character references and converting them to
the correct char (note: these 3 references are all equivalent to `'>''):

    >>> parser.feed('&gt;&#62;&#x3E;')
    Named ent: >
    Num ent  : >
    Num ent  : >

Feeding incomplete chunks to *Note feed(): 1a81. works, but *Note
handle_data(): 1a89. might be called more than once:

    >>> for chunk in ['<sp', 'an>buff', 'ered ', 'text</s', 'pan>']:
    ...     parser.feed(chunk)
    ...
    Start tag: span
    Data     : buff
    Data     : ered
    Data     : text
    End tag  : span

Parsing invalid HTML (e.g. unquoted attributes) also works:

    >>> parser.feed('<p><a class=link href=#main>tag soup</p ></a>')
    Start tag: p
    Start tag: a
         attr: ('class', 'link')
         attr: ('href', '#main')
    Data     : tag soup
    End tag  : p
    End tag  : a


File: python.info,  Node: sgmllib — Simple SGML parser,  Next: htmllib — A parser for HTML documents,  Prev: HTMLParser — Simple HTML and XHTML parser,  Up: Structured Markup Processing Tools

5.19.2 `sgmllib' — Simple SGML parser
---------------------------------------

Deprecated since version 2.6: The *Note sgmllib: 150. module has been
removed in Python 3.

This module defines a class *Note SGMLParser: 1a94. which serves as the
basis for parsing text files formatted in SGML (Standard Generalized
Mark-up Language).  In fact, it does not provide a full SGML parser —
it only parses SGML insofar as it is used by HTML, and the module only
exists as a base for the *Note htmllib: ed. module.  Another HTML
parser which supports XHTML and offers a somewhat different interface
is available in the *Note HTMLParser: ee. module.

 -- Class: sgmllib.SGMLParser
     The *Note SGMLParser: 1a94. class is instantiated without
     arguments. The parser is hardcoded to recognize the following
     constructs:

        * Opening and closing tags of the form `<tag attr="value" ...>'
          and `</tag>', respectively.

        * Numeric character references of the form `&#name;'.

        * Entity references of the form `&name;'.

        * SGML comments of the form `<!--text-->'.  Note that spaces,
          tabs, and newlines are allowed between the trailing `>' and
          the immediately preceding `--'.

A single exception is defined as well:

 -- Exception: sgmllib.SGMLParseError
     Exception raised by the *Note SGMLParser: 1a94. class when it
     encounters an error while parsing.

     New in version 2.1.


*Note SGMLParser: 1a94. instances have the following methods:

 -- Method: SGMLParser.reset ()
     Reset the instance.  Loses all unprocessed data.  This is called
     implicitly at instantiation time.

 -- Method: SGMLParser.setnomoretags ()
     Stop processing tags.  Treat all following input as literal input
     (CDATA).  (This is only provided so the HTML tag `<PLAINTEXT>' can
     be implemented.)

 -- Method: SGMLParser.setliteral ()
     Enter literal mode (CDATA mode).

 -- Method: SGMLParser.feed (data)
     Feed some text to the parser.  It is processed insofar as it
     consists of complete elements; incomplete data is buffered until
     more data is fed or *Note close(): 1a9a. is called.

 -- Method: SGMLParser.close ()
     Force processing of all buffered data as if it were followed by an
     end-of-file mark.  This method may be redefined by a derived class
     to define additional processing at the end of the input, but the
     redefined version should always call *Note close(): 1a9a.

 -- Method: SGMLParser.get_starttag_text ()
     Return the text of the most recently opened start tag.  This
     should not normally be needed for structured processing, but may
     be useful in dealing with HTML “as deployed” or for
     re-generating input with minimal changes (whitespace between
     attributes can be preserved, etc.).

 -- Method: SGMLParser.handle_starttag (tag, method, attributes)
     This method is called to handle start tags for which either a
     `start_tag()' or `do_tag()' method has been defined.  The `tag'
     argument is the name of the tag converted to lower case, and the
     `method' argument is the bound method which should be used to
     support semantic interpretation of the start tag. The `attributes'
     argument is a list of `(name, value)' pairs containing the
     attributes found inside the tag’s `<>' brackets.

     The `name' has been translated to lower case. Double quotes and
     backslashes in the `value' have been interpreted, as well as known
     character references and known entity references terminated by a
     semicolon (normally, entity references can be terminated by any
     non-alphanumerical character, but this would break the very common
     case of `<A HREF="url?spam=1&eggs=2">' when `eggs' is a valid
     entity name).

     For instance, for the tag `<A HREF="http://www.cwi.nl/">', this
     method would be called as `unknown_starttag('a', [('href',
     'http://www.cwi.nl/')])'.  The base implementation simply calls
     `method' with `attributes' as the only argument.

     New in version 2.5: Handling of entity and character references
     within attribute values.


 -- Method: SGMLParser.handle_endtag (tag, method)
     This method is called to handle endtags for which an `end_tag()'
     method has been defined.  The `tag' argument is the name of the
     tag converted to lower case, and the `method' argument is the
     bound method which should be used to support semantic
     interpretation of the end tag.  If no `end_tag()' method is
     defined for the closing element, this handler is not called.  The
     base implementation simply calls `method'.

 -- Method: SGMLParser.handle_data (data)
     This method is called to process arbitrary data.  It is intended
     to be overridden by a derived class; the base class implementation
     does nothing.

 -- Method: SGMLParser.handle_charref (ref)
     This method is called to process a character reference of the form
     `&#ref;'.  The base implementation uses *Note convert_charref():
     1aa0. to convert the reference to a string.  If that method
     returns a string, it is passed to *Note handle_data(): 1a9e,
     otherwise `unknown_charref(ref)' is called to handle the error.

     Changed in version 2.5: Use *Note convert_charref(): 1aa0. instead
     of hard-coding the conversion.


 -- Method: SGMLParser.convert_charref (ref)
     Convert a character reference to a string, or `None'.  `ref' is
     the reference passed in as a string.  In the base implementation,
     `ref' must be a decimal number in the range 0–255.  It converts
     the code point found using the *Note convert_codepoint(): 1aa1.
     method. If `ref' is invalid or out of range, this method returns
     `None'.  This method is called by the default *Note
     handle_charref(): 1a9f. implementation and by the attribute value
     parser.

     New in version 2.5.


 -- Method: SGMLParser.convert_codepoint (codepoint)
     Convert a code point to a *Note str: 1ea. value.  Encodings can be
     handled here if appropriate, though the rest of *Note sgmllib:
     150. is oblivious on this matter.

     New in version 2.5.


 -- Method: SGMLParser.handle_entityref (ref)
     This method is called to process a general entity reference of the
     form `&ref;' where `ref' is a general entity reference.  It
     converts `ref' by passing it to *Note convert_entityref(): 1aa3.
     If a translation is returned, it calls the method *Note
     handle_data(): 1a9e. with the translation; otherwise, it calls the
     method `unknown_entityref(ref)'. The default `entitydefs' defines
     translations for `&amp;', `&apos', `&gt;', `&lt;', and `&quot;'.

     Changed in version 2.5: Use *Note convert_entityref(): 1aa3.
     instead of hard-coding the conversion.


 -- Method: SGMLParser.convert_entityref (ref)
     Convert a named entity reference to a *Note str: 1ea. value, or
     `None'.  The resulting value will not be parsed.  `ref' will be
     only the name of the entity.  The default implementation looks for
     `ref' in the instance (or class) variable `entitydefs' which
     should be a mapping from entity names to corresponding
     translations.  If no translation is available for `ref', this
     method returns `None'.  This method is called by the default *Note
     handle_entityref(): 1aa2.  implementation and by the attribute
     value parser.

     New in version 2.5.


 -- Method: SGMLParser.handle_comment (comment)
     This method is called when a comment is encountered.  The
     `comment' argument is a string containing the text between the
     `<!--' and `-->' delimiters, but not the delimiters themselves.
     For example, the comment `<!--text-->' will cause this method to
     be called with the argument `'text''.  The default method does
     nothing.

 -- Method: SGMLParser.handle_decl (data)
     Method called when an SGML declaration is read by the parser.  In
     practice, the `DOCTYPE' declaration is the only thing observed in
     HTML, but the parser does not discriminate among different (or
     broken) declarations.  Internal subsets in a `DOCTYPE' declaration
     are not supported.  The `data' parameter will be the entire
     contents of the declaration inside the `<!'…`>' markup.  The
     default implementation does nothing.

 -- Method: SGMLParser.report_unbalanced (tag)
     This method is called when an end tag is found which does not
     correspond to any open element.

 -- Method: SGMLParser.unknown_starttag (tag, attributes)
     This method is called to process an unknown start tag.  It is
     intended to be overridden by a derived class; the base class
     implementation does nothing.

 -- Method: SGMLParser.unknown_endtag (tag)
     This method is called to process an unknown end tag.  It is
     intended to be overridden by a derived class; the base class
     implementation does nothing.

 -- Method: SGMLParser.unknown_charref (ref)
     This method is called to process unresolvable numeric character
     references.  Refer to *Note handle_charref(): 1a9f. to determine
     what is handled by default.  It is intended to be overridden by a
     derived class; the base class implementation does nothing.

 -- Method: SGMLParser.unknown_entityref (ref)
     This method is called to process an unknown entity reference.  It
     is intended to be overridden by a derived class; the base class
     implementation does nothing.

Apart from overriding or extending the methods listed above, derived
classes may also define methods of the following form to define
processing of specific tags.  Tag names in the input stream are case
independent; the `tag' occurring in method names must be in lower case:

 -- Method: SGMLParser.start_tag (attributes)
     This method is called to process an opening tag `tag'.  It has
     preference over `do_tag()'.  The `attributes' argument has the
     same meaning as described for *Note handle_starttag(): 1a9c. above.

 -- Method: SGMLParser.do_tag (attributes)
     This method is called to process an opening tag `tag'  for which no
     `start_tag()' method is defined.   The `attributes' argument has
     the same meaning as described for *Note handle_starttag(): 1a9c.
     above.

 -- Method: SGMLParser.end_tag ()
     This method is called to process a closing tag `tag'.

Note that the parser maintains a stack of open elements for which no
end tag has been found yet.  Only tags processed by `start_tag()' are
pushed on this stack.  Definition of an `end_tag()' method is optional
for these tags.  For tags processed by `do_tag()' or by
`unknown_tag()', no `end_tag()' method must be defined; if defined, it
will not be used.  If both `start_tag()' and `do_tag()' methods exist
for a tag, the `start_tag()' method takes precedence.


File: python.info,  Node: htmllib — A parser for HTML documents,  Next: htmlentitydefs — Definitions of HTML general entities,  Prev: sgmllib — Simple SGML parser,  Up: Structured Markup Processing Tools

5.19.3 `htmllib' — A parser for HTML documents
------------------------------------------------

Deprecated since version 2.6: The *Note htmllib: ed. module has been
removed in Python 3.  Use *Note HTMLParser: ee. instead in Python 2,
and the equivalent, `html.parser', in Python 3.

This module defines a class which can serve as a base for parsing text
files formatted in the HyperText Mark-up Language (HTML).  The class is
not directly concerned with I/O — it must be provided with input in
string form via a method, and makes calls to methods of a
“formatter” object in order to produce output.  The *Note
HTMLParser: 1a7d. class is designed to be used as a base class for
other classes in order to add functionality, and allows most of its
methods to be extended or overridden.  In turn, this class is derived
from and extends the `SGMLParser' class defined in module *Note
sgmllib: 150.  The *Note HTMLParser: 1a7d. implementation supports the
HTML 2.0 language as described in RFC 1866(1).  Two implementations of
formatter objects are provided in the *Note formatter: d4. module;
refer to the documentation for that module for information on the
formatter interface.

The following is a summary of the interface defined by *Note
sgmllib.SGMLParser: 1a94.:

   * The interface to feed data to an instance is through the `feed()'
     method, which takes a string argument.  This can be called with as
     little or as much text at a time as desired; `p.feed(a);
     p.feed(b)' has the same effect as `p.feed(a+b)'.  When the data
     contains complete HTML markup constructs, these are processed
     immediately; incomplete constructs are saved in a buffer.  To
     force processing of all unprocessed data, call the `close()'
     method.

     For example, to parse the entire contents of a file, use:

         parser.feed(open('myfile.html').read())
         parser.close()

   * The interface to define semantics for HTML tags is very simple:
     derive a class and define methods called `start_tag()',
     `end_tag()', or `do_tag()'.  The parser will call these at
     appropriate moments: `start_tag()' or `do_tag()' is called when an
     opening tag of the form `<tag ...>' is encountered; `end_tag()' is
     called when a closing tag of the form `<tag>' is encountered.  If
     an opening tag requires a corresponding closing tag, like `<H1>'
     … `</H1>', the class should define the `start_tag()' method; if
     a tag requires no closing tag, like `<P>', the class should define
     the `do_tag()' method.

The module defines a parser class and an exception:

 -- Class: htmllib.HTMLParser (formatter)
     This is the basic HTML parser class.  It supports all entity names
     required by the XHTML 1.0 Recommendation
     (<https://www.w3.org/TR/xhtml1>).   It also defines handlers for
     all HTML 2.0 and many HTML 3.0 and 3.2 elements.

 -- Exception: htmllib.HTMLParseError
     Exception raised by the *Note HTMLParser: 1a7d. class when it
     encounters an error while parsing.

     New in version 2.4.


See also
........

Module *Note formatter: d4.
     Interface definition for transforming an abstract flow of
     formatting events into specific output events on writer objects.

Module *Note HTMLParser: ee.
     Alternate HTML parser that offers a slightly lower-level view of
     the input, but is designed to work with XHTML, and does not
     implement some of the SGML syntax not used in “HTML as
     deployed” and which isn’t legal for XHTML.

Module *Note htmlentitydefs: ec.
     Definition of replacement text for XHTML 1.0  entities.

Module *Note sgmllib: 150.
     Base class for *Note HTMLParser: 1a7d.

* Menu:

* HTMLParser Objects::

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc1866.html


File: python.info,  Node: HTMLParser Objects,  Up: htmllib — A parser for HTML documents

5.19.3.1 HTMLParser Objects
...........................

In addition to tag methods, the *Note HTMLParser: 1a7d. class provides
some additional methods and instance variables for use within tag
methods.

 -- Attribute: HTMLParser.formatter
     This is the formatter instance associated with the parser.

 -- Attribute: HTMLParser.nofill
     Boolean flag which should be true when whitespace should not be
     collapsed, or false when it should be.  In general, this should
     only be true when character data is to be treated as
     “preformatted” text, as within a `<PRE>' element.  The default
     value is false.  This affects the operation of `handle_data()' and
     *Note save_end(): 1ab3.

 -- Method: HTMLParser.anchor_bgn (href, name, type)
     This method is called at the start of an anchor region.  The
     arguments correspond to the attributes of the `<A>' tag with the
     same names.  The default implementation maintains a list of
     hyperlinks (defined by the `HREF' attribute for `<A>' tags) within
     the document.  The list of hyperlinks is available as the data
     attribute `anchorlist'.

 -- Method: HTMLParser.anchor_end ()
     This method is called at the end of an anchor region.  The default
     implementation adds a textual footnote marker using an index into
     the list of hyperlinks created by *Note anchor_bgn(): 1ab4.

 -- Method: HTMLParser.handle_image (source, alt[, ismap[, align[,
          width[, height]]]])
     This method is called to handle images.  The default
     implementation simply passes the `alt' value to the
     `handle_data()' method.

 -- Method: HTMLParser.save_bgn ()
     Begins saving character data in a buffer instead of sending it to
     the formatter object.  Retrieve the stored data via *Note
     save_end(): 1ab3. Use of the *Note save_bgn(): 1ab7. / *Note
     save_end(): 1ab3. pair may not be nested.

 -- Method: HTMLParser.save_end ()
     Ends buffering character data and returns all data saved since the
     preceding call to *Note save_bgn(): 1ab7.  If the *Note nofill:
     1ab2. flag is false, whitespace is collapsed to single spaces.  A
     call to this method without a preceding call to *Note save_bgn():
     1ab7. will raise a *Note TypeError: 218. exception.


File: python.info,  Node: htmlentitydefs — Definitions of HTML general entities,  Next: XML Processing Modules,  Prev: htmllib — A parser for HTML documents,  Up: Structured Markup Processing Tools

5.19.4 `htmlentitydefs' — Definitions of HTML general entities
----------------------------------------------------------------

     Note: The *Note htmlentitydefs: ec. module has been renamed to
     `html.entities' in Python 3.  The *Note 2to3: c05. tool will
     automatically adapt imports when converting your sources to Python
     3.

`Source code:' Lib/htmlentitydefs.py(1)

__________________________________________________________________

This module defines three dictionaries, `name2codepoint',
`codepoint2name', and `entitydefs'. `entitydefs' is used by the *Note
htmllib: ed. module to provide the *Note entitydefs: 1ab9. attribute of
the *Note HTMLParser: 1a7d. class.  The definition provided here
contains all the entities defined by XHTML 1.0  that can be handled
using simple textual substitution in the Latin-1 character set
(ISO-8859-1).

 -- Data: htmlentitydefs.entitydefs
     A dictionary mapping XHTML 1.0 entity definitions to their
     replacement text in ISO Latin-1.

 -- Data: htmlentitydefs.name2codepoint
     A dictionary that maps HTML entity names to the Unicode code
     points.

     New in version 2.3.


 -- Data: htmlentitydefs.codepoint2name
     A dictionary that maps Unicode code points to HTML entity names.

     New in version 2.3.


---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/htmlentitydefs.py


File: python.info,  Node: XML Processing Modules,  Next: XML vulnerabilities,  Prev: htmlentitydefs — Definitions of HTML general entities,  Up: Structured Markup Processing Tools

5.19.5 XML Processing Modules
-----------------------------

Python’s interfaces for processing XML are grouped in the `xml'
package.

     Warning: The XML modules are not secure against erroneous or
     maliciously constructed data.  If you need to parse untrusted or
     unauthenticated data see *Note XML vulnerabilities: 1abf.

It is important to note that modules in the *Note xml: 1a0. package
require that there be at least one SAX-compliant XML parser available.
The Expat parser is included with Python, so the *Note
xml.parsers.expat: 1a5. module will always be available.

The documentation for the *Note xml.dom: 1a1. and *Note xml.sax: 1a6.
packages are the definition of the Python bindings for the DOM and SAX
interfaces.

The XML handling submodules are:

   * *Note xml.etree.ElementTree: 1a4.: the ElementTree API, a simple
     and lightweight XML processor

   * *Note xml.dom: 1a1.: the DOM API definition

   * *Note xml.dom.minidom: 1a2.: a minimal DOM implementation

   * *Note xml.dom.pulldom: 1a3.: support for building partial DOM trees

   * *Note xml.sax: 1a6.: SAX2 base classes and convenience functions

   * *Note xml.parsers.expat: 1a5.: the Expat parser binding


File: python.info,  Node: XML vulnerabilities,  Next: xml etree ElementTree — The ElementTree XML API,  Prev: XML Processing Modules,  Up: Structured Markup Processing Tools

5.19.6 XML vulnerabilities
--------------------------

The XML processing modules are not secure against maliciously
constructed data.  An attacker can abuse vulnerabilities for e.g.
denial of service attacks, to access local files, to generate network
connections to other machines, or to or circumvent firewalls. The
attacks on XML abuse unfamiliar features like inline DTD(1) (document
type definition) with entities.

The following table gives an overview of the known attacks and if the
various modules are vulnerable to them.

kind                          sax                etree               minidom            pulldom            xmlrpc
------------------------------------------------------------------------------------------------------------------------------ 
billion laughs                `Vulnerable'       `Vulnerable'        `Vulnerable'       `Vulnerable'       `Vulnerable'
quadratic blowup              `Vulnerable'       `Vulnerable'        `Vulnerable'       `Vulnerable'       `Vulnerable'
external entity expansion     `Vulnerable'       Safe    (1)         Safe    (2)        `Vulnerable'       Safe    (3)
DTD(2) retrieval              `Vulnerable'       Safe                Safe               `Vulnerable'       Safe
decompression bomb            Safe               Safe                Safe               Safe               `Vulnerable'

  1. *Note xml.etree.ElementTree: 1a4. doesn’t expand external
     entities and raises a ParserError when an entity occurs.

  2. *Note xml.dom.minidom: 1a2. doesn’t expand external entities and
     simply returns the unexpanded entity verbatim.

  3. *Note xmlrpclib: 1aa. doesn’t expand external entities and omits
     them.

billion laughs / exponential entity expansion
     The Billion Laughs(3) attack – also known as exponential entity
     expansion – uses multiple levels of nested entities. Each entity
     refers to another entity several times, the final entity
     definition contains a small string. Eventually the small string is
     expanded to several gigabytes. The exponential expansion consumes
     lots of CPU time, too.

quadratic blowup entity expansion
     A quadratic blowup attack is similar to a Billion Laughs(4)
     attack; it abuses entity expansion, too. Instead of nested
     entities it repeats one large entity with a couple of thousand
     chars over and over again. The attack isn’t as efficient as the
     exponential case but it avoids triggering countermeasures of
     parsers against heavily nested entities.

external entity expansion
     Entity declarations can contain more than just text for
     replacement. They can also point to external resources by public
     identifiers or system identifiers.  System identifiers are
     standard URIs or can refer to local files. The XML parser
     retrieves the resource with e.g. HTTP or FTP requests and embeds
     the content into the XML document.

DTD(5) retrieval
     Some XML libraries like Python’s *Note xml.dom.pulldom: 1a3.
     retrieve document type definitions from remote or local locations.
     The feature has similar implications as the external entity
     expansion issue.

decompression bomb
     The issue of decompression bombs (aka ZIP bomb(6)) apply to all
     XML libraries that can parse compressed XML stream like gzipped
     HTTP streams or LZMA-ed files. For an attacker it can reduce the
     amount of transmitted data by three magnitudes or more.

The documentation of defusedxml(7) on PyPI has further information about
all known attack vectors with examples and references.

* Menu:

* defused packages::

---------- Footnotes ----------

(1) https://en.wikipedia.org/wiki/Document_type_definition

(2) https://en.wikipedia.org/wiki/Document_type_definition

(3) https://en.wikipedia.org/wiki/Billion_laughs

(4) https://en.wikipedia.org/wiki/Billion_laughs

(5) https://en.wikipedia.org/wiki/Document_type_definition

(6) https://en.wikipedia.org/wiki/Zip_bomb

(7) https://pypi.python.org/pypi/defusedxml/


File: python.info,  Node: defused packages,  Up: XML vulnerabilities

5.19.6.1 defused packages
.........................

These external packages are recommended for any code that parses
untrusted XML data.

defusedxml(1) is a pure Python package with modified subclasses of all
stdlib XML parsers that prevent any potentially malicious operation. The
package also ships with example exploits and extended documentation on
more XML exploits like xpath injection.

defusedexpat(2) provides a modified libexpat and patched replacement
`pyexpat' extension module with countermeasures against entity expansion
DoS attacks. Defusedexpat still allows a sane and configurable amount
of entity expansions. The modifications will be merged into future
releases of Python.

The workarounds and modifications are not included in patch releases as
they break backward compatibility. After all inline DTD and entity
expansion are well-defined XML features.

---------- Footnotes ----------

(1) https://pypi.python.org/pypi/defusedxml/

(2) https://pypi.python.org/pypi/defusedexpat/


File: python.info,  Node: xml etree ElementTree — The ElementTree XML API,  Next: xml dom — The Document Object Model API,  Prev: XML vulnerabilities,  Up: Structured Markup Processing Tools

5.19.7 `xml.etree.ElementTree' — The ElementTree XML API
----------------------------------------------------------

New in version 2.5.

`Source code:' Lib/xml/etree/ElementTree.py(1)

__________________________________________________________________

The *Note Element: 2b3. type is a flexible container object, designed
to store hierarchical data structures in memory.  The type can be
described as a cross between a list and a dictionary.

     Warning: The *Note xml.etree.ElementTree: 1a4. module is not
     secure against maliciously constructed data.  If you need to parse
     untrusted or unauthenticated data see *Note XML vulnerabilities:
     1abf.

Each element has a number of properties associated with it:

   * a tag which is a string identifying what kind of data this element
     represents (the element type, in other words).

   * a number of attributes, stored in a Python dictionary.

   * a text string.

   * an optional tail string.

   * a number of child elements, stored in a Python sequence

To create an element instance, use the *Note Element: 2b3. constructor
or the *Note SubElement(): 1ac5. factory function.

The *Note ElementTree: 1ac6. class can be used to wrap an element
structure, and convert it from and to XML.

A C implementation of this API is available as `xml.etree.cElementTree'.

See <http://effbot.org/zone/element-index.htm> for tutorials and links
to other docs.  Fredrik Lundh’s page is also the location of the
development version of the xml.etree.ElementTree.

Changed in version 2.7: The ElementTree API is updated to 1.3.  For
more information, see Introducing ElementTree 1.3(2).

* Menu:

* Tutorial: Tutorial<2>.
* XPath support::
* Reference: Reference<2>.

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/xml/etree/ElementTree.py

(2) http://effbot.org/zone/elementtree-13-intro.htm


File: python.info,  Node: Tutorial<2>,  Next: XPath support,  Up: xml etree ElementTree — The ElementTree XML API

5.19.7.1 Tutorial
.................

This is a short tutorial for using *Note xml.etree.ElementTree: 1a4.
(`ET' in short).  The goal is to demonstrate some of the building
blocks and basic concepts of the module.

* Menu:

* XML tree and elements::
* Parsing XML::
* Finding interesting elements::
* Modifying an XML File::
* Building XML documents::
* Parsing XML with Namespaces::
* Additional resources::


File: python.info,  Node: XML tree and elements,  Next: Parsing XML,  Up: Tutorial<2>

5.19.7.2 XML tree and elements
..............................

XML is an inherently hierarchical data format, and the most natural way
to represent it is with a tree.  `ET' has two classes for this purpose -
*Note ElementTree: 1ac6. represents the whole XML document as a tree,
and *Note Element: 2b3. represents a single node in this tree.
Interactions with the whole document (reading and writing to/from
files) are usually done on the *Note ElementTree: 1ac6. level.
Interactions with a single XML element and its sub-elements are done on
the *Note Element: 2b3. level.


File: python.info,  Node: Parsing XML,  Next: Finding interesting elements,  Prev: XML tree and elements,  Up: Tutorial<2>

5.19.7.3 Parsing XML
....................

We’ll be using the following XML document as the sample data for this
section:

    <?xml version="1.0"?>
    <data>
        <country name="Liechtenstein">
            <rank>1</rank>
            <year>2008</year>
            <gdppc>141100</gdppc>
            <neighbor name="Austria" direction="E"/>
            <neighbor name="Switzerland" direction="W"/>
        </country>
        <country name="Singapore">
            <rank>4</rank>
            <year>2011</year>
            <gdppc>59900</gdppc>
            <neighbor name="Malaysia" direction="N"/>
        </country>
        <country name="Panama">
            <rank>68</rank>
            <year>2011</year>
            <gdppc>13600</gdppc>
            <neighbor name="Costa Rica" direction="W"/>
            <neighbor name="Colombia" direction="E"/>
        </country>
    </data>

We have a number of ways to import the data.  Reading the file from
disk:

    import xml.etree.ElementTree as ET
    tree = ET.parse('country_data.xml')
    root = tree.getroot()

Reading the data from a string:

    root = ET.fromstring(country_data_as_string)

*Note fromstring(): 1acb. parses XML from a string directly into an
*Note Element: 2b3, which is the root element of the parsed tree.
Other parsing functions may create an *Note ElementTree: 1ac6.  Check
the documentation to be sure.

As an *Note Element: 2b3, `root' has a tag and a dictionary of
attributes:

    >>> root.tag
    'data'
    >>> root.attrib
    {}

It also has children nodes over which we can iterate:

    >>> for child in root:
    ...     print child.tag, child.attrib
    ...
    country {'name': 'Liechtenstein'}
    country {'name': 'Singapore'}
    country {'name': 'Panama'}

Children are nested, and we can access specific child nodes by index:

    >>> root[0][1].text
    '2008'


File: python.info,  Node: Finding interesting elements,  Next: Modifying an XML File,  Prev: Parsing XML,  Up: Tutorial<2>

5.19.7.4 Finding interesting elements
.....................................

*Note Element: 2b3. has some useful methods that help iterate
recursively over all the sub-tree below it (its children, their
children, and so on).  For example, *Note Element.iter(): 2b5.:

    >>> for neighbor in root.iter('neighbor'):
    ...     print neighbor.attrib
    ...
    {'name': 'Austria', 'direction': 'E'}
    {'name': 'Switzerland', 'direction': 'W'}
    {'name': 'Malaysia', 'direction': 'N'}
    {'name': 'Costa Rica', 'direction': 'W'}
    {'name': 'Colombia', 'direction': 'E'}

*Note Element.findall(): 1acd. finds only elements with a tag which are
direct children of the current element.  *Note Element.find(): 1ace.
finds the `first' child with a particular tag, and *Note Element.text:
1acf. accesses the element’s text content.  *Note Element.get():
1ad0. accesses the element’s attributes:

    >>> for country in root.findall('country'):
    ...     rank = country.find('rank').text
    ...     name = country.get('name')
    ...     print name, rank
    ...
    Liechtenstein 1
    Singapore 4
    Panama 68

More sophisticated specification of which elements to look for is
possible by using *Note XPath: 1ad1.


File: python.info,  Node: Modifying an XML File,  Next: Building XML documents,  Prev: Finding interesting elements,  Up: Tutorial<2>

5.19.7.5 Modifying an XML File
..............................

*Note ElementTree: 1ac6. provides a simple way to build XML documents
and write them to files.  The *Note ElementTree.write(): 2b1. method
serves this purpose.

Once created, an *Note Element: 2b3. object may be manipulated by
directly changing its fields (such as *Note Element.text: 1acf.),
adding and modifying attributes (*Note Element.set(): 1ad3. method), as
well as adding new children (for example with *Note Element.append():
1ad4.).

Let’s say we want to add one to each country’s rank, and add an
`updated' attribute to the rank element:

    >>> for rank in root.iter('rank'):
    ...     new_rank = int(rank.text) + 1
    ...     rank.text = str(new_rank)
    ...     rank.set('updated', 'yes')
    ...
    >>> tree.write('output.xml')

Our XML now looks like this:

    <?xml version="1.0"?>
    <data>
        <country name="Liechtenstein">
            <rank updated="yes">2</rank>
            <year>2008</year>
            <gdppc>141100</gdppc>
            <neighbor name="Austria" direction="E"/>
            <neighbor name="Switzerland" direction="W"/>
        </country>
        <country name="Singapore">
            <rank updated="yes">5</rank>
            <year>2011</year>
            <gdppc>59900</gdppc>
            <neighbor name="Malaysia" direction="N"/>
        </country>
        <country name="Panama">
            <rank updated="yes">69</rank>
            <year>2011</year>
            <gdppc>13600</gdppc>
            <neighbor name="Costa Rica" direction="W"/>
            <neighbor name="Colombia" direction="E"/>
        </country>
    </data>

We can remove elements using *Note Element.remove(): 1ad5.  Let’s say
we want to remove all countries with a rank higher than 50:

    >>> for country in root.findall('country'):
    ...     rank = int(country.find('rank').text)
    ...     if rank > 50:
    ...         root.remove(country)
    ...
    >>> tree.write('output.xml')

Our XML now looks like this:

    <?xml version="1.0"?>
    <data>
        <country name="Liechtenstein">
            <rank updated="yes">2</rank>
            <year>2008</year>
            <gdppc>141100</gdppc>
            <neighbor name="Austria" direction="E"/>
            <neighbor name="Switzerland" direction="W"/>
        </country>
        <country name="Singapore">
            <rank updated="yes">5</rank>
            <year>2011</year>
            <gdppc>59900</gdppc>
            <neighbor name="Malaysia" direction="N"/>
        </country>
    </data>


File: python.info,  Node: Building XML documents,  Next: Parsing XML with Namespaces,  Prev: Modifying an XML File,  Up: Tutorial<2>

5.19.7.6 Building XML documents
...............................

The *Note SubElement(): 1ac5. function also provides a convenient way
to create new sub-elements for a given element:

    >>> a = ET.Element('a')
    >>> b = ET.SubElement(a, 'b')
    >>> c = ET.SubElement(a, 'c')
    >>> d = ET.SubElement(c, 'd')
    >>> ET.dump(a)
    <a><b /><c><d /></c></a>


File: python.info,  Node: Parsing XML with Namespaces,  Next: Additional resources,  Prev: Building XML documents,  Up: Tutorial<2>

5.19.7.7 Parsing XML with Namespaces
....................................

If the XML input has namespaces(1), tags and attributes with prefixes
in the form `prefix:sometag' get expanded to `{uri}sometag' where the
`prefix' is replaced by the full `URI'.  Also, if there is a default
namespace(2), that full URI gets prepended to all of the non-prefixed
tags.

Here is an XML example that incorporates two namespaces, one with the
prefix “fictional” and the other serving as the default namespace:

    <?xml version="1.0"?>
    <actors xmlns:fictional="http://characters.example.com"
            xmlns="http://people.example.com">
        <actor>
            <name>John Cleese</name>
            <fictional:character>Lancelot</fictional:character>
            <fictional:character>Archie Leach</fictional:character>
        </actor>
        <actor>
            <name>Eric Idle</name>
            <fictional:character>Sir Robin</fictional:character>
            <fictional:character>Gunther</fictional:character>
            <fictional:character>Commander Clement</fictional:character>
        </actor>
    </actors>

One way to search and explore this XML example is to manually add the
URI to every tag or attribute in the xpath of a *Note find(): 1ace. or
*Note findall(): 1acd.:

    root = fromstring(xml_text)
    for actor in root.findall('{http://people.example.com}actor'):
        name = actor.find('{http://people.example.com}name')
        print name.text
        for char in actor.findall('{http://characters.example.com}character'):
            print ' |-->', char.text

A better way to search the namespaced XML example is to create a
dictionary with your own prefixes and use those in the search functions:

    ns = {'real_person': 'http://people.example.com',
          'role': 'http://characters.example.com'}

    for actor in root.findall('real_person:actor', ns):
        name = actor.find('real_person:name', ns)
        print name.text
        for char in actor.findall('role:character', ns):
            print ' |-->', char.text

These two approaches both output:

    John Cleese
     |--> Lancelot
     |--> Archie Leach
    Eric Idle
     |--> Sir Robin
     |--> Gunther
     |--> Commander Clement

---------- Footnotes ----------

(1) https://en.wikipedia.org/wiki/XML_namespace

(2) https://www.w3.org/TR/2006/REC-xml-names-20060816/#defaulting


File: python.info,  Node: Additional resources,  Prev: Parsing XML with Namespaces,  Up: Tutorial<2>

5.19.7.8 Additional resources
.............................

See <http://effbot.org/zone/element-index.htm> for tutorials and links
to other docs.


File: python.info,  Node: XPath support,  Next: Reference<2>,  Prev: Tutorial<2>,  Up: xml etree ElementTree — The ElementTree XML API

5.19.7.9 XPath support
......................

This module provides limited support for XPath expressions(1) for
locating elements in a tree.  The goal is to support a small subset of
the abbreviated syntax; a full XPath engine is outside the scope of the
module.

* Menu:

* Example: Example<10>.
* Supported XPath syntax::

---------- Footnotes ----------

(1) https://www.w3.org/TR/xpath


File: python.info,  Node: Example<10>,  Next: Supported XPath syntax,  Up: XPath support

5.19.7.10 Example
.................

Here’s an example that demonstrates some of the XPath capabilities of
the module.  We’ll be using the `countrydata' XML document from the
*Note Parsing XML: 1ac9. section:

    import xml.etree.ElementTree as ET

    root = ET.fromstring(countrydata)

    # Top-level elements
    root.findall(".")

    # All 'neighbor' grand-children of 'country' children of the top-level
    # elements
    root.findall("./country/neighbor")

    # Nodes with name='Singapore' that have a 'year' child
    root.findall(".//year/..[@name='Singapore']")

    # 'year' nodes that are children of nodes with name='Singapore'
    root.findall(".//*[@name='Singapore']/year")

    # All 'neighbor' nodes that are the second child of their parent
    root.findall(".//neighbor[2]")


File: python.info,  Node: Supported XPath syntax,  Prev: Example<10>,  Up: XPath support

5.19.7.11 Supported XPath syntax
................................

Syntax                      Meaning
--------------------------------------------------------------------------------------- 
`tag'                       Selects all child elements with the given tag.  For
                            example, `spam' selects all child elements named `spam',
                            and `spam/egg' selects all grandchildren named `egg' in
                            all children named `spam'.
`*'                         Selects all child elements.  For example, `*/egg' selects
                            all grandchildren named `egg'.
`.'                         Selects the current node.  This is mostly useful at the
                            beginning of the path, to indicate that it’s a relative
                            path.
`//'                        Selects all subelements, on all levels beneath the
                            current  element.  For example, `.//egg' selects all
                            `egg' elements in the entire tree.
`..'                        Selects the parent element.
`[@attrib]'                 Selects all elements that have the given attribute.
`[@attrib='value']'         Selects all elements for which the given attribute has
                            the given value.  The value cannot contain quotes.
`[tag]'                     Selects all elements that have a child named `tag'.  Only
                            immediate children are supported.
`[tag='text']'              Selects all elements that have a child named `tag' whose
                            complete text content, including descendants, equals the
                            given `text'.
`[position]'                Selects all elements that are located at the given
                            position.  The position can be either an integer (1 is
                            the first position), the expression `last()' (for the
                            last position), or a position relative to the last
                            position (e.g. `last()-1').

Predicates (expressions within square brackets) must be preceded by a
tag name, an asterisk, or another predicate.  `position' predicates
must be preceded by a tag name.


File: python.info,  Node: Reference<2>,  Prev: XPath support,  Up: xml etree ElementTree — The ElementTree XML API

5.19.7.12 Reference
...................

* Menu:

* Functions: Functions<4>.
* Element Objects::
* ElementTree Objects::
* QName Objects::
* TreeBuilder Objects::
* XMLParser Objects::


File: python.info,  Node: Functions<4>,  Next: Element Objects,  Up: Reference<2>

5.19.7.13 Functions
...................

 -- Function: xml.etree.ElementTree.Comment (text=None)
     Comment element factory.  This factory function creates a special
     element that will be serialized as an XML comment by the standard
     serializer.  The comment string can be either a bytestring or a
     Unicode string.  `text' is a string containing the comment string.
     Returns an element instance representing a comment.

 -- Function: xml.etree.ElementTree.dump (elem)
     Writes an element tree or element structure to sys.stdout.  This
     function should be used for debugging only.

     The exact output format is implementation dependent.  In this
     version, it’s written as an ordinary XML file.

     `elem' is an element tree or an individual element.

 -- Function: xml.etree.ElementTree.fromstring (text)
     Parses an XML section from a string constant.  Same as *Note
     XML(): 1ae1.  `text' is a string containing XML data.  Returns an
     *Note Element: 2b3. instance.

 -- Function: xml.etree.ElementTree.fromstringlist (sequence,
          parser=None)
     Parses an XML document from a sequence of string fragments.
     `sequence' is a list or other sequence containing XML data
     fragments.  `parser' is an optional parser instance.  If not
     given, the standard *Note XMLParser: 2b0.  parser is used.
     Returns an *Note Element: 2b3. instance.

     New in version 2.7.


 -- Function: xml.etree.ElementTree.iselement (element)
     Checks if an object appears to be a valid element object.
     `element' is an element instance.  Returns a true value if this is
     an element object.

 -- Function: xml.etree.ElementTree.iterparse (source, events=None,
          parser=None)
     Parses an XML section into an element tree incrementally, and
     reports what’s going on to the user.  `source' is a filename or
     file object containing XML data.  `events' is a list of events to
     report back.  If omitted, only “end” events are reported.
     `parser' is an optional parser instance.  If not given, the
     standard *Note XMLParser: 2b0. parser is used.  `parser' is not
     supported by `cElementTree'. Returns an *Note iterator: 8a8.
     providing `(event, elem)' pairs.

          Note: *Note iterparse(): 1ae4. only guarantees that it has
          seen the “>” character of a starting tag when it emits a
          “start” event, so the attributes are defined, but the
          contents of the text and tail attributes are undefined at
          that point.  The same applies to the element children; they
          may or may not be present.

          If you need a fully populated element, look for “end”
          events instead.

 -- Function: xml.etree.ElementTree.parse (source, parser=None)
     Parses an XML section into an element tree.  `source' is a
     filename or file object containing XML data.  `parser' is an
     optional parser instance.  If not given, the standard *Note
     XMLParser: 2b0. parser is used.  Returns an *Note ElementTree:
     1ac6. instance.

 -- Function: xml.etree.ElementTree.ProcessingInstruction (target,
          text=None)
     PI element factory.  This factory function creates a special
     element that will be serialized as an XML processing instruction.
     `target' is a string containing the PI target.  `text' is a string
     containing the PI contents, if given.  Returns an element
     instance, representing a processing instruction.

 -- Function: xml.etree.ElementTree.register_namespace (prefix, uri)
     Registers a namespace prefix.  The registry is global, and any
     existing mapping for either the given prefix or the namespace URI
     will be removed.  `prefix' is a namespace prefix.  `uri' is a
     namespace uri.  Tags and attributes in this namespace will be
     serialized with the given prefix, if at all possible.

     New in version 2.7.


 -- Function: xml.etree.ElementTree.SubElement (parent, tag, attrib={},
          **extra)
     Subelement factory.  This function creates an element instance,
     and appends it to an existing element.

     The element name, attribute names, and attribute values can be
     either bytestrings or Unicode strings.  `parent' is the parent
     element.  `tag' is the subelement name.  `attrib' is an optional
     dictionary, containing element attributes.  `extra' contains
     additional attributes, given as keyword arguments.  Returns an
     element instance.

 -- Function: xml.etree.ElementTree.tostring (element,
          encoding="us-ascii", method="xml")
     Generates a string representation of an XML element, including all
     subelements.  `element' is an *Note Element: 2b3. instance.
     `encoding' (1) is the output encoding (default is US-ASCII).
     `method' is either `"xml"', `"html"' or `"text"' (default is
     `"xml"').  Returns an encoded string containing the XML data.

 -- Function: xml.etree.ElementTree.tostringlist (element,
          encoding="us-ascii", method="xml")
     Generates a string representation of an XML element, including all
     subelements.  `element' is an *Note Element: 2b3. instance.
     `encoding' (2) is the output encoding (default is US-ASCII).
     `method' is either `"xml"', `"html"' or `"text"' (default is
     `"xml"').  Returns a list of encoded strings containing the XML
     data.  It does not guarantee any specific sequence, except that
     `"".join(tostringlist(element)) == tostring(element)'.

     New in version 2.7.


 -- Function: xml.etree.ElementTree.XML (text, parser=None)
     Parses an XML section from a string constant.  This function can
     be used to embed “XML literals” in Python code.  `text' is a
     string containing XML data.  `parser' is an optional parser
     instance.  If not given, the standard *Note XMLParser: 2b0. parser
     is used.  Returns an *Note Element: 2b3. instance.

 -- Function: xml.etree.ElementTree.XMLID (text, parser=None)
     Parses an XML section from a string constant, and also returns a
     dictionary which maps from element id:s to elements.  `text' is a
     string containing XML data.  `parser' is an optional parser
     instance.  If not given, the standard *Note XMLParser: 2b0. parser
     is used.  Returns a tuple containing an *Note Element: 2b3.
     instance and a dictionary.

---------- Footnotes ----------

(1) The encoding string included in XML output should conform to the
appropriate standards.  For example, “UTF-8” is valid, but
“UTF8” is not.  See
<https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl> and
<https://www.iana.org/assignments/character-sets/character-sets.xhtml>.

(2) The encoding string included in XML output should conform to the
appropriate standards.  For example, “UTF-8” is valid, but
“UTF8” is not.  See
<https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl> and
<https://www.iana.org/assignments/character-sets/character-sets.xhtml>.


File: python.info,  Node: Element Objects,  Next: ElementTree Objects,  Prev: Functions<4>,  Up: Reference<2>

5.19.7.14 Element Objects
.........................

 -- Class: xml.etree.ElementTree.Element (tag, attrib={}, **extra)
     Element class.  This class defines the Element interface, and
     provides a reference implementation of this interface.

     The element name, attribute names, and attribute values can be
     either bytestrings or Unicode strings.  `tag' is the element name.
     `attrib' is an optional dictionary, containing element
     attributes.  `extra' contains additional attributes, given as
     keyword arguments.

      -- Attribute: tag
          A string identifying what kind of data this element
          represents (the element type, in other words).

      -- Attribute: text
      -- Attribute: tail
          These attributes can be used to hold additional data
          associated with the element.  Their values are usually
          strings but may be any application-specific object.  If the
          element is created from an XML file, the `text' attribute
          holds either the text between the element’s start tag and
          its first child or end tag, or `None', and the `tail'
          attribute holds either the text between the element’s end
          tag and the next tag, or `None'.  For the XML data

              <a><b>1<c>2<d/>3</c></b>4</a>

          the `a' element has `None' for both `text' and `tail'
          attributes, the `b' element has `text' `"1"' and `tail' `"4"',
          the `c' element has `text' `"2"' and `tail' `None', and the
          `d' element has `text' `None' and `tail' `"3"'.

          To collect the inner text of an element, see *Note
          itertext(): 2b6, for example `"".join(element.itertext())'.

          Applications may store arbitrary objects in these attributes.

      -- Attribute: attrib
          A dictionary containing the element’s attributes.  Note
          that while the `attrib' value is always a real mutable Python
          dictionary, an ElementTree implementation may choose to use
          another internal representation, and create the dictionary
          only if someone asks for it.  To take advantage of such
          implementations, use the dictionary methods below whenever
          possible.

     The following dictionary-like methods work on the element
     attributes.

      -- Method: clear ()
          Resets an element.  This function removes all subelements,
          clears all attributes, and sets the text and tail attributes
          to `None'.

      -- Method: get (key, default=None)
          Gets the element attribute named `key'.

          Returns the attribute value, or `default' if the attribute
          was not found.

      -- Method: items ()
          Returns the element attributes as a sequence of (name, value)
          pairs.  The attributes are returned in an arbitrary order.

      -- Method: keys ()
          Returns the elements attribute names as a list.  The names
          are returned in an arbitrary order.

      -- Method: set (key, value)
          Set the attribute `key' on the element to `value'.

     The following methods work on the element’s children
     (subelements).

      -- Method: append (subelement)
          Adds the element `subelement' to the end of this elements
          internal list of subelements.

      -- Method: extend (subelements)
          Appends `subelements' from a sequence object with zero or
          more elements.  Raises *Note AssertionError: 834. if a
          subelement is not a valid object.

          New in version 2.7.


      -- Method: find (match)
          Finds the first subelement matching `match'.  `match' may be
          a tag name or path.  Returns an element instance or `None'.

      -- Method: findall (match)
          Finds all matching subelements, by tag name or path.  Returns
          a list containing all matching elements in document order.

      -- Method: findtext (match, default=None)
          Finds text for the first subelement matching `match'.
          `match' may be a tag name or path.  Returns the text content
          of the first matching element, or `default' if no element was
          found.  Note that if the matching element has no text content
          an empty string is returned.

      -- Method: getchildren ()
          Deprecated since version 2.7: Use `list(elem)' or iteration.


      -- Method: getiterator (tag=None)
          Deprecated since version 2.7: Use method *Note
          Element.iter(): 2b5. instead.


      -- Method: insert (index, element)
          Inserts a subelement at the given position in this element.

      -- Method: iter (tag=None)
          Creates a tree *Note iterator: 8a8. with the current element
          as the root.  The iterator iterates over this element and all
          elements below it, in document (depth first) order.  If `tag'
          is not `None' or `'*'', only elements whose tag equals `tag'
          are returned from the iterator.  If the tree structure is
          modified during iteration, the result is undefined.

          New in version 2.7.


      -- Method: iterfind (match)
          Finds all matching subelements, by tag name or path.  Returns
          an iterable yielding all matching elements in document order.

          New in version 2.7.


      -- Method: itertext ()
          Creates a text iterator.  The iterator loops over this
          element and all subelements, in document order, and returns
          all inner text.

          New in version 2.7.


      -- Method: makeelement (tag, attrib)
          Creates a new element object of the same type as this
          element.  Do not call this method, use the *Note
          SubElement(): 1ac5. factory function instead.

      -- Method: remove (subelement)
          Removes `subelement' from the element.  Unlike the find*
          methods this method compares elements based on the instance
          identity, not on tag value or contents.

     *Note Element: 2b3. objects also support the following sequence
     type methods for working with subelements: *Note __delitem__():
     482, *Note __getitem__(): 468, *Note __setitem__(): 481, *Note
     __len__(): 423.

     Caution: Elements with no subelements will test as `False'.  This
     behavior will change in future versions.  Use specific `len(elem)'
     or `elem is None' test instead.

         element = root.find('foo')

         if not element:  # careful!
             print "element not found, or element has no subelements"

         if element is None:
             print "element not found"


File: python.info,  Node: ElementTree Objects,  Next: QName Objects,  Prev: Element Objects,  Up: Reference<2>

5.19.7.15 ElementTree Objects
.............................

 -- Class: xml.etree.ElementTree.ElementTree (element=None, file=None)
     ElementTree wrapper class.  This class represents an entire element
     hierarchy, and adds some extra support for serialization to and
     from standard XML.

     `element' is the root element.  The tree is initialized with the
     contents of the XML `file' if given.

      -- Method: _setroot (element)
          Replaces the root element for this tree.  This discards the
          current contents of the tree, and replaces it with the given
          element.  Use with care.  `element' is an element instance.

      -- Method: find (match)
          Same as *Note Element.find(): 1ace, starting at the root of
          the tree.

      -- Method: findall (match)
          Same as *Note Element.findall(): 1acd, starting at the root
          of the tree.

      -- Method: findtext (match, default=None)
          Same as *Note Element.findtext(): 1af2, starting at the root
          of the tree.

      -- Method: getiterator (tag=None)
          Deprecated since version 2.7: Use method *Note
          ElementTree.iter(): 1aff. instead.


      -- Method: getroot ()
          Returns the root element for this tree.

      -- Method: iter (tag=None)
          Creates and returns a tree iterator for the root element.
          The iterator loops over all elements in this tree, in section
          order.  `tag' is the tag to look for (default is to return
          all elements).

      -- Method: iterfind (match)
          Finds all matching subelements, by tag name or path.  Same as
          getroot().iterfind(match). Returns an iterable yielding all
          matching elements in document order.

          New in version 2.7.


      -- Method: parse (source, parser=None)
          Loads an external XML section into this element tree.
          `source' is a file name or file object.  `parser' is an
          optional parser instance.  If not given, the standard
          XMLParser parser is used.  Returns the section root element.

      -- Method: write (file, encoding="us-ascii",
               xml_declaration=None, default_namespace=None,
               method="xml")
          Writes the element tree to a file, as XML.  `file' is a file
          name, or a file object opened for writing.  `encoding' (1) is
          the output encoding (default is US-ASCII).  `xml_declaration'
          controls if an XML declaration should be added to the file.
          Use `False' for never, `True' for always, `None' for only if
          not US-ASCII or UTF-8 (default is `None').
          `default_namespace' sets the default XML namespace (for
          “xmlns”).  `method' is either `"xml"', `"html"' or
          `"text"' (default is `"xml"').  Returns an encoded string.

This is the XML file that is going to be manipulated:

    <html>
        <head>
            <title>Example page</title>
        </head>
        <body>
            <p>Moved to <a href="http://example.org/">example.org</a>
            or <a href="http://example.com/">example.com</a>.</p>
        </body>
    </html>

Example of changing the attribute “target” of every link in first
paragraph:

    >>> from xml.etree.ElementTree import ElementTree
    >>> tree = ElementTree()
    >>> tree.parse("index.xhtml")
    <Element 'html' at 0xb77e6fac>
    >>> p = tree.find("body/p")     # Finds first occurrence of tag p in body
    >>> p
    <Element 'p' at 0xb77ec26c>
    >>> links = list(p.iter("a"))   # Returns list of all links
    >>> links
    [<Element 'a' at 0xb77ec2ac>, <Element 'a' at 0xb77ec1cc>]
    >>> for i in links:             # Iterates through all found links
    ...     i.attrib["target"] = "blank"
    ...
    >>> tree.write("output.xhtml")

---------- Footnotes ----------

(1) The encoding string included in XML output should conform to the
appropriate standards.  For example, “UTF-8” is valid, but
“UTF8” is not.  See
<https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl> and
<https://www.iana.org/assignments/character-sets/character-sets.xhtml>.


File: python.info,  Node: QName Objects,  Next: TreeBuilder Objects,  Prev: ElementTree Objects,  Up: Reference<2>

5.19.7.16 QName Objects
.......................

 -- Class: xml.etree.ElementTree.QName (text_or_uri, tag=None)
     QName wrapper.  This can be used to wrap a QName attribute value,
     in order to get proper namespace handling on output.
     `text_or_uri' is a string containing the QName value, in the form
     {uri}local, or, if the tag argument is given, the URI part of a
     QName.  If `tag' is given, the first argument is interpreted as a
     URI, and this argument is interpreted as a local name.  *Note
     QName: 1b05. instances are opaque.


File: python.info,  Node: TreeBuilder Objects,  Next: XMLParser Objects,  Prev: QName Objects,  Up: Reference<2>

5.19.7.17 TreeBuilder Objects
.............................

 -- Class: xml.etree.ElementTree.TreeBuilder (element_factory=None)
     Generic element structure builder.  This builder converts a
     sequence of start, data, and end method calls to a well-formed
     element structure.  You can use this class to build an element
     structure using a custom XML parser, or a parser for some other
     XML-like format.  The `element_factory' is called to create new
     *Note Element: 2b3. instances when given.

      -- Method: close ()
          Flushes the builder buffers, and returns the toplevel document
          element.  Returns an *Note Element: 2b3. instance.

      -- Method: data (data)
          Adds text to the current element.  `data' is a string.  This
          should be either a bytestring, or a Unicode string.

      -- Method: end (tag)
          Closes the current element.  `tag' is the element name.
          Returns the closed element.

      -- Method: start (tag, attrs)
          Opens a new element.  `tag' is the element name.  `attrs' is
          a dictionary containing element attributes.  Returns the
          opened element.

     In addition, a custom *Note TreeBuilder: 1b08. object can provide
     the following method:

      -- Method: doctype (name, pubid, system)
          Handles a doctype declaration.  `name' is the doctype name.
          `pubid' is the public identifier.  `system' is the system
          identifier.  This method does not exist on the default *Note
          TreeBuilder: 1b08. class.

          New in version 2.7.



File: python.info,  Node: XMLParser Objects,  Prev: TreeBuilder Objects,  Up: Reference<2>

5.19.7.18 XMLParser Objects
...........................

 -- Class: xml.etree.ElementTree.XMLParser (html=0, target=None,
          encoding=None)
     *Note Element: 2b3. structure builder for XML source data, based
     on the expat parser.  `html' are predefined HTML entities.  This
     flag is not supported by the current implementation.  `target' is
     the target object.  If omitted, the builder uses an instance of
     the standard TreeBuilder class.  `encoding' (1) is optional.  If
     given, the value overrides the encoding specified in the XML file.

      -- Method: close ()
          Finishes feeding data to the parser.  Returns an element
          structure.

      -- Method: doctype (name, pubid, system)
          Deprecated since version 2.7: Define the *Note
          TreeBuilder.doctype(): 1b0d. method on a custom TreeBuilder
          target.


      -- Method: feed (data)
          Feeds data to the parser.  `data' is encoded data.

*Note XMLParser.feed(): 1b12. calls `target'’s `start()' method for
each opening tag, its `end()' method for each closing tag, and data is
processed by method `data()'.  *Note XMLParser.close(): 1b10.  calls
`target'’s method `close()'.  *Note XMLParser: 2b0. can be used not
only for building a tree structure.  This is an example of counting the
maximum depth of an XML file:

    >>> from xml.etree.ElementTree import XMLParser
    >>> class MaxDepth:                     # The target object of the parser
    ...     maxDepth = 0
    ...     depth = 0
    ...     def start(self, tag, attrib):   # Called for each opening tag.
    ...         self.depth += 1
    ...         if self.depth > self.maxDepth:
    ...             self.maxDepth = self.depth
    ...     def end(self, tag):             # Called for each closing tag.
    ...         self.depth -= 1
    ...     def data(self, data):
    ...         pass            # We do not need to do anything with data.
    ...     def close(self):    # Called when all data has been parsed.
    ...         return self.maxDepth
    ...
    >>> target = MaxDepth()
    >>> parser = XMLParser(target=target)
    >>> exampleXml = """
    ... <a>
    ...   <b>
    ...   </b>
    ...   <b>
    ...     <c>
    ...       <d>
    ...       </d>
    ...     </c>
    ...   </b>
    ... </a>"""
    >>> parser.feed(exampleXml)
    >>> parser.close()
    4

---------- Footnotes ----------

(1) The encoding string included in XML output should conform to the
appropriate standards.  For example, “UTF-8” is valid, but
“UTF8” is not.  See
<https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl> and
<https://www.iana.org/assignments/character-sets/character-sets.xhtml>.


File: python.info,  Node: xml dom — The Document Object Model API,  Next: xml dom minidom — Minimal DOM implementation,  Prev: xml etree ElementTree — The ElementTree XML API,  Up: Structured Markup Processing Tools

5.19.8 `xml.dom' — The Document Object Model API
--------------------------------------------------

New in version 2.0.

The Document Object Model, or “DOM,” is a cross-language API from
the World Wide Web Consortium (W3C) for accessing and modifying XML
documents.  A DOM implementation presents an XML document as a tree
structure, or allows client code to build such a structure from
scratch.  It then gives access to the structure through a set of
objects which provided well-known interfaces.

The DOM is extremely useful for random-access applications.  SAX only
allows you a view of one bit of the document at a time.  If you are
looking at one SAX element, you have no access to another.  If you are
looking at a text node, you have no access to a containing element.
When you write a SAX application, you need to keep track of your
program’s position in the document somewhere in your own code.  SAX
does not do it for you.  Also, if you need to look ahead in the XML
document, you are just out of luck.

Some applications are simply impossible in an event driven model with
no access to a tree.  Of course you could build some sort of tree
yourself in SAX events, but the DOM allows you to avoid writing that
code.  The DOM is a standard tree representation for XML data.

The Document Object Model is being defined by the W3C in stages, or
“levels” in their terminology.  The Python mapping of the API is
substantially based on the DOM Level 2 recommendation.

DOM applications typically start by parsing some XML into a DOM.  How
this is accomplished is not covered at all by DOM Level 1, and Level 2
provides only limited improvements: There is a `DOMImplementation'
object class which provides access to `Document' creation methods, but
no way to access an XML reader/parser/Document builder in an
implementation-independent way. There is also no well-defined way to
access these methods without an existing `Document' object.  In Python,
each DOM implementation will provide a function *Note
getDOMImplementation(): 1b15. DOM Level 3 adds a Load/Store
specification, which defines an interface to the reader, but this is
not yet available in the Python standard library.

Once you have a DOM document object, you can access the parts of your
XML document through its properties and methods.  These properties are
defined in the DOM specification; this portion of the reference manual
describes the interpretation of the specification in Python.

The specification provided by the W3C defines the DOM API for Java,
ECMAScript, and OMG IDL.  The Python mapping defined here is based in
large part on the IDL version of the specification, but strict
compliance is not required (though implementations are free to support
the strict mapping from IDL).  See section *Note Conformance: 1b16. for
a detailed discussion of mapping requirements.

See also
........

Document Object Model (DOM) Level 2 Specification(1)
     The W3C recommendation upon which the Python DOM API is based.

Document Object Model (DOM) Level 1 Specification(2)
     The W3C recommendation for the DOM supported by *Note
     xml.dom.minidom: 1a2.

Python Language Mapping Specification(3)
     This specifies the mapping from OMG IDL to Python.

* Menu:

* Module Contents: Module Contents<3>.
* Objects in the DOM::
* Conformance::

---------- Footnotes ----------

(1) https://www.w3.org/TR/DOM-Level-2-Core/

(2) https://www.w3.org/TR/REC-DOM-Level-1/

(3) http://www.omg.org/spec/PYTH/1.2/PDF


File: python.info,  Node: Module Contents<3>,  Next: Objects in the DOM,  Up: xml dom — The Document Object Model API

5.19.8.1 Module Contents
........................

The *Note xml.dom: 1a1. contains the following functions:

 -- Function: xml.dom.registerDOMImplementation (name, factory)
     Register the `factory' function with the name `name'.  The factory
     function should return an object which implements the
     `DOMImplementation' interface.  The factory function can return
     the same object every time, or a new one for each call, as
     appropriate for the specific implementation (e.g. if that
     implementation supports some customization).

 -- Function: xml.dom.getDOMImplementation ([name[, features]])
     Return a suitable DOM implementation. The `name' is either
     well-known, the module name of a DOM implementation, or `None'. If
     it is not `None', imports the corresponding module and returns a
     `DOMImplementation' object if the import succeeds.  If no name is
     given, and if the environment variable `PYTHON_DOM' is set, this
     variable is used to find the implementation.

     If name is not given, this examines the available implementations
     to find one with the required feature set.  If no implementation
     can be found, raise an *Note ImportError: 388.  The features list
     must be a sequence of `(feature, version)' pairs which are passed
     to the `hasFeature()' method on available `DOMImplementation'
     objects.

Some convenience constants are also provided:

 -- Data: xml.dom.EMPTY_NAMESPACE
     The value used to indicate that no namespace is associated with a
     node in the DOM.  This is typically found as the `namespaceURI' of
     a node, or used as the `namespaceURI' parameter to a
     namespaces-specific method.

     New in version 2.2.


 -- Data: xml.dom.XML_NAMESPACE
     The namespace URI associated with the reserved prefix `xml', as
     defined by Namespaces in XML(1) (section 4).

     New in version 2.2.


 -- Data: xml.dom.XMLNS_NAMESPACE
     The namespace URI for namespace declarations, as defined by
     Document Object Model (DOM) Level 2 Core Specification(2) (section
     1.1.8).

     New in version 2.2.


 -- Data: xml.dom.XHTML_NAMESPACE
     The URI of the XHTML namespace as defined by XHTML 1.0: The
     Extensible HyperText Markup Language(3) (section 3.1.1).

     New in version 2.2.


In addition, *Note xml.dom: 1a1. contains a base `Node' class and the
DOM exception classes.  The `Node' class provided by this module does
not implement any of the methods or attributes defined by the DOM
specification; concrete DOM implementations must provide those.  The
`Node' class provided as part of this module does provide the constants
used for the `nodeType' attribute on concrete `Node' objects; they are
located within the class rather than at the module level to conform
with the DOM specifications.

---------- Footnotes ----------

(1) https://www.w3.org/TR/REC-xml-names/

(2) https://www.w3.org/TR/DOM-Level-2-Core/core.html

(3) https://www.w3.org/TR/xhtml1/


File: python.info,  Node: Objects in the DOM,  Next: Conformance,  Prev: Module Contents<3>,  Up: xml dom — The Document Object Model API

5.19.8.2 Objects in the DOM
...........................

The definitive documentation for the DOM is the DOM specification from
the W3C.

Note that DOM attributes may also be manipulated as nodes instead of as
simple strings.  It is fairly rare that you must do this, however, so
this usage is not yet documented.

Interface                            Section                                 Purpose
------------------------------------------------------------------------------------------------------------------- 
`DOMImplementation'                  *Note DOMImplementation Objects: 1b1f.  Interface to the underlying
                                                                             implementation.
`Node'                               *Note Node Objects: 1b20.               Base interface for most objects in a
                                                                             document.
`NodeList'                           *Note NodeList Objects: 1b21.           Interface for a sequence of nodes.
`DocumentType'                       *Note DocumentType Objects: 1b22.       Information about the declarations
                                                                             needed to process a document.
`Document'                           *Note Document Objects: 1b23.           Object which represents an entire
                                                                             document.
`Element'                            *Note Element Objects: 1b24.            Element nodes in the document
                                                                             hierarchy.
`Attr'                               *Note Attr Objects: 1b25.               Attribute value nodes on element
                                                                             nodes.
`Comment'                            *Note Comment Objects: 1b26.            Representation of comments in the
                                                                             source document.
`Text'                               *Note Text and CDATASection Objects:    Nodes containing textual content
                                     1b27.                                   from the document.
`ProcessingInstruction'              *Note ProcessingInstruction Objects:    Processing instruction
                                     1b28.                                   representation.

An additional section describes the exceptions defined for working with
the DOM in Python.

* Menu:

* DOMImplementation Objects::
* Node Objects::
* NodeList Objects::
* DocumentType Objects::
* Document Objects::
* Element Objects: Element Objects<2>.
* Attr Objects::
* NamedNodeMap Objects::
* Comment Objects::
* Text and CDATASection Objects::
* ProcessingInstruction Objects::
* Exceptions: Exceptions<6>.


File: python.info,  Node: DOMImplementation Objects,  Next: Node Objects,  Up: Objects in the DOM

5.19.8.3 DOMImplementation Objects
..................................

The `DOMImplementation' interface provides a way for applications to
determine the availability of particular features in the DOM they are
using.  DOM Level 2 added the ability to create new `Document' and
`DocumentType' objects using the `DOMImplementation' as well.

 -- Method: DOMImplementation.hasFeature (feature, version)
     Return true if the feature identified by the pair of strings
     `feature' and `version' is implemented.

 -- Method: DOMImplementation.createDocument (namespaceUri,
          qualifiedName, doctype)
     Return a new `Document' object (the root of the DOM), with a child
     `Element' object having the given `namespaceUri' and
     `qualifiedName'. The `doctype' must be a `DocumentType' object
     created by *Note createDocumentType(): 1b2c, or `None'. In the
     Python DOM API, the first two arguments can also be `None' in
     order to indicate that no `Element' child is to be created.

 -- Method: DOMImplementation.createDocumentType (qualifiedName,
          publicId, systemId)
     Return a new `DocumentType' object that encapsulates the given
     `qualifiedName', `publicId', and `systemId' strings, representing
     the information contained in an XML document type declaration.


File: python.info,  Node: Node Objects,  Next: NodeList Objects,  Prev: DOMImplementation Objects,  Up: Objects in the DOM

5.19.8.4 Node Objects
.....................

All of the components of an XML document are subclasses of `Node'.

 -- Attribute: Node.nodeType
     An integer representing the node type.  Symbolic constants for the
     types are on the `Node' object: `ELEMENT_NODE', `ATTRIBUTE_NODE',
     `TEXT_NODE', `CDATA_SECTION_NODE', `ENTITY_NODE',
     `PROCESSING_INSTRUCTION_NODE', `COMMENT_NODE', `DOCUMENT_NODE',
     `DOCUMENT_TYPE_NODE', `NOTATION_NODE'.  This is a read-only
     attribute.

 -- Attribute: Node.parentNode
     The parent of the current node, or `None' for the document node.
     The value is always a `Node' object or `None'.  For `Element'
     nodes, this will be the parent element, except for the root
     element, in which case it will be the `Document' object. For
     `Attr' nodes, this is always `None'. This is a read-only attribute.

 -- Attribute: Node.attributes
     A `NamedNodeMap' of attribute objects.  Only elements have actual
     values for this; others provide `None' for this attribute. This is
     a read-only attribute.

 -- Attribute: Node.previousSibling
     The node that immediately precedes this one with the same parent.
     For instance the element with an end-tag that comes just before
     the `self' element’s start-tag.  Of course, XML documents are
     made up of more than just elements so the previous sibling could
     be text, a comment, or something else.  If this node is the first
     child of the parent, this attribute will be `None'. This is a
     read-only attribute.

 -- Attribute: Node.nextSibling
     The node that immediately follows this one with the same parent.
     See also *Note previousSibling: 1b31.  If this is the last child
     of the parent, this attribute will be `None'. This is a read-only
     attribute.

 -- Attribute: Node.childNodes
     A list of nodes contained within this node. This is a read-only
     attribute.

 -- Attribute: Node.firstChild
     The first child of the node, if there are any, or `None'. This is
     a read-only attribute.

 -- Attribute: Node.lastChild
     The last child of the node, if there are any, or `None'. This is a
     read-only attribute.

 -- Attribute: Node.localName
     The part of the `tagName' following the colon if there is one,
     else the entire `tagName'.  The value is a string.

 -- Attribute: Node.prefix
     The part of the `tagName' preceding the colon if there is one,
     else the empty string.  The value is a string, or `None'.

 -- Attribute: Node.namespaceURI
     The namespace associated with the element name.  This will be a
     string or `None'.  This is a read-only attribute.

 -- Attribute: Node.nodeName
     This has a different meaning for each node type; see the DOM
     specification for details.  You can always get the information you
     would get here from another property such as the `tagName'
     property for elements or the `name' property for attributes. For
     all node types, the value of this attribute will be either a
     string or `None'.  This is a read-only attribute.

 -- Attribute: Node.nodeValue
     This has a different meaning for each node type; see the DOM
     specification for details.  The situation is similar to that with
     *Note nodeName: 1b39.  The value is a string or `None'.

 -- Method: Node.hasAttributes ()
     Returns true if the node has any attributes.

 -- Method: Node.hasChildNodes ()
     Returns true if the node has any child nodes.

 -- Method: Node.isSameNode (other)
     Returns true if `other' refers to the same node as this node. This
     is especially useful for DOM implementations which use any sort of
     proxy architecture (because more than one object can refer to the
     same node).

          Note: This is based on a proposed DOM Level 3 API which is
          still in the “working draft” stage, but this particular
          interface appears uncontroversial.  Changes from the W3C will
          not necessarily affect this method in the Python DOM interface
          (though any new W3C API for this would also be supported).

 -- Method: Node.appendChild (newChild)
     Add a new child node to this node at the end of the list of
     children, returning `newChild'. If the node was already in the
     tree, it is removed first.

 -- Method: Node.insertBefore (newChild, refChild)
     Insert a new child node before an existing child.  It must be the
     case that `refChild' is a child of this node; if not, *Note
     ValueError: 236. is raised.  `newChild' is returned. If `refChild'
     is `None', it inserts `newChild' at the end of the children’s
     list.

 -- Method: Node.removeChild (oldChild)
     Remove a child node.  `oldChild' must be a child of this node; if
     not, *Note ValueError: 236. is raised.  `oldChild' is returned on
     success.  If `oldChild' will not be used further, its `unlink()'
     method should be called.

 -- Method: Node.replaceChild (newChild, oldChild)
     Replace an existing node with a new node. It must be the case that
     `oldChild' is a child of this node; if not, *Note ValueError:
     236. is raised.

 -- Method: Node.normalize ()
     Join adjacent text nodes so that all stretches of text are stored
     as single `Text' instances.  This simplifies processing text from
     a DOM tree for many applications.

     New in version 2.1.


 -- Method: Node.cloneNode (deep)
     Clone this node.  Setting `deep' means to clone all child nodes as
     well.  This returns the clone.


File: python.info,  Node: NodeList Objects,  Next: DocumentType Objects,  Prev: Node Objects,  Up: Objects in the DOM

5.19.8.5 NodeList Objects
.........................

A `NodeList' represents a sequence of nodes.  These objects are used in
two ways in the DOM Core recommendation:  an `Element' object provides
one as its list of child nodes, and the `getElementsByTagName()' and
`getElementsByTagNameNS()' methods of `Node' return objects with this
interface to represent query results.

The DOM Level 2 recommendation defines one method and one attribute for
these objects:

 -- Method: NodeList.item (i)
     Return the `i'’th item from the sequence, if there is one, or
     `None'.  The index `i' is not allowed to be less than zero or
     greater than or equal to the length of the sequence.

 -- Attribute: NodeList.length
     The number of nodes in the sequence.

In addition, the Python DOM interface requires that some additional
support is provided to allow `NodeList' objects to be used as Python
sequences.  All `NodeList' implementations must include support for
*Note __len__(): 423. and *Note __getitem__(): 468.; this allows
iteration over the `NodeList' in *Note for: 303. statements and proper
support for the *Note len(): 53c. built-in function.

If a DOM implementation supports modification of the document, the
`NodeList' implementation must also support the *Note __setitem__():
481. and *Note __delitem__(): 482. methods.


File: python.info,  Node: DocumentType Objects,  Next: Document Objects,  Prev: NodeList Objects,  Up: Objects in the DOM

5.19.8.6 DocumentType Objects
.............................

Information about the notations and entities declared by a document
(including the external subset if the parser uses it and can provide
the information) is available from a `DocumentType' object.  The
`DocumentType' for a document is available from the `Document'
object’s `doctype' attribute; if there is no `DOCTYPE' declaration
for the document, the document’s `doctype' attribute will be set to
`None' instead of an instance of this interface.

`DocumentType' is a specialization of `Node', and adds the following
attributes:

 -- Attribute: DocumentType.publicId
     The public identifier for the external subset of the document type
     definition.  This will be a string or `None'.

 -- Attribute: DocumentType.systemId
     The system identifier for the external subset of the document type
     definition.  This will be a URI as a string, or `None'.

 -- Attribute: DocumentType.internalSubset
     A string giving the complete internal subset from the document.
     This does not include the brackets which enclose the subset.  If
     the document has no internal subset, this should be `None'.

 -- Attribute: DocumentType.name
     The name of the root element as given in the `DOCTYPE'
     declaration, if present.

 -- Attribute: DocumentType.entities
     This is a `NamedNodeMap' giving the definitions of external
     entities.  For entity names defined more than once, only the first
     definition is provided (others are ignored as required by the XML
     recommendation).  This may be `None' if the information is not
     provided by the parser, or if no entities are defined.

 -- Attribute: DocumentType.notations
     This is a `NamedNodeMap' giving the definitions of notations. For
     notation names defined more than once, only the first definition
     is provided (others are ignored as required by the XML
     recommendation).  This may be `None' if the information is not
     provided by the parser, or if no notations are defined.


File: python.info,  Node: Document Objects,  Next: Element Objects<2>,  Prev: DocumentType Objects,  Up: Objects in the DOM

5.19.8.7 Document Objects
.........................

A `Document' represents an entire XML document, including its
constituent elements, attributes, processing instructions, comments
etc.  Remember that it inherits properties from `Node'.

 -- Attribute: Document.documentElement
     The one and only root element of the document.

 -- Method: Document.createElement (tagName)
     Create and return a new element node.  The element is not inserted
     into the document when it is created.  You need to explicitly
     insert it with one of the other methods such as `insertBefore()'
     or `appendChild()'.

 -- Method: Document.createElementNS (namespaceURI, tagName)
     Create and return a new element with a namespace.  The `tagName'
     may have a prefix.  The element is not inserted into the document
     when it is created.  You need to explicitly insert it with one of
     the other methods such as `insertBefore()' or `appendChild()'.

 -- Method: Document.createTextNode (data)
     Create and return a text node containing the data passed as a
     parameter.  As with the other creation methods, this one does not
     insert the node into the tree.

 -- Method: Document.createComment (data)
     Create and return a comment node containing the data passed as a
     parameter.  As with the other creation methods, this one does not
     insert the node into the tree.

 -- Method: Document.createProcessingInstruction (target, data)
     Create and return a processing instruction node containing the
     `target' and `data' passed as parameters.  As with the other
     creation methods, this one does not insert the node into the tree.

 -- Method: Document.createAttribute (name)
     Create and return an attribute node.  This method does not
     associate the attribute node with any particular element.  You
     must use `setAttributeNode()' on the appropriate `Element' object
     to use the newly created attribute instance.

 -- Method: Document.createAttributeNS (namespaceURI, qualifiedName)
     Create and return an attribute node with a namespace.  The
     `tagName' may have a prefix.  This method does not associate the
     attribute node with any particular element.  You must use
     `setAttributeNode()' on the appropriate `Element' object to use
     the newly created attribute instance.

 -- Method: Document.getElementsByTagName (tagName)
     Search for all descendants (direct children, children’s
     children, etc.) with a particular element type name.

 -- Method: Document.getElementsByTagNameNS (namespaceURI, localName)
     Search for all descendants (direct children, children’s
     children, etc.) with a particular namespace URI and localname.
     The localname is the part of the namespace after the prefix.


File: python.info,  Node: Element Objects<2>,  Next: Attr Objects,  Prev: Document Objects,  Up: Objects in the DOM

5.19.8.8 Element Objects
........................

`Element' is a subclass of `Node', so inherits all the attributes of
that class.

 -- Attribute: Element.tagName
     The element type name.  In a namespace-using document it may have
     colons in it.  The value is a string.

 -- Method: Element.getElementsByTagName (tagName)
     Same as equivalent method in the `Document' class.

 -- Method: Element.getElementsByTagNameNS (namespaceURI, localName)
     Same as equivalent method in the `Document' class.

 -- Method: Element.hasAttribute (name)
     Returns true if the element has an attribute named by `name'.

 -- Method: Element.hasAttributeNS (namespaceURI, localName)
     Returns true if the element has an attribute named by
     `namespaceURI' and `localName'.

 -- Method: Element.getAttribute (name)
     Return the value of the attribute named by `name' as a string. If
     no such attribute exists, an empty string is returned, as if the
     attribute had no value.

 -- Method: Element.getAttributeNode (attrname)
     Return the `Attr' node for the attribute named by `attrname'.

 -- Method: Element.getAttributeNS (namespaceURI, localName)
     Return the value of the attribute named by `namespaceURI' and
     `localName' as a string. If no such attribute exists, an empty
     string is returned, as if the attribute had no value.

 -- Method: Element.getAttributeNodeNS (namespaceURI, localName)
     Return an attribute value as a node, given a `namespaceURI' and
     `localName'.

 -- Method: Element.removeAttribute (name)
     Remove an attribute by name.  If there is no matching attribute, a
     *Note NotFoundErr: 1b64. is raised.

 -- Method: Element.removeAttributeNode (oldAttr)
     Remove and return `oldAttr' from the attribute list, if present.
     If `oldAttr' is not present, *Note NotFoundErr: 1b64. is raised.

 -- Method: Element.removeAttributeNS (namespaceURI, localName)
     Remove an attribute by name.  Note that it uses a localName, not a
     qname.  No exception is raised if there is no matching attribute.

 -- Method: Element.setAttribute (name, value)
     Set an attribute value from a string.

 -- Method: Element.setAttributeNode (newAttr)
     Add a new attribute node to the element, replacing an existing
     attribute if necessary if the `name' attribute matches.  If a
     replacement occurs, the old attribute node will be returned.  If
     `newAttr' is already in use, *Note InuseAttributeErr: 1b69. will
     be raised.

 -- Method: Element.setAttributeNodeNS (newAttr)
     Add a new attribute node to the element, replacing an existing
     attribute if necessary if the `namespaceURI' and `localName'
     attributes match.  If a replacement occurs, the old attribute node
     will be returned.  If `newAttr' is already in use, *Note
     InuseAttributeErr: 1b69. will be raised.

 -- Method: Element.setAttributeNS (namespaceURI, qname, value)
     Set an attribute value from a string, given a `namespaceURI' and a
     `qname'.  Note that a qname is the whole attribute name.  This is
     different than above.


File: python.info,  Node: Attr Objects,  Next: NamedNodeMap Objects,  Prev: Element Objects<2>,  Up: Objects in the DOM

5.19.8.9 Attr Objects
.....................

`Attr' inherits from `Node', so inherits all its attributes.

 -- Attribute: Attr.name
     The attribute name.  In a namespace-using document it may include
     a colon.

 -- Attribute: Attr.localName
     The part of the name following the colon if there is one, else the
     entire name.  This is a read-only attribute.

 -- Attribute: Attr.prefix
     The part of the name preceding the colon if there is one, else the
     empty string.

 -- Attribute: Attr.value
     The text value of the attribute.  This is a synonym for the
     `nodeValue' attribute.


File: python.info,  Node: NamedNodeMap Objects,  Next: Comment Objects,  Prev: Attr Objects,  Up: Objects in the DOM

5.19.8.10 NamedNodeMap Objects
..............................

`NamedNodeMap' does `not' inherit from `Node'.

 -- Attribute: NamedNodeMap.length
     The length of the attribute list.

 -- Method: NamedNodeMap.item (index)
     Return an attribute with a particular index.  The order you get
     the attributes in is arbitrary but will be consistent for the life
     of a DOM.  Each item is an attribute node.  Get its value with the
     `value' attribute.

There are also experimental methods that give this class more mapping
behavior.  You can use them or you can use the standardized
`getAttribute*()' family of methods on the `Element' objects.


File: python.info,  Node: Comment Objects,  Next: Text and CDATASection Objects,  Prev: NamedNodeMap Objects,  Up: Objects in the DOM

5.19.8.11 Comment Objects
.........................

`Comment' represents a comment in the XML document.  It is a subclass of
`Node', but cannot have child nodes.

 -- Attribute: Comment.data
     The content of the comment as a string.  The attribute contains
     all characters between the leading `<!-'`-' and trailing `-'`->',
     but does not include them.


File: python.info,  Node: Text and CDATASection Objects,  Next: ProcessingInstruction Objects,  Prev: Comment Objects,  Up: Objects in the DOM

5.19.8.12 Text and CDATASection Objects
.......................................

The `Text' interface represents text in the XML document.  If the parser
and DOM implementation support the DOM’s XML extension, portions of
the text enclosed in CDATA marked sections are stored in `CDATASection'
objects.  These two interfaces are identical, but provide different
values for the `nodeType' attribute.

These interfaces extend the `Node' interface.  They cannot have child
nodes.

 -- Attribute: Text.data
     The content of the text node as a string.

     Note: The use of a `CDATASection' node does not indicate that the
     node represents a complete CDATA marked section, only that the
     content of the node was part of a CDATA section.  A single CDATA
     section may be represented by more than one node in the document
     tree.  There is no way to determine whether two adjacent
     `CDATASection' nodes represent different CDATA marked sections.


File: python.info,  Node: ProcessingInstruction Objects,  Next: Exceptions<6>,  Prev: Text and CDATASection Objects,  Up: Objects in the DOM

5.19.8.13 ProcessingInstruction Objects
.......................................

Represents a processing instruction in the XML document; this inherits
from the `Node' interface and cannot have child nodes.

 -- Attribute: ProcessingInstruction.target
     The content of the processing instruction up to the first
     whitespace character.  This is a read-only attribute.

 -- Attribute: ProcessingInstruction.data
     The content of the processing instruction following the first
     whitespace character.


File: python.info,  Node: Exceptions<6>,  Prev: ProcessingInstruction Objects,  Up: Objects in the DOM

5.19.8.14 Exceptions
....................

New in version 2.1.

The DOM Level 2 recommendation defines a single exception, *Note
DOMException: 1b7e, and a number of constants that allow applications
to determine what sort of error occurred. *Note DOMException: 1b7e.
instances carry a *Note code: 62. attribute that provides the
appropriate value for the specific exception.

The Python DOM interface provides the constants, but also expands the
set of exceptions so that a specific exception exists for each of the
exception codes defined by the DOM.  The implementations must raise the
appropriate specific exception, each of which carries the appropriate
value for the *Note code: 62.  attribute.

 -- Exception: xml.dom.DOMException
     Base exception class used for all specific DOM exceptions.  This
     exception class cannot be directly instantiated.

 -- Exception: xml.dom.DomstringSizeErr
     Raised when a specified range of text does not fit into a string.
     This is not known to be used in the Python DOM implementations,
     but may be received from DOM implementations not written in Python.

 -- Exception: xml.dom.HierarchyRequestErr
     Raised when an attempt is made to insert a node where the node
     type is not allowed.

 -- Exception: xml.dom.IndexSizeErr
     Raised when an index or size parameter to a method is negative or
     exceeds the allowed values.

 -- Exception: xml.dom.InuseAttributeErr
     Raised when an attempt is made to insert an `Attr' node that is
     already present elsewhere in the document.

 -- Exception: xml.dom.InvalidAccessErr
     Raised if a parameter or an operation is not supported on the
     underlying object.

 -- Exception: xml.dom.InvalidCharacterErr
     This exception is raised when a string parameter contains a
     character that is not permitted in the context it’s being used
     in by the XML 1.0 recommendation.  For example, attempting to
     create an `Element' node with a space in the element type name
     will cause this error to be raised.

 -- Exception: xml.dom.InvalidModificationErr
     Raised when an attempt is made to modify the type of a node.

 -- Exception: xml.dom.InvalidStateErr
     Raised when an attempt is made to use an object that is not
     defined or is no longer usable.

 -- Exception: xml.dom.NamespaceErr
     If an attempt is made to change any object in a way that is not
     permitted with regard to the Namespaces in XML(1) recommendation,
     this exception is raised.

 -- Exception: xml.dom.NotFoundErr
     Exception when a node does not exist in the referenced context.
     For example, `NamedNodeMap.removeNamedItem()' will raise this if
     the node passed in does not exist in the map.

 -- Exception: xml.dom.NotSupportedErr
     Raised when the implementation does not support the requested type
     of object or operation.

 -- Exception: xml.dom.NoDataAllowedErr
     This is raised if data is specified for a node which does not
     support data.


 -- Exception: xml.dom.NoModificationAllowedErr
     Raised on attempts to modify an object where modifications are not
     allowed (such as for read-only nodes).

 -- Exception: xml.dom.SyntaxErr
     Raised when an invalid or illegal string is specified.


 -- Exception: xml.dom.WrongDocumentErr
     Raised when a node is inserted in a different document than it
     currently belongs to, and the implementation does not support
     migrating the node from one document to the other.

The exception codes defined in the DOM recommendation map to the
exceptions described above according to this table:

Constant                                   Exception
--------------------------------------------------------------------------------- 
`DOMSTRING_SIZE_ERR'                       *Note DomstringSizeErr: 1b7f.
`HIERARCHY_REQUEST_ERR'                    *Note HierarchyRequestErr: 1b80.
`INDEX_SIZE_ERR'                           *Note IndexSizeErr: 1b81.
`INUSE_ATTRIBUTE_ERR'                      *Note InuseAttributeErr: 1b69.
`INVALID_ACCESS_ERR'                       *Note InvalidAccessErr: 1b82.
`INVALID_CHARACTER_ERR'                    *Note InvalidCharacterErr: 1b83.
`INVALID_MODIFICATION_ERR'                 *Note InvalidModificationErr: 1b84.
`INVALID_STATE_ERR'                        *Note InvalidStateErr: 1b85.
`NAMESPACE_ERR'                            *Note NamespaceErr: 1b86.
`NOT_FOUND_ERR'                            *Note NotFoundErr: 1b64.
`NOT_SUPPORTED_ERR'                        *Note NotSupportedErr: 1b87.
`NO_DATA_ALLOWED_ERR'                      *Note NoDataAllowedErr: 1b88.
`NO_MODIFICATION_ALLOWED_ERR'              *Note NoModificationAllowedErr: 1b89.
`SYNTAX_ERR'                               *Note SyntaxErr: 1b8a.
`WRONG_DOCUMENT_ERR'                       *Note WrongDocumentErr: 1b8b.

---------- Footnotes ----------

(1) https://www.w3.org/TR/REC-xml-names/


File: python.info,  Node: Conformance,  Prev: Objects in the DOM,  Up: xml dom — The Document Object Model API

5.19.8.15 Conformance
.....................

This section describes the conformance requirements and relationships
between the Python DOM API, the W3C DOM recommendations, and the OMG
IDL mapping for Python.

* Menu:

* Type Mapping::
* Accessor Methods::


File: python.info,  Node: Type Mapping,  Next: Accessor Methods,  Up: Conformance

5.19.8.16 Type Mapping
......................

The primitive IDL types used in the DOM specification are mapped to
Python types according to the following table.

IDL Type               Python Type
----------------------------------------------------------------------- 
`boolean'              `IntegerType' (with a value of `0' or `1')
`int'                  `IntegerType'
`long int'             `IntegerType'
`unsigned int'         `IntegerType'

Additionally, the `DOMString' defined in the recommendation is mapped to
a Python string or Unicode string.  Applications should be able to
handle Unicode whenever a string is returned from the DOM.

The IDL `null' value is mapped to `None', which may be accepted or
provided by the implementation whenever `null' is allowed by the API.


File: python.info,  Node: Accessor Methods,  Prev: Type Mapping,  Up: Conformance

5.19.8.17 Accessor Methods
..........................

The mapping from OMG IDL to Python defines accessor functions for IDL
`attribute' declarations in much the way the Java mapping does.
Mapping the IDL declarations

    readonly attribute string someValue;
             attribute string anotherValue;

yields three accessor functions:  a “get” method for `someValue'
(`_get_someValue()'), and “get” and “set” methods for
`anotherValue' (`_get_anotherValue()' and `_set_anotherValue()').  The
mapping, in particular, does not require that the IDL attributes are
accessible as normal Python attributes:  `object.someValue' is `not'
required to work, and may raise an *Note AttributeError: 1f8.

The Python DOM API, however, `does' require that normal attribute
access work.  This means that the typical surrogates generated by
Python IDL compilers are not likely to work, and wrapper objects may be
needed on the client if the DOM objects are accessed via CORBA. While
this does require some additional consideration for CORBA DOM clients,
the implementers with experience using DOM over CORBA from Python do
not consider this a problem.  Attributes that are declared `readonly'
may not restrict write access in all DOM implementations.

In the Python DOM API, accessor functions are not required.  If
provided, they should take the form defined by the Python IDL mapping,
but these methods are considered unnecessary since the attributes are
accessible directly from Python.  “Set” accessors should never be
provided for `readonly' attributes.

The IDL definitions do not fully embody the requirements of the W3C DOM
API, such as the notion of certain objects, such as the return value of
`getElementsByTagName()', being “live”.  The Python DOM API does
not require implementations to enforce such requirements.


File: python.info,  Node: xml dom minidom — Minimal DOM implementation,  Next: xml dom pulldom — Support for building partial DOM trees,  Prev: xml dom — The Document Object Model API,  Up: Structured Markup Processing Tools

5.19.9 `xml.dom.minidom' — Minimal DOM implementation
-------------------------------------------------------

New in version 2.0.

`Source code:' Lib/xml/dom/minidom.py(1)

__________________________________________________________________

*Note xml.dom.minidom: 1a2. is a minimal implementation of the Document
Object Model interface, with an API similar to that in other languages.
It is intended to be simpler than the full DOM and also significantly
smaller.  Users who are not already proficient with the DOM should
consider using the *Note xml.etree.ElementTree: 1a4. module for their
XML processing instead.

     Warning: The *Note xml.dom.minidom: 1a2. module is not secure
     against maliciously constructed data.  If you need to parse
     untrusted or unauthenticated data see *Note XML vulnerabilities:
     1abf.

DOM applications typically start by parsing some XML into a DOM.  With
*Note xml.dom.minidom: 1a2, this is done through the parse functions:

    from xml.dom.minidom import parse, parseString

    dom1 = parse('c:\\temp\\mydata.xml')  # parse an XML file by name

    datasource = open('c:\\temp\\mydata.xml')
    dom2 = parse(datasource)  # parse an open file

    dom3 = parseString('<myxml>Some data<empty/> some more data</myxml>')

The *Note parse(): 1b93. function can take either a filename or an open
file object.

 -- Function: xml.dom.minidom.parse (filename_or_file[, parser[,
          bufsize]])
     Return a `Document' from the given input. `filename_or_file' may be
     either a file name, or a file-like object. `parser', if given,
     must be a SAX2 parser object. This function will change the
     document handler of the parser and activate namespace support;
     other parser configuration (like setting an entity resolver) must
     have been done in advance.

If you have XML in a string, you can use the *Note parseString(): 1b94.
function instead:

 -- Function: xml.dom.minidom.parseString (string[, parser])
     Return a `Document' that represents the `string'. This method
     creates a *Note StringIO: 2df. object for the string and passes
     that on to *Note parse(): 1b93.

Both functions return a `Document' object representing the content of
the document.

What the *Note parse(): 1b93. and *Note parseString(): 1b94. functions
do is connect an XML parser with a “DOM builder” that can accept
parse events from any SAX parser and convert them into a DOM tree.  The
name of the functions are perhaps misleading, but are easy to grasp
when learning the interfaces.  The parsing of the document will be
completed before these functions return; it’s simply that these
functions do not provide a parser implementation themselves.

You can also create a `Document' by calling a method on a “DOM
Implementation” object.  You can get this object either by calling the
`getDOMImplementation()' function in the *Note xml.dom: 1a1. package or
the *Note xml.dom.minidom: 1a2. module. Using the implementation from
the *Note xml.dom.minidom: 1a2. module will always return a `Document'
instance from the minidom implementation, while the version from *Note
xml.dom: 1a1. may provide an alternate implementation (this is likely
if you have the PyXML package(2) installed).  Once you have a
`Document', you can add child nodes to it to populate the DOM:

    from xml.dom.minidom import getDOMImplementation

    impl = getDOMImplementation()

    newdoc = impl.createDocument(None, "some_tag", None)
    top_element = newdoc.documentElement
    text = newdoc.createTextNode('Some textual content.')
    top_element.appendChild(text)

Once you have a DOM document object, you can access the parts of your
XML document through its properties and methods.  These properties are
defined in the DOM specification.  The main property of the document
object is the `documentElement' property.  It gives you the main
element in the XML document: the one that holds all others.  Here is an
example program:

    dom3 = parseString("<myxml>Some data</myxml>")
    assert dom3.documentElement.tagName == "myxml"

When you are finished with a DOM tree, you may optionally call the
`unlink()' method to encourage early cleanup of the now-unneeded
objects.  `unlink()' is an *Note xml.dom.minidom: 1a2.-specific
extension to the DOM API that renders the node and its descendants are
essentially useless.  Otherwise, Python’s garbage collector will
eventually take care of the objects in the tree.

See also
........

Document Object Model (DOM) Level 1 Specification(3)
     The W3C recommendation for the DOM supported by *Note
     xml.dom.minidom: 1a2.

* Menu:

* DOM Objects::
* DOM Example::
* minidom and the DOM standard::

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/xml/dom/minidom.py

(2) http://pyxml.sourceforge.net/

(3) https://www.w3.org/TR/REC-DOM-Level-1/


File: python.info,  Node: DOM Objects,  Next: DOM Example,  Up: xml dom minidom — Minimal DOM implementation

5.19.9.1 DOM Objects
....................

The definition of the DOM API for Python is given as part of the *Note
xml.dom: 1a1.  module documentation.  This section lists the
differences between the API and *Note xml.dom.minidom: 1a2.

 -- Method: Node.unlink ()
     Break internal references within the DOM so that it will be
     garbage collected on versions of Python without cyclic GC.  Even
     when cyclic GC is available, using this can make large amounts of
     memory available sooner, so calling this on DOM objects as soon as
     they are no longer needed is good practice.  This only needs to be
     called on the `Document' object, but may be called on child nodes
     to discard children of that node.

 -- Method: Node.writexml (writer, indent="", addindent="", newl="")
     Write XML to the writer object.  The writer should have a
     `write()' method which matches that of the file object interface.
     The `indent' parameter is the indentation of the current node.
     The `addindent' parameter is the incremental indentation to use
     for subnodes of the current one.  The `newl' parameter specifies
     the string to use to terminate newlines.

     For the `Document' node, an additional keyword argument `encoding'
     can be used to specify the encoding field of the XML header.

     Changed in version 2.1: The optional keyword parameters `indent',
     `addindent', and `newl' were added to support pretty output.

     Changed in version 2.3: For the `Document' node, an additional
     keyword argument `encoding' can be used to specify the encoding
     field of the XML header.


 -- Method: Node.toxml ([encoding])
     Return the XML that the DOM represents as a string.

     With no argument, the XML header does not specify an encoding, and
     the result is Unicode string if the default encoding cannot
     represent all characters in the document. Encoding this string in
     an encoding other than UTF-8 is likely incorrect, since UTF-8 is
     the default encoding of XML.

     With an explicit `encoding' (1) argument, the result is a byte
     string in the specified encoding. It is recommended that this
     argument is always specified. To avoid *Note UnicodeError: 44c.
     exceptions in case of unrepresentable text data, the encoding
     argument should be specified as “utf-8”.

     Changed in version 2.3: the `encoding' argument was introduced;
     see *Note writexml(): 1b98.


 -- Method: Node.toprettyxml ([indent=""[, newl=""[, encoding=""]]])
     Return a pretty-printed version of the document. `indent'
     specifies the indentation string and defaults to a tabulator;
     `newl' specifies the string emitted at the end of each line and
     defaults to `\n'.

     New in version 2.1.

     Changed in version 2.3: the encoding argument was introduced; see
     *Note writexml(): 1b98.


The following standard DOM methods have special considerations with
*Note xml.dom.minidom: 1a2.:

 -- Method: Node.cloneNode (deep)
     Although this method was present in the version of *Note
     xml.dom.minidom: 1a2.  packaged with Python 2.0, it was seriously
     broken.  This has been corrected for subsequent releases.

---------- Footnotes ----------

(1) The encoding string included in XML output should conform to the
appropriate standards. For example, “UTF-8” is valid, but
“UTF8” is not. See
<https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl> and
<https://www.iana.org/assignments/character-sets/character-sets.xhtml>.


File: python.info,  Node: DOM Example,  Next: minidom and the DOM standard,  Prev: DOM Objects,  Up: xml dom minidom — Minimal DOM implementation

5.19.9.2 DOM Example
....................

This example program is a fairly realistic example of a simple program.
In this particular case, we do not take much advantage of the
flexibility of the DOM.

    import xml.dom.minidom

    document = """\
    <slideshow>
    <title>Demo slideshow</title>
    <slide><title>Slide title</title>
    <point>This is a demo</point>
    <point>Of a program for processing slides</point>
    </slide>

    <slide><title>Another demo slide</title>
    <point>It is important</point>
    <point>To have more than</point>
    <point>one slide</point>
    </slide>
    </slideshow>
    """

    dom = xml.dom.minidom.parseString(document)

    def getText(nodelist):
        rc = []
        for node in nodelist:
            if node.nodeType == node.TEXT_NODE:
                rc.append(node.data)
        return ''.join(rc)

    def handleSlideshow(slideshow):
        print "<html>"
        handleSlideshowTitle(slideshow.getElementsByTagName("title")[0])
        slides = slideshow.getElementsByTagName("slide")
        handleToc(slides)
        handleSlides(slides)
        print "</html>"

    def handleSlides(slides):
        for slide in slides:
            handleSlide(slide)

    def handleSlide(slide):
        handleSlideTitle(slide.getElementsByTagName("title")[0])
        handlePoints(slide.getElementsByTagName("point"))

    def handleSlideshowTitle(title):
        print "<title>%s</title>" % getText(title.childNodes)

    def handleSlideTitle(title):
        print "<h2>%s</h2>" % getText(title.childNodes)

    def handlePoints(points):
        print "<ul>"
        for point in points:
            handlePoint(point)
        print "</ul>"

    def handlePoint(point):
        print "<li>%s</li>" % getText(point.childNodes)

    def handleToc(slides):
        for slide in slides:
            title = slide.getElementsByTagName("title")[0]
            print "<p>%s</p>" % getText(title.childNodes)

    handleSlideshow(dom)


File: python.info,  Node: minidom and the DOM standard,  Prev: DOM Example,  Up: xml dom minidom — Minimal DOM implementation

5.19.9.3 minidom and the DOM standard
.....................................

The *Note xml.dom.minidom: 1a2. module is essentially a DOM
1.0-compatible DOM with some DOM 2 features (primarily namespace
features).

Usage of the DOM interface in Python is straight-forward.  The
following mapping rules apply:

   * Interfaces are accessed through instance objects. Applications
     should not instantiate the classes themselves; they should use the
     creator functions available on the `Document' object. Derived
     interfaces support all operations (and attributes) from the base
     interfaces, plus any new operations.

   * Operations are used as methods. Since the DOM uses only *Note in:
     441.  parameters, the arguments are passed in normal order (from
     left to right).  There are no optional arguments. `void'
     operations return `None'.

   * IDL attributes map to instance attributes. For compatibility with
     the OMG IDL language mapping for Python, an attribute `foo' can
     also be accessed through accessor methods `_get_foo()' and
     `_set_foo()'.  `readonly' attributes must not be changed; this is
     not enforced at runtime.

   * The types `short int', `unsigned int', `unsigned long long', and
     `boolean' all map to Python integer objects.

   * The type `DOMString' maps to Python strings. *Note
     xml.dom.minidom: 1a2. supports either byte or Unicode strings, but
     will normally produce Unicode strings.  Values of type `DOMString'
     may also be `None' where allowed to have the IDL `null' value by
     the DOM specification from the W3C.

   * `const' declarations map to variables in their respective scope
     (e.g.  `xml.dom.minidom.Node.PROCESSING_INSTRUCTION_NODE'); they
     must not be changed.

   * `DOMException' is currently not supported in *Note
     xml.dom.minidom: 1a2.  Instead, *Note xml.dom.minidom: 1a2. uses
     standard Python exceptions such as *Note TypeError: 218. and *Note
     AttributeError: 1f8.

   * `NodeList' objects are implemented using Python’s built-in list
     type.  Starting with Python 2.2, these objects provide the
     interface defined in the DOM specification, but with earlier
     versions of Python they do not support the official API.  They
     are, however, much more “Pythonic” than the interface defined
     in the W3C recommendations.

The following interfaces have no implementation in *Note
xml.dom.minidom: 1a2.:

   * `DOMTimeStamp'

   * `DocumentType' (added in Python 2.1)

   * `DOMImplementation' (added in Python 2.1)

   * `CharacterData'

   * `CDATASection'

   * `Notation'

   * `Entity'

   * `EntityReference'

   * `DocumentFragment'

Most of these reflect information in the XML document that is not of
general utility to most DOM users.


File: python.info,  Node: xml dom pulldom — Support for building partial DOM trees,  Next: xml sax — Support for SAX2 parsers,  Prev: xml dom minidom — Minimal DOM implementation,  Up: Structured Markup Processing Tools

5.19.10 `xml.dom.pulldom' — Support for building partial DOM trees
--------------------------------------------------------------------

New in version 2.0.

`Source code:' Lib/xml/dom/pulldom.py(1)

__________________________________________________________________

*Note xml.dom.pulldom: 1a3. allows building only selected portions of a
Document Object Model representation of a document from SAX events.

     Warning: The *Note xml.dom.pulldom: 1a3. module is not secure
     against maliciously constructed data.  If you need to parse
     untrusted or unauthenticated data see *Note XML vulnerabilities:
     1abf.

 -- Class: xml.dom.pulldom.PullDOM ([documentFactory])
     *Note xml.sax.handler.ContentHandler: 1ba3. implementation that …

 -- Class: xml.dom.pulldom.DOMEventStream (stream, parser, bufsize)
     …

 -- Class: xml.dom.pulldom.SAX2DOM ([documentFactory])
     *Note xml.sax.handler.ContentHandler: 1ba3. implementation that …

 -- Function: xml.dom.pulldom.parse (stream_or_string[, parser[,
          bufsize]])
     …

 -- Function: xml.dom.pulldom.parseString (string[, parser])
     …

 -- Data: xml.dom.pulldom.default_bufsize
     Default value for the `bufsize' parameter to *Note parse(): 1ba6.

     Changed in version 2.1: The value of this variable can be changed
     before calling *Note parse(): 1ba6. and the new value will take
     effect.


* Menu:

* DOMEventStream Objects::

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/xml/dom/pulldom.py


File: python.info,  Node: DOMEventStream Objects,  Up: xml dom pulldom — Support for building partial DOM trees

5.19.10.1 DOMEventStream Objects
................................

 -- Method: DOMEventStream.getEvent ()
     …

 -- Method: DOMEventStream.expandNode (node)
     …

 -- Method: DOMEventStream.reset ()
     …


File: python.info,  Node: xml sax — Support for SAX2 parsers,  Next: xml sax handler — Base classes for SAX handlers,  Prev: xml dom pulldom — Support for building partial DOM trees,  Up: Structured Markup Processing Tools

5.19.11 `xml.sax' — Support for SAX2 parsers
----------------------------------------------

New in version 2.0.

The *Note xml.sax: 1a6. package provides a number of modules which
implement the Simple API for XML (SAX) interface for Python.  The
package itself provides the SAX exceptions and the convenience
functions which will be most used by users of the SAX API.

     Warning: The *Note xml.sax: 1a6. module is not secure against
     maliciously constructed data.  If you need to parse untrusted or
     unauthenticated data see *Note XML vulnerabilities: 1abf.

The convenience functions are:

 -- Function: xml.sax.make_parser ([parser_list])
     Create and return a SAX *Note XMLReader: 1bb1. object.  The first
     parser found will be used.  If `parser_list' is provided, it must
     be a sequence of strings which name modules that have a function
     named `create_parser()'.  Modules listed in `parser_list' will be
     used before modules in the default list of parsers.

 -- Function: xml.sax.parse (filename_or_stream, handler[,
          error_handler])
     Create a SAX parser and use it to parse a document.  The document,
     passed in as `filename_or_stream', can be a filename or a file
     object.  The `handler' parameter needs to be a SAX *Note
     ContentHandler: 1ba3. instance.  If `error_handler' is given, it
     must be a SAX *Note ErrorHandler: 1bb3.  instance; if omitted,
     *Note SAXParseException: 1bb4. will be raised on all errors.
     There is no return value; all work must be done by the `handler'
     passed in.

 -- Function: xml.sax.parseString (string, handler[, error_handler])
     Similar to *Note parse(): 1bb2, but parses from a buffer `string'
     received as a parameter.

A typical SAX application uses three kinds of objects: readers,
handlers and input sources.  “Reader” in this context is another
term for parser, i.e. some piece of code that reads the bytes or
characters from the input source, and produces a sequence of events.
The events then get distributed to the handler objects, i.e. the reader
invokes a method on the handler.  A SAX application must therefore
obtain a reader object, create or open the input sources, create the
handlers, and connect these objects all together.  As the final step of
preparation, the reader is called to parse the input. During parsing,
methods on the handler objects are called based on structural and
syntactic events from the input data.

For these objects, only the interfaces are relevant; they are normally
not instantiated by the application itself.  Since Python does not have
an explicit notion of interface, they are formally introduced as
classes, but applications may use implementations which do not inherit
from the provided classes.  The *Note InputSource: 1bb6, *Note Locator:
1bb7, `Attributes', `AttributesNS', and *Note XMLReader: 1bb1.
interfaces are defined in the module *Note xml.sax.xmlreader: 1a9.  The
handler interfaces are defined in *Note xml.sax.handler: 1a7.  For
convenience, *Note InputSource: 1bb6. (which is often instantiated
directly) and the handler classes are also available from *Note
xml.sax: 1a6.  These interfaces are described below.

In addition to these classes, *Note xml.sax: 1a6. provides the
following exception classes.

 -- Exception: xml.sax.SAXException (msg[, exception])
     Encapsulate an XML error or warning.  This class can contain basic
     error or warning information from either the XML parser or the
     application: it can be subclassed to provide additional
     functionality or to add localization.  Note that although the
     handlers defined in the *Note ErrorHandler: 1bb3. interface
     receive instances of this exception, it is not required to
     actually raise the exception — it is also useful as a container
     for information.

     When instantiated, `msg' should be a human-readable description of
     the error.  The optional `exception' parameter, if given, should
     be `None' or an exception that was caught by the parsing code and
     is being passed along as information.

     This is the base class for the other SAX exception classes.

 -- Exception: xml.sax.SAXParseException (msg, exception, locator)
     Subclass of *Note SAXException: 1bb8. raised on parse errors.
     Instances of this class are passed to the methods of the SAX *Note
     ErrorHandler: 1bb3. interface to provide information about the
     parse error.  This class supports the SAX *Note Locator: 1bb7.
     interface as well as the *Note SAXException: 1bb8. interface.

 -- Exception: xml.sax.SAXNotRecognizedException (msg[, exception])
     Subclass of *Note SAXException: 1bb8. raised when a SAX *Note
     XMLReader: 1bb1. is confronted with an unrecognized feature or
     property.  SAX applications and extensions may use this class for
     similar purposes.

 -- Exception: xml.sax.SAXNotSupportedException (msg[, exception])
     Subclass of *Note SAXException: 1bb8. raised when a SAX *Note
     XMLReader: 1bb1. is asked to enable a feature that is not
     supported, or to set a property to a value that the implementation
     does not support.  SAX applications and extensions may use this
     class for similar purposes.

See also
........

SAX: The Simple API for XML(1)
     This site is the focal point for the definition of the SAX API.
     It provides a Java implementation and online documentation.  Links
     to implementations and historical information are also available.

Module *Note xml.sax.handler: 1a7.
     Definitions of the interfaces for application-provided objects.

Module *Note xml.sax.saxutils: 1a8.
     Convenience functions for use in SAX applications.

Module *Note xml.sax.xmlreader: 1a9.
     Definitions of the interfaces for parser-provided objects.

* Menu:

* SAXException Objects::

---------- Footnotes ----------

(1) http://www.saxproject.org/


File: python.info,  Node: SAXException Objects,  Up: xml sax — Support for SAX2 parsers

5.19.11.1 SAXException Objects
..............................

The *Note SAXException: 1bb8. exception class supports the following
methods:

 -- Method: SAXException.getMessage ()
     Return a human-readable message describing the error condition.

 -- Method: SAXException.getException ()
     Return an encapsulated exception object, or `None'.


File: python.info,  Node: xml sax handler — Base classes for SAX handlers,  Next: xml sax saxutils — SAX Utilities,  Prev: xml sax — Support for SAX2 parsers,  Up: Structured Markup Processing Tools

5.19.12 `xml.sax.handler' — Base classes for SAX handlers
-----------------------------------------------------------

New in version 2.0.

The SAX API defines four kinds of handlers: content handlers, DTD
handlers, error handlers, and entity resolvers. Applications normally
only need to implement those interfaces whose events they are
interested in; they can implement the interfaces in a single object or
in multiple objects. Handler implementations should inherit from the
base classes provided in the module *Note xml.sax.handler: 1a7, so that
all methods get default implementations.

 -- Class: xml.sax.handler.ContentHandler
     This is the main callback interface in SAX, and the one most
     important to applications. The order of events in this interface
     mirrors the order of the information in the document.

 -- Class: xml.sax.handler.DTDHandler
     Handle DTD events.

     This interface specifies only those DTD events required for basic
     parsing (unparsed entities and attributes).

 -- Class: xml.sax.handler.EntityResolver
     Basic interface for resolving entities. If you create an object
     implementing this interface, then register the object with your
     Parser, the parser will call the method in your object to resolve
     all external entities.

 -- Class: xml.sax.handler.ErrorHandler
     Interface used by the parser to present error and warning messages
     to the application.  The methods of this object control whether
     errors are immediately converted to exceptions or are handled in
     some other way.

In addition to these classes, *Note xml.sax.handler: 1a7. provides
symbolic constants for the feature and property names.

 -- Data: xml.sax.handler.feature_namespaces
         value: `"http://xml.org/sax/features/namespaces"' 
         true: Perform Namespace processing. 
         false: Optionally do not perform Namespace processing (implies namespace-prefixes; default). 
         access: (parsing) read-only; (not parsing) read/write 


 -- Data: xml.sax.handler.feature_namespace_prefixes
         value: `"http://xml.org/sax/features/namespace-prefixes"' 
         true: Report the original prefixed names and attributes used for Namespace declarations. 
         false: Do not report attributes used for Namespace declarations, and optionally do not report original prefixed names (default). 
         access: (parsing) read-only; (not parsing) read/write 


 -- Data: xml.sax.handler.feature_string_interning
         value: `"http://xml.org/sax/features/string-interning"' 
         true: All element names, prefixes, attribute names, Namespace URIs, and local names are interned using the built-in intern function. 
         false: Names are not necessarily interned, although they may be (default). 
         access: (parsing) read-only; (not parsing) read/write 


 -- Data: xml.sax.handler.feature_validation
         value: `"http://xml.org/sax/features/validation"' 
         true: Report all validation errors (implies external-general-entities and external-parameter-entities). 
         false: Do not report validation errors. 
         access: (parsing) read-only; (not parsing) read/write 


 -- Data: xml.sax.handler.feature_external_ges
         value: `"http://xml.org/sax/features/external-general-entities"' 
         true: Include all external general (text) entities. 
         false: Do not include external general entities. 
         access: (parsing) read-only; (not parsing) read/write 


 -- Data: xml.sax.handler.feature_external_pes
         value: `"http://xml.org/sax/features/external-parameter-entities"' 
         true: Include all external parameter entities, including the external DTD subset. 
         false: Do not include any external parameter entities, even the external DTD subset. 
         access: (parsing) read-only; (not parsing) read/write 


 -- Data: xml.sax.handler.all_features
     List of all features.

 -- Data: xml.sax.handler.property_lexical_handler
         value: `"http://xml.org/sax/properties/lexical-handler"' 
         data type: xml.sax.sax2lib.LexicalHandler (not supported in Python 2) 
         description: An optional extension handler for lexical events like comments. 
         access: read/write 


 -- Data: xml.sax.handler.property_declaration_handler
         value: `"http://xml.org/sax/properties/declaration-handler"' 
         data type: xml.sax.sax2lib.DeclHandler (not supported in Python 2) 
         description: An optional extension handler for DTD-related events other than notations and unparsed entities. 
         access: read/write 


 -- Data: xml.sax.handler.property_dom_node
         value: `"http://xml.org/sax/properties/dom-node"' 
         data type: org.w3c.dom.Node (not supported in Python 2) 
         description: When parsing, the current DOM node being visited if this is a DOM iterator; when not parsing, the root DOM node for iteration. 
         access: (parsing) read-only; (not parsing) read/write 


 -- Data: xml.sax.handler.property_xml_string
         value: `"http://xml.org/sax/properties/xml-string"' 
         data type: String 
         description: The literal string of characters that was the source for the current event. 
         access: read-only 


 -- Data: xml.sax.handler.all_properties
     List of all known property names.

* Menu:

* ContentHandler Objects::
* DTDHandler Objects::
* EntityResolver Objects::
* ErrorHandler Objects::


File: python.info,  Node: ContentHandler Objects,  Next: DTDHandler Objects,  Up: xml sax handler — Base classes for SAX handlers

5.19.12.1 ContentHandler Objects
................................

Users are expected to subclass *Note ContentHandler: 1ba3. to support
their application.  The following methods are called by the parser on
the appropriate events in the input document:

 -- Method: ContentHandler.setDocumentLocator (locator)
     Called by the parser to give the application a locator for
     locating the origin of document events.

     SAX parsers are strongly encouraged (though not absolutely
     required) to supply a locator: if it does so, it must supply the
     locator to the application by invoking this method before invoking
     any of the other methods in the DocumentHandler interface.

     The locator allows the application to determine the end position
     of any document-related event, even if the parser is not reporting
     an error. Typically, the application will use this information for
     reporting its own errors (such as character content that does not
     match an application’s business rules). The information returned
     by the locator is probably not sufficient for use with a search
     engine.

     Note that the locator will return correct information only during
     the invocation of the events in this interface. The application
     should not attempt to use it at any other time.

 -- Method: ContentHandler.startDocument ()
     Receive notification of the beginning of a document.

     The SAX parser will invoke this method only once, before any other
     methods in this interface or in DTDHandler (except for *Note
     setDocumentLocator(): 1bd1.).

 -- Method: ContentHandler.endDocument ()
     Receive notification of the end of a document.

     The SAX parser will invoke this method only once, and it will be
     the last method invoked during the parse. The parser shall not
     invoke this method until it has either abandoned parsing (because
     of an unrecoverable error) or reached the end of input.

 -- Method: ContentHandler.startPrefixMapping (prefix, uri)
     Begin the scope of a prefix-URI Namespace mapping.

     The information from this event is not necessary for normal
     Namespace processing: the SAX XML reader will automatically
     replace prefixes for element and attribute names when the
     `feature_namespaces' feature is enabled (the default).

     There are cases, however, when applications need to use prefixes
     in character data or in attribute values, where they cannot safely
     be expanded automatically; the *Note startPrefixMapping(): 1bd4.
     and *Note endPrefixMapping(): 1bd5. events supply the information
     to the application to expand prefixes in those contexts itself, if
     necessary.

     Note that *Note startPrefixMapping(): 1bd4. and *Note
     endPrefixMapping(): 1bd5. events are not guaranteed to be properly
     nested relative to each-other: all *Note startPrefixMapping():
     1bd4. events will occur before the corresponding *Note
     startElement(): 1bd6. event, and all *Note endPrefixMapping():
     1bd5. events will occur after the corresponding *Note
     endElement(): 1bd7. event, but their order is not guaranteed.

 -- Method: ContentHandler.endPrefixMapping (prefix)
     End the scope of a prefix-URI mapping.

     See *Note startPrefixMapping(): 1bd4. for details. This event will
     always occur after the corresponding *Note endElement(): 1bd7.
     event, but the order of *Note endPrefixMapping(): 1bd5. events is
     not otherwise guaranteed.

 -- Method: ContentHandler.startElement (name, attrs)
     Signals the start of an element in non-namespace mode.

     The `name' parameter contains the raw XML 1.0 name of the element
     type as a string and the `attrs' parameter holds an object of the
     `Attributes' interface (see *Note The Attributes Interface: 1bd8.)
     containing the attributes of the element.  The object passed as
     `attrs' may be re-used by the parser; holding on to a reference to
     it is not a reliable way to keep a copy of the attributes.  To
     keep a copy of the attributes, use the *Note copy(): 71. method of
     the `attrs' object.

 -- Method: ContentHandler.endElement (name)
     Signals the end of an element in non-namespace mode.

     The `name' parameter contains the name of the element type, just
     as with the *Note startElement(): 1bd6. event.

 -- Method: ContentHandler.startElementNS (name, qname, attrs)
     Signals the start of an element in namespace mode.

     The `name' parameter contains the name of the element type as a
     `(uri, localname)' tuple, the `qname' parameter contains the raw
     XML 1.0 name used in the source document, and the `attrs'
     parameter holds an instance of the `AttributesNS' interface (see
     *Note The AttributesNS Interface: 1bda.)  containing the
     attributes of the element.  If no namespace is associated with the
     element, the `uri' component of `name' will be `None'.  The object
     passed as `attrs' may be re-used by the parser; holding on to a
     reference to it is not a reliable way to keep a copy of the
     attributes.  To keep a copy of the attributes, use the *Note
     copy(): 71. method of the `attrs' object.

     Parsers may set the `qname' parameter to `None', unless the
     `feature_namespace_prefixes' feature is activated.

 -- Method: ContentHandler.endElementNS (name, qname)
     Signals the end of an element in namespace mode.

     The `name' parameter contains the name of the element type, just
     as with the *Note startElementNS(): 1bd9. method, likewise the
     `qname' parameter.

 -- Method: ContentHandler.characters (content)
     Receive notification of character data.

     The Parser will call this method to report each chunk of character
     data. SAX parsers may return all contiguous character data in a
     single chunk, or they may split it into several chunks; however,
     all of the characters in any single event must come from the same
     external entity so that the Locator provides useful information.

     `content' may be a Unicode string or a byte string; the `expat'
     reader module produces always Unicode strings.

          Note: The earlier SAX 1 interface provided by the Python XML
          Special Interest Group used a more Java-like interface for
          this method.  Since most parsers used from Python did not
          take advantage of the older interface, the simpler signature
          was chosen to replace it.  To convert old code to the new
          interface, use `content' instead of slicing content with the
          old `offset' and `length' parameters.

 -- Method: ContentHandler.ignorableWhitespace (whitespace)
     Receive notification of ignorable whitespace in element content.

     Validating Parsers must use this method to report each chunk of
     ignorable whitespace (see the W3C XML 1.0 recommendation, section
     2.10): non-validating parsers may also use this method if they are
     capable of parsing and using content models.

     SAX parsers may return all contiguous whitespace in a single
     chunk, or they may split it into several chunks; however, all of
     the characters in any single event must come from the same
     external entity, so that the Locator provides useful information.

 -- Method: ContentHandler.processingInstruction (target, data)
     Receive notification of a processing instruction.

     The Parser will invoke this method once for each processing
     instruction found: note that processing instructions may occur
     before or after the main document element.

     A SAX parser should never report an XML declaration (XML 1.0,
     section 2.8) or a text declaration (XML 1.0, section 4.3.1) using
     this method.

 -- Method: ContentHandler.skippedEntity (name)
     Receive notification of a skipped entity.

     The Parser will invoke this method once for each entity skipped.
     Non-validating processors may skip entities if they have not seen
     the declarations (because, for example, the entity was declared in
     an external DTD subset). All processors may skip external
     entities, depending on the values of the `feature_external_ges'
     and the `feature_external_pes' properties.


File: python.info,  Node: DTDHandler Objects,  Next: EntityResolver Objects,  Prev: ContentHandler Objects,  Up: xml sax handler — Base classes for SAX handlers

5.19.12.2 DTDHandler Objects
............................

*Note DTDHandler: 1bc1. instances provide the following methods:

 -- Method: DTDHandler.notationDecl (name, publicId, systemId)
     Handle a notation declaration event.

 -- Method: DTDHandler.unparsedEntityDecl (name, publicId, systemId,
          ndata)
     Handle an unparsed entity declaration event.


File: python.info,  Node: EntityResolver Objects,  Next: ErrorHandler Objects,  Prev: DTDHandler Objects,  Up: xml sax handler — Base classes for SAX handlers

5.19.12.3 EntityResolver Objects
................................

 -- Method: EntityResolver.resolveEntity (publicId, systemId)
     Resolve the system identifier of an entity and return either the
     system identifier to read from as a string, or an InputSource to
     read from. The default implementation returns `systemId'.


File: python.info,  Node: ErrorHandler Objects,  Prev: EntityResolver Objects,  Up: xml sax handler — Base classes for SAX handlers

5.19.12.4 ErrorHandler Objects
..............................

Objects with this interface are used to receive error and warning
information from the *Note XMLReader: 1bb1.  If you create an object
that implements this interface, then register the object with your
*Note XMLReader: 1bb1, the parser will call the methods in your object
to report all warnings and errors. There are three levels of errors
available: warnings, (possibly) recoverable errors, and unrecoverable
errors.  All methods take a `SAXParseException' as the only parameter.
Errors and warnings may be converted to an exception by raising the
passed-in exception object.

 -- Method: ErrorHandler.error (exception)
     Called when the parser encounters a recoverable error.  If this
     method does not raise an exception, parsing may continue, but
     further document information should not be expected by the
     application.  Allowing the parser to continue may allow additional
     errors to be discovered in the input document.

 -- Method: ErrorHandler.fatalError (exception)
     Called when the parser encounters an error it cannot recover from;
     parsing is expected to terminate when this method returns.

 -- Method: ErrorHandler.warning (exception)
     Called when the parser presents minor warning information to the
     application.  Parsing is expected to continue when this method
     returns, and document information will continue to be passed to
     the application. Raising an exception in this method will cause
     parsing to end.


File: python.info,  Node: xml sax saxutils — SAX Utilities,  Next: xml sax xmlreader — Interface for XML parsers,  Prev: xml sax handler — Base classes for SAX handlers,  Up: Structured Markup Processing Tools

5.19.13 `xml.sax.saxutils' — SAX Utilities
--------------------------------------------

New in version 2.0.

The module *Note xml.sax.saxutils: 1a8. contains a number of classes
and functions that are commonly useful when creating SAX applications,
either in direct use, or as base classes.

 -- Function: xml.sax.saxutils.escape (data[, entities])
     Escape `'&'', `'<'', and `'>'' in a string of data.

     You can escape other strings of data by passing a dictionary as
     the optional `entities' parameter.  The keys and values must all
     be strings; each key will be replaced with its corresponding
     value.  The characters `'&'', `'<'' and `'>'' are always escaped,
     even if `entities' is provided.

 -- Function: xml.sax.saxutils.unescape (data[, entities])
     Unescape `'&amp;'', `'&lt;'', and `'&gt;'' in a string of data.

     You can unescape other strings of data by passing a dictionary as
     the optional `entities' parameter.  The keys and values must all
     be strings; each key will be replaced with its corresponding
     value.  `'&amp'', `'&lt;'', and `'&gt;'' are always unescaped,
     even if `entities' is provided.

     New in version 2.3.


 -- Function: xml.sax.saxutils.quoteattr (data[, entities])
     Similar to *Note escape(): 1bee, but also prepares `data' to be
     used as an attribute value.  The return value is a quoted version
     of `data' with any additional required replacements. *Note
     quoteattr(): 1bf0. will select a quote character based on the
     content of `data', attempting to avoid encoding any quote
     characters in the string.  If both single- and double-quote
     characters are already in `data', the double-quote characters will
     be encoded and `data' will be wrapped in double-quotes.  The
     resulting string can be used directly as an attribute value:

         >>> print "<element attr=%s>" % quoteattr("ab ' cd \" ef")
         <element attr="ab ' cd &quot; ef">

     This function is useful when generating attribute values for HTML
     or any SGML using the reference concrete syntax.

     New in version 2.2.


 -- Class: xml.sax.saxutils.XMLGenerator ([out[, encoding]])
     This class implements the *Note ContentHandler: 1ba3. interface by
     writing SAX events back into an XML document. In other words,
     using an *Note XMLGenerator: 1bf1.  as the content handler will
     reproduce the original document being parsed. `out' should be a
     file-like object which will default to `sys.stdout'. `encoding' is
     the encoding of the output stream which defaults to `'iso-8859-1''.

 -- Class: xml.sax.saxutils.XMLFilterBase (base)
     This class is designed to sit between an *Note XMLReader: 1bb1.
     and the client application’s event handlers.  By default, it
     does nothing but pass requests up to the reader and events on to
     the handlers unmodified, but subclasses can override specific
     methods to modify the event stream or the configuration requests
     as they pass through.

 -- Function: xml.sax.saxutils.prepare_input_source (source[, base])
     This function takes an input source and an optional base URL and
     returns a fully resolved *Note InputSource: 1bb6. object ready for
     reading.  The input source can be given as a string, a file-like
     object, or an *Note InputSource: 1bb6. object; parsers will use
     this function to implement the polymorphic `source' argument to
     their `parse()' method.


File: python.info,  Node: xml sax xmlreader — Interface for XML parsers,  Next: xml parsers expat — Fast XML parsing using Expat,  Prev: xml sax saxutils — SAX Utilities,  Up: Structured Markup Processing Tools

5.19.14 `xml.sax.xmlreader' — Interface for XML parsers
---------------------------------------------------------

New in version 2.0.

SAX parsers implement the *Note XMLReader: 1bb1. interface. They are
implemented in a Python module, which must provide a function
`create_parser()'. This function is invoked by  *Note
xml.sax.make_parser(): 1bb0. with no arguments to create a new  parser
object.

 -- Class: xml.sax.xmlreader.XMLReader
     Base class which can be inherited by SAX parsers.

 -- Class: xml.sax.xmlreader.IncrementalParser
     In some cases, it is desirable not to parse an input source at
     once, but to feed chunks of the document as they get available.
     Note that the reader will normally not read the entire file, but
     read it in chunks as well; still `parse()' won’t return until
     the entire document is processed. So these interfaces should be
     used if the blocking behaviour of `parse()' is not desirable.

     When the parser is instantiated it is ready to begin accepting
     data from the feed method immediately. After parsing has been
     finished with a call to close the reset method must be called to
     make the parser ready to accept new data, either from feed or
     using the parse method.

     Note that these methods must `not' be called during parsing, that
     is, after parse has been called and before it returns.

     By default, the class also implements the parse method of the
     XMLReader interface using the feed, close and reset methods of the
     IncrementalParser interface as a convenience to SAX 2.0 driver
     writers.

 -- Class: xml.sax.xmlreader.Locator
     Interface for associating a SAX event with a document location. A
     locator object will return valid results only during calls to
     DocumentHandler methods; at any other time, the results are
     unpredictable. If information is not available, methods may return
     `None'.

 -- Class: xml.sax.xmlreader.InputSource ([systemId])
     Encapsulation of the information needed by the *Note XMLReader:
     1bb1. to read entities.

     This class may include information about the public identifier,
     system identifier, byte stream (possibly with character encoding
     information) and/or the character stream of an entity.

     Applications will create objects of this class for use in the
     *Note XMLReader.parse(): 1bf7. method and for returning from
     EntityResolver.resolveEntity.

     An *Note InputSource: 1bb6. belongs to the application, the *Note
     XMLReader: 1bb1. is not allowed to modify *Note InputSource: 1bb6.
     objects passed to it from the application, although it may make
     copies and modify those.

 -- Class: xml.sax.xmlreader.AttributesImpl (attrs)
     This is an implementation of the `Attributes' interface (see
     section *Note The Attributes Interface: 1bd8.).  This is a
     dictionary-like object which represents the element attributes in
     a `startElement()' call. In addition to the most useful dictionary
     operations, it supports a number of other methods as described by
     the interface. Objects of this class should be instantiated by
     readers; `attrs' must be a dictionary-like object containing a
     mapping from attribute names to attribute values.

 -- Class: xml.sax.xmlreader.AttributesNSImpl (attrs, qnames)
     Namespace-aware variant of *Note AttributesImpl: 1bf8, which will
     be passed to `startElementNS()'. It is derived from *Note
     AttributesImpl: 1bf8, but understands attribute names as
     two-tuples of `namespaceURI' and `localname'. In addition, it
     provides a number of methods expecting qualified names as they
     appear in the original document.  This class implements the
     `AttributesNS' interface (see section *Note The AttributesNS
     Interface: 1bda.).

* Menu:

* XMLReader Objects::
* IncrementalParser Objects::
* Locator Objects::
* InputSource Objects::
* The Attributes Interface::
* The AttributesNS Interface::


File: python.info,  Node: XMLReader Objects,  Next: IncrementalParser Objects,  Up: xml sax xmlreader — Interface for XML parsers

5.19.14.1 XMLReader Objects
...........................

The *Note XMLReader: 1bb1. interface supports the following methods:

 -- Method: XMLReader.parse (source)
     Process an input source, producing SAX events. The `source' object
     can be a system identifier (a string identifying the input source
     – typically a file name or a URL), a file-like object, or an
     *Note InputSource: 1bb6. object. When *Note parse(): 1bf7.
     returns, the input is completely processed, and the parser object
     can be discarded or reset. As a limitation, the current
     implementation only accepts byte streams; processing of character
     streams is for further study.

 -- Method: XMLReader.getContentHandler ()
     Return the current *Note ContentHandler: 1ba3.

 -- Method: XMLReader.setContentHandler (handler)
     Set the current *Note ContentHandler: 1ba3.  If no *Note
     ContentHandler: 1ba3. is set, content events will be discarded.

 -- Method: XMLReader.getDTDHandler ()
     Return the current *Note DTDHandler: 1bc1.

 -- Method: XMLReader.setDTDHandler (handler)
     Set the current *Note DTDHandler: 1bc1.  If no *Note DTDHandler:
     1bc1. is set, DTD events will be discarded.

 -- Method: XMLReader.getEntityResolver ()
     Return the current *Note EntityResolver: 1bc2.

 -- Method: XMLReader.setEntityResolver (handler)
     Set the current *Note EntityResolver: 1bc2.  If no *Note
     EntityResolver: 1bc2. is set, attempts to resolve an external
     entity will result in opening the system identifier for the
     entity, and fail if it is not available.

 -- Method: XMLReader.getErrorHandler ()
     Return the current *Note ErrorHandler: 1bb3.

 -- Method: XMLReader.setErrorHandler (handler)
     Set the current error handler.  If no *Note ErrorHandler: 1bb3.
     is set, errors will be raised as exceptions, and warnings will be
     printed.

 -- Method: XMLReader.setLocale (locale)
     Allow an application to set the locale for errors and warnings.

     SAX parsers are not required to provide localization for errors
     and warnings; if they cannot support the requested locale,
     however, they must raise a SAX exception.  Applications may
     request a locale change in the middle of a parse.

 -- Method: XMLReader.getFeature (featurename)
     Return the current setting for feature `featurename'.  If the
     feature is not recognized, `SAXNotRecognizedException' is raised.
     The well-known featurenames are listed in the module *Note
     xml.sax.handler: 1a7.

 -- Method: XMLReader.setFeature (featurename, value)
     Set the `featurename' to `value'. If the feature is not recognized,
     `SAXNotRecognizedException' is raised. If the feature or its
     setting is not supported by the parser, `SAXNotSupportedException'
     is raised.

 -- Method: XMLReader.getProperty (propertyname)
     Return the current setting for property `propertyname'. If the
     property is not recognized, a `SAXNotRecognizedException' is
     raised. The well-known propertynames are listed in the module
     *Note xml.sax.handler: 1a7.

 -- Method: XMLReader.setProperty (propertyname, value)
     Set the `propertyname' to `value'. If the property is not
     recognized, `SAXNotRecognizedException' is raised. If the property
     or its setting is not supported by the parser,
     `SAXNotSupportedException' is raised.


File: python.info,  Node: IncrementalParser Objects,  Next: Locator Objects,  Prev: XMLReader Objects,  Up: xml sax xmlreader — Interface for XML parsers

5.19.14.2 IncrementalParser Objects
...................................

Instances of *Note IncrementalParser: 1bf6. offer the following
additional methods:

 -- Method: IncrementalParser.feed (data)
     Process a chunk of `data'.

 -- Method: IncrementalParser.close ()
     Assume the end of the document. That will check well-formedness
     conditions that can be checked only at the end, invoke handlers,
     and may clean up resources allocated during parsing.

 -- Method: IncrementalParser.reset ()
     This method is called after close has been called to reset the
     parser so that it is ready to parse new documents. The results of
     calling parse or feed after close without calling reset are
     undefined.


File: python.info,  Node: Locator Objects,  Next: InputSource Objects,  Prev: IncrementalParser Objects,  Up: xml sax xmlreader — Interface for XML parsers

5.19.14.3 Locator Objects
.........................

Instances of *Note Locator: 1bb7. provide these methods:

 -- Method: Locator.getColumnNumber ()
     Return the column number where the current event begins.

 -- Method: Locator.getLineNumber ()
     Return the line number where the current event begins.

 -- Method: Locator.getPublicId ()
     Return the public identifier for the current event.

 -- Method: Locator.getSystemId ()
     Return the system identifier for the current event.


File: python.info,  Node: InputSource Objects,  Next: The Attributes Interface,  Prev: Locator Objects,  Up: xml sax xmlreader — Interface for XML parsers

5.19.14.4 InputSource Objects
.............................

 -- Method: InputSource.setPublicId (id)
     Sets the public identifier of this *Note InputSource: 1bb6.

 -- Method: InputSource.getPublicId ()
     Returns the public identifier of this *Note InputSource: 1bb6.

 -- Method: InputSource.setSystemId (id)
     Sets the system identifier of this *Note InputSource: 1bb6.

 -- Method: InputSource.getSystemId ()
     Returns the system identifier of this *Note InputSource: 1bb6.

 -- Method: InputSource.setEncoding (encoding)
     Sets the character encoding of this *Note InputSource: 1bb6.

     The encoding must be a string acceptable for an XML encoding
     declaration (see section 4.3.3 of the XML recommendation).

     The encoding attribute of the *Note InputSource: 1bb6. is ignored
     if the *Note InputSource: 1bb6. also contains a character stream.

 -- Method: InputSource.getEncoding ()
     Get the character encoding of this InputSource.

 -- Method: InputSource.setByteStream (bytefile)
     Set the byte stream (a Python file-like object which does not
     perform byte-to-character conversion) for this input source.

     The SAX parser will ignore this if there is also a character
     stream specified, but it will use a byte stream in preference to
     opening a URI connection itself.

     If the application knows the character encoding of the byte
     stream, it should set it with the setEncoding method.

 -- Method: InputSource.getByteStream ()
     Get the byte stream for this input source.

     The getEncoding method will return the character encoding for this
     byte stream, or `None' if unknown.

 -- Method: InputSource.setCharacterStream (charfile)
     Set the character stream for this input source. (The stream must
     be a Python 1.6 Unicode-wrapped file-like that performs conversion
     to Unicode strings.)

     If there is a character stream specified, the SAX parser will
     ignore any byte stream and will not attempt to open a URI
     connection to the system identifier.

 -- Method: InputSource.getCharacterStream ()
     Get the character stream for this input source.


File: python.info,  Node: The Attributes Interface,  Next: The AttributesNS Interface,  Prev: InputSource Objects,  Up: xml sax xmlreader — Interface for XML parsers

5.19.14.5 The `Attributes' Interface
....................................

`Attributes' objects implement a portion of the mapping protocol,
including the methods `copy()', `get()', `has_key()', `items()',
`keys()', and `values()'.  The following methods are also provided:

 -- Method: Attributes.getLength ()
     Return the number of attributes.

 -- Method: Attributes.getNames ()
     Return the names of the attributes.

 -- Method: Attributes.getType (name)
     Returns the type of the attribute `name', which is normally
     `'CDATA''.

 -- Method: Attributes.getValue (name)
     Return the value of attribute `name'.


File: python.info,  Node: The AttributesNS Interface,  Prev: The Attributes Interface,  Up: xml sax xmlreader — Interface for XML parsers

5.19.14.6 The `AttributesNS' Interface
......................................

This interface is a subtype of the `Attributes' interface (see section
*Note The Attributes Interface: 1bd8.).  All methods supported by that
interface are also available on `AttributesNS' objects.

The following methods are also available:

 -- Method: AttributesNS.getValueByQName (name)
     Return the value for a qualified name.

 -- Method: AttributesNS.getNameByQName (name)
     Return the `(namespace, localname)' pair for a qualified `name'.

 -- Method: AttributesNS.getQNameByName (name)
     Return the qualified name for a `(namespace, localname)' pair.

 -- Method: AttributesNS.getQNames ()
     Return the qualified names of all attributes.


File: python.info,  Node: xml parsers expat — Fast XML parsing using Expat,  Prev: xml sax xmlreader — Interface for XML parsers,  Up: Structured Markup Processing Tools

5.19.15 `xml.parsers.expat' — Fast XML parsing using Expat
------------------------------------------------------------

     Warning: The `pyexpat' module is not secure against maliciously
     constructed data.  If you need to parse untrusted or
     unauthenticated data see *Note XML vulnerabilities: 1abf.

New in version 2.0.

The *Note xml.parsers.expat: 1a5. module is a Python interface to the
Expat non-validating XML parser. The module provides a single extension
type, `xmlparser', that represents the current state of an XML parser.
After an `xmlparser' object has been created, various attributes of the
object can be set to handler functions.  When an XML document is then
fed to the parser, the handler functions are called for the character
data and markup in the XML document.

This module uses the `pyexpat' module to provide access to the Expat
parser.  Direct use of the `pyexpat' module is deprecated.

This module provides one exception and one type object:

 -- Exception: xml.parsers.expat.ExpatError
     The exception raised when Expat reports an error.  See section
     *Note ExpatError Exceptions: 1c2d. for more information on
     interpreting Expat errors.

 -- Exception: xml.parsers.expat.error
     Alias for *Note ExpatError: 1c2c.

 -- Data: xml.parsers.expat.XMLParserType
     The type of the return values from the *Note ParserCreate(): 1c30.
     function.

The *Note xml.parsers.expat: 1a5. module contains two functions:

 -- Function: xml.parsers.expat.ErrorString (errno)
     Returns an explanatory string for a given error number `errno'.

 -- Function: xml.parsers.expat.ParserCreate ([encoding[,
          namespace_separator]])
     Creates and returns a new `xmlparser' object.   `encoding', if
     specified, must be a string naming the encoding  used by the XML
     data.  Expat doesn’t support as many encodings as Python does,
     and its repertoire of encodings can’t be extended; it supports
     UTF-8, UTF-16, ISO-8859-1 (Latin1), and ASCII.  If `encoding' (1)
     is given it will override the implicit or explicit encoding of the
     document.

     Expat can optionally do XML namespace processing for you, enabled
     by providing a value for `namespace_separator'.  The value must be
     a one-character string; a *Note ValueError: 236. will be raised if
     the string has an illegal length (`None' is considered the same as
     omission).  When namespace processing is enabled, element type
     names and attribute names that belong to a namespace will be
     expanded.  The element name passed to the element handlers
     `StartElementHandler' and `EndElementHandler' will be the
     concatenation of the namespace URI, the namespace separator
     character, and the local part of the name.  If the namespace
     separator is a zero byte (`chr(0)') then the namespace URI and the
     local part will be concatenated without any separator.

     For example, if `namespace_separator' is set to a space character
     (`' '') and the following document is parsed:

         <?xml version="1.0"?>
         <root xmlns    = "http://default-namespace.org/"
               xmlns:py = "http://www.python.org/ns/">
           <py:elem1 />
           <elem2 xmlns="" />
         </root>

     `StartElementHandler' will receive the following strings for each
     element:

         http://default-namespace.org/ root
         http://www.python.org/ns/ elem1
         elem2

     Due to limitations in the `Expat' library used by `pyexpat', the
     `xmlparser' instance returned can only be used to parse a single
     XML document.  Call `ParserCreate' for each document to provide
     unique parser instances.

See also
........

The Expat XML Parser(2)
     Home page of the Expat project.

* Menu:

* XMLParser Objects: XMLParser Objects<2>.
* ExpatError Exceptions::
* Example: Example<11>.
* Content Model Descriptions::
* Expat error constants::

---------- Footnotes ----------

(1) The encoding string included in XML output should conform to the
appropriate standards. For example, “UTF-8” is valid, but
“UTF8” is not. See
<https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl> and
<https://www.iana.org/assignments/character-sets/character-sets.xhtml>.

(2) http://www.libexpat.org/


File: python.info,  Node: XMLParser Objects<2>,  Next: ExpatError Exceptions,  Up: xml parsers expat — Fast XML parsing using Expat

5.19.15.1 XMLParser Objects
...........................

`xmlparser' objects have the following methods:

 -- Method: xmlparser.Parse (data[, isfinal])
     Parses the contents of the string `data', calling the appropriate
     handler functions to process the parsed data.  `isfinal' must be
     true on the final call to this method; it allows the parsing of a
     single file in fragments, not the submission of multiple files.
     `data' can be the empty string at any time.

 -- Method: xmlparser.ParseFile (file)
     Parse XML data reading from the object `file'.  `file' only needs
     to provide the `read(nbytes)' method, returning the empty string
     when there’s no more data.

 -- Method: xmlparser.SetBase (base)
     Sets the base to be used for resolving relative URIs in system
     identifiers in declarations.  Resolving relative identifiers is
     left to the application: this value will be passed through as the
     `base' argument to the *Note ExternalEntityRefHandler(): 1c37,
     *Note NotationDeclHandler(): 1c38, and *Note
     UnparsedEntityDeclHandler(): 1c39. functions.

 -- Method: xmlparser.GetBase ()
     Returns a string containing the base set by a previous call to
     *Note SetBase(): 1c36, or `None' if  *Note SetBase(): 1c36.
     hasn’t been called.

 -- Method: xmlparser.GetInputContext ()
     Returns the input data that generated the current event as a
     string. The data is in the encoding of the entity which contains
     the text. When called while an event handler is not active, the
     return value is `None'.

     New in version 2.1.


 -- Method: xmlparser.ExternalEntityParserCreate (context[, encoding])
     Create a “child” parser which can be used to parse an external
     parsed entity referred to by content parsed by the parent parser.
     The `context' parameter should be the string passed to the *Note
     ExternalEntityRefHandler(): 1c37. handler function, described
     below. The child parser is created with the *Note
     ordered_attributes: 1c3d, *Note returns_unicode: 1c3e. and *Note
     specified_attributes: 1c3f. set to the values of this parser.

 -- Method: xmlparser.SetParamEntityParsing (flag)
     Control parsing of parameter entities (including the external DTD
     subset).  Possible `flag' values are
     `XML_PARAM_ENTITY_PARSING_NEVER',
     `XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE' and
     `XML_PARAM_ENTITY_PARSING_ALWAYS'.  Return true if setting the flag
     was successful.

 -- Method: xmlparser.UseForeignDTD ([flag])
     Calling this with a true value for `flag' (the default) will cause
     Expat to call the *Note ExternalEntityRefHandler: 1c37. with *Note
     None: 3b2. for all arguments to allow an alternate DTD to be
     loaded.  If the document does not contain a document type
     declaration, the *Note ExternalEntityRefHandler: 1c37. will still
     be called, but the *Note StartDoctypeDeclHandler: 1c42. and *Note
     EndDoctypeDeclHandler: 1c43. will not be called.

     Passing a false value for `flag' will cancel a previous call that
     passed a true value, but otherwise has no effect.

     This method can only be called before the *Note Parse(): 1c34. or
     *Note ParseFile(): 1c35.  methods are called; calling it after
     either of those have been called causes *Note ExpatError: 1c2c. to
     be raised with the *Note code: 62. attribute set to
     `errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING'.

     New in version 2.3.


`xmlparser' objects have the following attributes:

 -- Attribute: xmlparser.buffer_size
     The size of the buffer used when *Note buffer_text: 1c45. is true.
     A new buffer size can be set by assigning a new integer value to
     this attribute.  When the size is changed, the buffer will be
     flushed.

     New in version 2.3.

     Changed in version 2.6: The buffer size can now be changed.


 -- Attribute: xmlparser.buffer_text
     Setting this to true causes the `xmlparser' object to buffer
     textual content returned by Expat to avoid multiple calls to the
     *Note CharacterDataHandler(): 1c46. callback whenever possible.
     This can improve performance substantially since Expat normally
     breaks character data into chunks at every line ending.  This
     attribute is false by default, and may be changed at any time.

     New in version 2.3.


 -- Attribute: xmlparser.buffer_used
     If *Note buffer_text: 1c45. is enabled, the number of bytes stored
     in the buffer.  These bytes represent UTF-8 encoded text.  This
     attribute has no meaningful interpretation when *Note buffer_text:
     1c45. is false.

     New in version 2.3.


 -- Attribute: xmlparser.ordered_attributes
     Setting this attribute to a non-zero integer causes the attributes
     to be reported as a list rather than a dictionary.  The attributes
     are presented in the order found in the document text.  For each
     attribute, two list entries are presented: the attribute name and
     the attribute value.  (Older versions of this module also used
     this format.)  By default, this attribute is false; it may be
     changed at any time.

     New in version 2.1.


 -- Attribute: xmlparser.returns_unicode
     If this attribute is set to a non-zero integer, the handler
     functions will be passed Unicode strings.  If *Note
     returns_unicode: 1c3e. is *Note False: 3c9, 8-bit strings
     containing UTF-8 encoded data will be passed to the handlers.
     This is *Note True: 3c8. by default when Python is built with
     Unicode support.

     Changed in version 1.6: Can be changed at any time to affect the
     result type.


 -- Attribute: xmlparser.specified_attributes
     If set to a non-zero integer, the parser will report only those
     attributes which were specified in the document instance and not
     those which were derived from attribute declarations.
     Applications which set this need to be especially careful to use
     what additional information is available from the declarations as
     needed to comply with the standards for the behavior of XML
     processors.  By default, this attribute is false; it may be
     changed at any time.

     New in version 2.1.


The following attributes contain values relating to the most recent
error encountered by an `xmlparser' object, and will only have correct
values once a call to `Parse()' or `ParseFile()' has raised an *Note
xml.parsers.expat.ExpatError: 1c2c. exception.

 -- Attribute: xmlparser.ErrorByteIndex
     Byte index at which an error occurred.

 -- Attribute: xmlparser.ErrorCode
     Numeric code specifying the problem.  This value can be passed to
     the *Note ErrorString(): 1c31. function, or compared to one of the
     constants defined in the `errors' object.

 -- Attribute: xmlparser.ErrorColumnNumber
     Column number at which an error occurred.

 -- Attribute: xmlparser.ErrorLineNumber
     Line number at which an error occurred.

The following attributes contain values relating to the current parse
location in an `xmlparser' object.  During a callback reporting a parse
event they indicate the location of the first of the sequence of
characters that generated the event.  When called outside of a
callback, the position indicated will be just past the last parse event
(regardless of whether there was an associated callback).

New in version 2.4.

 -- Attribute: xmlparser.CurrentByteIndex
     Current byte index in the parser input.

 -- Attribute: xmlparser.CurrentColumnNumber
     Current column number in the parser input.

 -- Attribute: xmlparser.CurrentLineNumber
     Current line number in the parser input.

Here is the list of handlers that can be set.  To set a handler on an
`xmlparser' object `o', use `o.handlername = func'.  `handlername' must
be taken from the following list, and `func' must be a callable object
accepting the correct number of arguments.  The arguments are all
strings, unless otherwise stated.

 -- Method: xmlparser.XmlDeclHandler (version, encoding, standalone)
     Called when the XML declaration is parsed.  The XML declaration is
     the (optional) declaration of the applicable version of the XML
     recommendation, the encoding of the document text, and an optional
     “standalone” declaration.  `version' and `encoding' will be
     strings of the type dictated by the *Note returns_unicode: 1c3e.
     attribute, and `standalone' will be `1' if the document is
     declared standalone, `0' if it is declared not to be standalone,
     or `-1' if the standalone clause was omitted. This is only
     available with Expat version 1.95.0 or newer.

     New in version 2.1.


 -- Method: xmlparser.StartDoctypeDeclHandler (doctypeName, systemId,
          publicId, has_internal_subset)
     Called when Expat begins parsing the document type declaration
     (`<!DOCTYPE ...').  The `doctypeName' is provided exactly as
     presented.  The `systemId' and `publicId' parameters give the
     system and public identifiers if specified, or `None' if omitted.
     `has_internal_subset' will be true if the document contains and
     internal document declaration subset. This requires Expat version
     1.2 or newer.

 -- Method: xmlparser.EndDoctypeDeclHandler ()
     Called when Expat is done parsing the document type declaration.
     This requires Expat version 1.2 or newer.

 -- Method: xmlparser.ElementDeclHandler (name, model)
     Called once for each element type declaration.  `name' is the name
     of the element type, and `model' is a representation of the
     content model.

 -- Method: xmlparser.AttlistDeclHandler (elname, attname, type,
          default, required)
     Called for each declared attribute for an element type.  If an
     attribute list declaration declares three attributes, this handler
     is called three times, once for each attribute.  `elname' is the
     name of the element to which the declaration applies and `attname'
     is the name of the attribute declared.  The attribute type is a
     string passed as `type'; the possible values are `'CDATA'',
     `'ID'', `'IDREF'', … `default' gives the default value for the
     attribute used when the attribute is not specified by the document
     instance, or `None' if there is no default value (`#IMPLIED'
     values).  If the attribute is required to be given in the document
     instance, `required' will be true. This requires Expat version
     1.95.0 or newer.

 -- Method: xmlparser.StartElementHandler (name, attributes)
     Called for the start of every element.  `name' is a string
     containing the element name, and `attributes' is a dictionary
     mapping attribute names to their values.

 -- Method: xmlparser.EndElementHandler (name)
     Called for the end of every element.

 -- Method: xmlparser.ProcessingInstructionHandler (target, data)
     Called for every processing instruction.

 -- Method: xmlparser.CharacterDataHandler (data)
     Called for character data.  This will be called for normal
     character data, CDATA marked content, and ignorable whitespace.
     Applications which must distinguish these cases can use the *Note
     StartCdataSectionHandler: 1c55, *Note EndCdataSectionHandler:
     1c56, and *Note ElementDeclHandler: 1c50. callbacks to collect the
     required information.

 -- Method: xmlparser.UnparsedEntityDeclHandler (entityName, base,
          systemId, publicId, notationName)
     Called for unparsed (NDATA) entity declarations.  This is only
     present for version 1.2 of the Expat library; for more recent
     versions, use *Note EntityDeclHandler: 1c57. instead.  (The
     underlying function in the Expat library has been declared
     obsolete.)

 -- Method: xmlparser.EntityDeclHandler (entityName,
          is_parameter_entity, value, base, systemId, publicId,
          notationName)
     Called for all entity declarations.  For parameter and internal
     entities, `value' will be a string giving the declared contents of
     the entity; this will be `None' for external entities.  The
     `notationName' parameter will be `None' for parsed entities, and
     the name of the notation for unparsed entities.
     `is_parameter_entity' will be true if the entity is a parameter
     entity or false for general entities (most applications only need
     to be concerned with general entities). This is only available
     starting with version 1.95.0 of the Expat library.

     New in version 2.1.


 -- Method: xmlparser.NotationDeclHandler (notationName, base,
          systemId, publicId)
     Called for notation declarations.  `notationName', `base', and
     `systemId', and `publicId' are strings if given.  If the public
     identifier is omitted, `publicId' will be `None'.

 -- Method: xmlparser.StartNamespaceDeclHandler (prefix, uri)
     Called when an element contains a namespace declaration.
     Namespace declarations are processed before the *Note
     StartElementHandler: 1c52. is called for the element on which
     declarations are placed.

 -- Method: xmlparser.EndNamespaceDeclHandler (prefix)
     Called when the closing tag is reached for an element  that
     contained a namespace declaration.  This is called once for each
     namespace declaration on the element in the reverse of the order
     for which the *Note StartNamespaceDeclHandler: 1c58. was called to
     indicate the start of each namespace declaration’s scope.  Calls
     to this handler are made after the corresponding *Note
     EndElementHandler: 1c53. for the end of the element.

 -- Method: xmlparser.CommentHandler (data)
     Called for comments.  `data' is the text of the comment, excluding
     the leading `'<!-'`-'' and trailing `'-'`->''.

 -- Method: xmlparser.StartCdataSectionHandler ()
     Called at the start of a CDATA section.  This and *Note
     EndCdataSectionHandler: 1c56.  are needed to be able to identify
     the syntactical start and end for CDATA sections.

 -- Method: xmlparser.EndCdataSectionHandler ()
     Called at the end of a CDATA section.

 -- Method: xmlparser.DefaultHandler (data)
     Called for any characters in the XML document for which no
     applicable handler has been specified.  This means characters that
     are part of a construct which could be reported, but for which no
     handler has been supplied.

 -- Method: xmlparser.DefaultHandlerExpand (data)
     This is the same as the *Note DefaultHandler(): 1c5b,  but
     doesn’t inhibit expansion of internal entities. The entity
     reference will not be passed to the default handler.

 -- Method: xmlparser.NotStandaloneHandler ()
     Called if the XML document hasn’t been declared as being a
     standalone document.  This happens when there is an external
     subset or a reference to a parameter entity, but the XML
     declaration does not set standalone to `yes' in an XML
     declaration.  If this handler returns `0', then the parser will
     raise an `XML_ERROR_NOT_STANDALONE' error.  If this handler is not
     set, no exception is raised by the parser for this condition.

 -- Method: xmlparser.ExternalEntityRefHandler (context, base,
          systemId, publicId)
     Called for references to external entities.  `base' is the current
     base, as set by a previous call to *Note SetBase(): 1c36.  The
     public and system identifiers, `systemId' and `publicId', are
     strings if given; if the public identifier is not given,
     `publicId' will be `None'.  The `context' value is opaque and
     should only be used as described below.

     For external entities to be parsed, this handler must be
     implemented. It is responsible for creating the sub-parser using
     `ExternalEntityParserCreate(context)', initializing it with the
     appropriate callbacks, and parsing the entity.  This handler
     should return an integer; if it returns `0', the parser will raise
     an `XML_ERROR_EXTERNAL_ENTITY_HANDLING' error, otherwise parsing
     will continue.

     If this handler is not provided, external entities are reported by
     the *Note DefaultHandler: 1c5b. callback, if provided.


File: python.info,  Node: ExpatError Exceptions,  Next: Example<11>,  Prev: XMLParser Objects<2>,  Up: xml parsers expat — Fast XML parsing using Expat

5.19.15.2 ExpatError Exceptions
...............................

*Note ExpatError: 1c2c. exceptions have a number of interesting
attributes:

 -- Attribute: ExpatError.code
     Expat’s internal error number for the specific error.  This will
     match one of the constants defined in the `errors' object from
     this module.

     New in version 2.1.


 -- Attribute: ExpatError.lineno
     Line number on which the error was detected.  The first line is
     numbered `1'.

     New in version 2.1.


 -- Attribute: ExpatError.offset
     Character offset into the line where the error occurred.  The
     first column is numbered `0'.

     New in version 2.1.



File: python.info,  Node: Example<11>,  Next: Content Model Descriptions,  Prev: ExpatError Exceptions,  Up: xml parsers expat — Fast XML parsing using Expat

5.19.15.3 Example
.................

The following program defines three handlers that just print out their
arguments.

    import xml.parsers.expat

    # 3 handler functions
    def start_element(name, attrs):
        print 'Start element:', name, attrs
    def end_element(name):
        print 'End element:', name
    def char_data(data):
        print 'Character data:', repr(data)

    p = xml.parsers.expat.ParserCreate()

    p.StartElementHandler = start_element
    p.EndElementHandler = end_element
    p.CharacterDataHandler = char_data

    p.Parse("""<?xml version="1.0"?>
    <parent id="top"><child1 name="paul">Text goes here</child1>
    <child2 name="fred">More text</child2>
    </parent>""", 1)

The output from this program is:

    Start element: parent {'id': 'top'}
    Start element: child1 {'name': 'paul'}
    Character data: 'Text goes here'
    End element: child1
    Character data: '\n'
    Start element: child2 {'name': 'fred'}
    Character data: 'More text'
    End element: child2
    Character data: '\n'
    End element: parent


File: python.info,  Node: Content Model Descriptions,  Next: Expat error constants,  Prev: Example<11>,  Up: xml parsers expat — Fast XML parsing using Expat

5.19.15.4 Content Model Descriptions
....................................

Content models are described using nested tuples.  Each tuple contains
four values: the type, the quantifier, the name, and a tuple of
children.  Children are simply additional content model descriptions.

The values of the first two fields are constants defined in the `model'
object of the *Note xml.parsers.expat: 1a5. module.  These constants
can be collected in two groups: the model type group and the quantifier
group.

The constants in the model type group are:

 -- Data: xml.parsers.expat.XML_CTYPE_ANY
     The element named by the model name was declared to have a content
     model of `ANY'.

 -- Data: xml.parsers.expat.XML_CTYPE_CHOICE
     The named element allows a choice from a number of options; this
     is used for content models such as `(A | B | C)'.

 -- Data: xml.parsers.expat.XML_CTYPE_EMPTY
     Elements which are declared to be `EMPTY' have this model type.

 -- Data: xml.parsers.expat.XML_CTYPE_MIXED

 -- Data: xml.parsers.expat.XML_CTYPE_NAME

 -- Data: xml.parsers.expat.XML_CTYPE_SEQ
     Models which represent a series of models which follow one after
     the other are indicated with this model type.  This is used for
     models such as `(A, B, C)'.

The constants in the quantifier group are:

 -- Data: xml.parsers.expat.XML_CQUANT_NONE
     No modifier is given, so it can appear exactly once, as for `A'.

 -- Data: xml.parsers.expat.XML_CQUANT_OPT
     The model is optional: it can appear once or not at all, as for
     `A?'.

 -- Data: xml.parsers.expat.XML_CQUANT_PLUS
     The model must occur one or more times (like `A+').

 -- Data: xml.parsers.expat.XML_CQUANT_REP
     The model must occur zero or more times, as for `A*'.


File: python.info,  Node: Expat error constants,  Prev: Content Model Descriptions,  Up: xml parsers expat — Fast XML parsing using Expat

5.19.15.5 Expat error constants
...............................

The following constants are provided in the `errors' object of the
*Note xml.parsers.expat: 1a5. module.  These constants are useful in
interpreting some of the attributes of the *Note ExpatError: 1c2c.
exception objects raised when an error has occurred.

The `errors' object has the following attributes:

 -- Data: xml.parsers.expat.XML_ERROR_ASYNC_ENTITY

 -- Data: xml.parsers.expat.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF
     An entity reference in an attribute value referred to an external
     entity instead of an internal entity.

 -- Data: xml.parsers.expat.XML_ERROR_BAD_CHAR_REF
     A character reference referred to a character which is illegal in
     XML (for example, character `0', or ‘`&#0;'’).

 -- Data: xml.parsers.expat.XML_ERROR_BINARY_ENTITY_REF
     An entity reference referred to an entity which was declared with
     a notation, so cannot be parsed.

 -- Data: xml.parsers.expat.XML_ERROR_DUPLICATE_ATTRIBUTE
     An attribute was used more than once in a start tag.

 -- Data: xml.parsers.expat.XML_ERROR_INCORRECT_ENCODING

 -- Data: xml.parsers.expat.XML_ERROR_INVALID_TOKEN
     Raised when an input byte could not properly be assigned to a
     character; for example, a NUL byte (value `0') in a UTF-8 input
     stream.

 -- Data: xml.parsers.expat.XML_ERROR_JUNK_AFTER_DOC_ELEMENT
     Something other than whitespace occurred after the document
     element.

 -- Data: xml.parsers.expat.XML_ERROR_MISPLACED_XML_PI
     An XML declaration was found somewhere other than the start of the
     input data.

 -- Data: xml.parsers.expat.XML_ERROR_NO_ELEMENTS
     The document contains no elements (XML requires all documents to
     contain exactly one top-level element)..

 -- Data: xml.parsers.expat.XML_ERROR_NO_MEMORY
     Expat was not able to allocate memory internally.

 -- Data: xml.parsers.expat.XML_ERROR_PARAM_ENTITY_REF
     A parameter entity reference was found where it was not allowed.

 -- Data: xml.parsers.expat.XML_ERROR_PARTIAL_CHAR
     An incomplete character was found in the input.

 -- Data: xml.parsers.expat.XML_ERROR_RECURSIVE_ENTITY_REF
     An entity reference contained another reference to the same
     entity; possibly via a different name, and possibly indirectly.

 -- Data: xml.parsers.expat.XML_ERROR_SYNTAX
     Some unspecified syntax error was encountered.

 -- Data: xml.parsers.expat.XML_ERROR_TAG_MISMATCH
     An end tag did not match the innermost open start tag.

 -- Data: xml.parsers.expat.XML_ERROR_UNCLOSED_TOKEN
     Some token (such as a start tag) was not closed before the end of
     the stream or the next token was encountered.

 -- Data: xml.parsers.expat.XML_ERROR_UNDEFINED_ENTITY
     A reference was made to an entity which was not defined.

 -- Data: xml.parsers.expat.XML_ERROR_UNKNOWN_ENCODING
     The document encoding is not supported by Expat.

 -- Data: xml.parsers.expat.XML_ERROR_UNCLOSED_CDATA_SECTION
     A CDATA marked section was not closed.

 -- Data: xml.parsers.expat.XML_ERROR_EXTERNAL_ENTITY_HANDLING

 -- Data: xml.parsers.expat.XML_ERROR_NOT_STANDALONE
     The parser determined that the document was not “standalone”
     though it declared itself to be in the XML declaration, and the
     `NotStandaloneHandler' was set and returned `0'.

 -- Data: xml.parsers.expat.XML_ERROR_UNEXPECTED_STATE

 -- Data: xml.parsers.expat.XML_ERROR_ENTITY_DECLARED_IN_PE

 -- Data: xml.parsers.expat.XML_ERROR_FEATURE_REQUIRES_XML_DTD
     An operation was requested that requires DTD support to be
     compiled in, but Expat was configured without DTD support.  This
     should never be reported by a standard build of the *Note
     xml.parsers.expat: 1a5. module.

 -- Data: xml.parsers.expat.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING
     A behavioral change was requested after parsing started that can
     only be changed before parsing has started.  This is (currently)
     only raised by `UseForeignDTD()'.

 -- Data: xml.parsers.expat.XML_ERROR_UNBOUND_PREFIX
     An undeclared prefix was found when namespace processing was
     enabled.

 -- Data: xml.parsers.expat.XML_ERROR_UNDECLARING_PREFIX
     The document attempted to remove the namespace declaration
     associated with a prefix.

 -- Data: xml.parsers.expat.XML_ERROR_INCOMPLETE_PE
     A parameter entity contained incomplete markup.

 -- Data: xml.parsers.expat.XML_ERROR_XML_DECL
     The document contained no document element at all.

 -- Data: xml.parsers.expat.XML_ERROR_TEXT_DECL
     There was an error parsing a text declaration in an external
     entity.

 -- Data: xml.parsers.expat.XML_ERROR_PUBLICID
     Characters were found in the public id that are not allowed.

 -- Data: xml.parsers.expat.XML_ERROR_SUSPENDED
     The requested operation was made on a suspended parser, but
     isn’t allowed.  This includes attempts to provide additional
     input or to stop the parser.

 -- Data: xml.parsers.expat.XML_ERROR_NOT_SUSPENDED
     An attempt to resume the parser was made when the parser had not
     been suspended.

 -- Data: xml.parsers.expat.XML_ERROR_ABORTED
     This should not be reported to Python applications.

 -- Data: xml.parsers.expat.XML_ERROR_FINISHED
     The requested operation was made on a parser which was finished
     parsing input, but isn’t allowed.  This includes attempts to
     provide additional input or to stop the parser.

 -- Data: xml.parsers.expat.XML_ERROR_SUSPEND_PE


File: python.info,  Node: Internet Protocols and Support,  Next: Multimedia Services,  Prev: Structured Markup Processing Tools,  Up: The Python Standard Library

5.20 Internet Protocols and Support
===================================

The modules described in this chapter implement Internet protocols and
support for related technology.  They are all implemented in Python.
Most of these modules require the presence of the system-dependent
module *Note socket: 15c, which is currently supported on most popular
platforms.  Here is an overview:

* Menu:

* webbrowser — Convenient Web-browser controller::
* cgi — Common Gateway Interface support::
* cgitb — Traceback manager for CGI scripts::
* wsgiref — WSGI Utilities and Reference Implementation::
* urllib — Open arbitrary resources by URL::
* urllib2 — extensible library for opening URLs::
* httplib — HTTP protocol client::
* ftplib — FTP protocol client::
* poplib — POP3 protocol client::
* imaplib — IMAP4 protocol client::
* nntplib — NNTP protocol client::
* smtplib — SMTP protocol client::
* smtpd — SMTP Server::
* telnetlib — Telnet client::
* uuid — UUID objects according to RFC 4122::
* urlparse — Parse URLs into components::
* SocketServer — A framework for network servers::
* BaseHTTPServer — Basic HTTP server::
* SimpleHTTPServer — Simple HTTP request handler::
* CGIHTTPServer — CGI-capable HTTP request handler::
* cookielib — Cookie handling for HTTP clients::
* Cookie — HTTP state management::
* xmlrpclib — XML-RPC client access::
* SimpleXMLRPCServer — Basic XML-RPC server::
* DocXMLRPCServer — Self-documenting XML-RPC server::


File: python.info,  Node: webbrowser — Convenient Web-browser controller,  Next: cgi — Common Gateway Interface support,  Up: Internet Protocols and Support

5.20.1 `webbrowser' — Convenient Web-browser controller
---------------------------------------------------------

`Source code:' Lib/webbrowser.py(1)

__________________________________________________________________

The *Note webbrowser: 196. module provides a high-level interface to
allow displaying Web-based documents to users. Under most
circumstances, simply calling the *Note open(): 1c6d. function from
this module will do the right thing.

Under Unix, graphical browsers are preferred under X11, but text-mode
browsers will be used if graphical browsers are not available or an X11
display isn’t available.  If text-mode browsers are used, the calling
process will block until the user exits the browser.

If the environment variable `BROWSER' exists, it is interpreted to
override the platform default list of browsers, as an *Note os.pathsep:
678.-separated list of browsers to try in order.  When the value of a
list part contains the string `%s', then it is  interpreted as a
literal browser command line to be used with the argument URL
substituted for `%s'; if the part does not contain `%s', it is simply
interpreted as the name of the browser to launch. (2)

For non-Unix platforms, or when a remote browser is available on Unix,
the controlling process will not wait for the user to finish with the
browser, but allow the remote browser to maintain its own windows on
the display.  If remote browsers are not available on Unix, the
controlling process will launch a new browser and wait.

The script `webbrowser' can be used as a command-line interface for the
module. It accepts a URL as the argument. It accepts the following
optional parameters: `-n' opens the URL in a new browser window, if
possible; `-t' opens the URL in a new browser page (“tab”). The
options are, naturally, mutually exclusive.  Usage example:

    python -m webbrowser -t "http://www.python.org"

The following exception is defined:

 -- Exception: webbrowser.Error
     Exception raised when a browser control error occurs.

The following functions are defined:

 -- Function: webbrowser.open (url, new=0, autoraise=True)
     Display `url' using the default browser. If `new' is 0, the `url'
     is opened in the same browser window if possible.  If `new' is 1,
     a new browser window is opened if possible.  If `new' is 2, a new
     browser page (“tab”) is opened if possible.  If `autoraise' is
     `True', the window is raised if possible (note that under many
     window managers this will occur regardless of the setting of this
     variable).

     Note that on some platforms, trying to open a filename using this
     function, may work and start the operating system’s associated
     program.  However, this is neither supported nor portable.

     Changed in version 2.5: `new' can now be 2.


 -- Function: webbrowser.open_new (url)
     Open `url' in a new window of the default browser, if possible,
     otherwise, open `url' in the only browser window.

 -- Function: webbrowser.open_new_tab (url)
     Open `url' in a new page (“tab”) of the default browser, if
     possible, otherwise equivalent to *Note open_new(): 1c6f.

     New in version 2.5.


 -- Function: webbrowser.get ([name])
     Return a controller object for the browser type `name'.  If `name'
     is empty, return a controller for a default browser appropriate to
     the caller’s environment.

 -- Function: webbrowser.register (name, constructor[, instance])
     Register the browser type `name'.  Once a browser type is
     registered, the *Note get(): 1c71. function can return a
     controller for that browser type.  If `instance' is not provided,
     or is `None', `constructor' will be called without parameters to
     create an instance when needed.  If `instance' is provided,
     `constructor' will never be called, and may be `None'.

     This entry point is only useful if you plan to either set the `BROWSER'
     variable or call *Note get(): 1c71. with a nonempty argument
     matching the name of a handler you declare.

A number of browser types are predefined.  This table gives the type
names that may be passed to the *Note get(): 1c71. function and the
corresponding instantiations for the controller classes, all defined in
this module.

Type Name                   Class Name                                    Notes
-------------------------------------------------------------------------------------- 
`'mozilla''                 `Mozilla('mozilla')'                          
`'firefox''                 `Mozilla('mozilla')'                          
`'netscape''                `Mozilla('netscape')'                         
`'galeon''                  `Galeon('galeon')'                            
`'epiphany''                `Galeon('epiphany')'                          
`'skipstone''               `BackgroundBrowser('skipstone')'              
`'kfmclient''               `Konqueror()'                                 (1)
`'konqueror''               `Konqueror()'                                 (1)
`'kfm''                     `Konqueror()'                                 (1)
`'mosaic''                  `BackgroundBrowser('mosaic')'                 
`'opera''                   `Opera()'                                     
`'grail''                   `Grail()'                                     
`'links''                   `GenericBrowser('links')'                     
`'elinks''                  `Elinks('elinks')'                            
`'lynx''                    `GenericBrowser('lynx')'                      
`'w3m''                     `GenericBrowser('w3m')'                       
`'windows-default''         `WindowsDefault'                              (2)
`'macosx''                  `MacOSX('default')'                           (3)
`'safari''                  `MacOSX('safari')'                            (3)
`'google-chrome''           `Chrome('google-chrome')'                     (4)
`'chrome''                  `Chrome('chrome')'                            (4)
`'chromium''                `Chromium('chromium')'                        (4)
`'chromium-browser''        `Chromium('chromium-browser')'                (4)

Notes:

  1. “Konqueror” is the file manager for the KDE desktop
     environment for Unix, and only makes sense to use if KDE is
     running.  Some way of reliably detecting KDE would be nice; the `KDEDIR'
     variable is not sufficient.  Note also that the name “kfm” is
     used even when using the `konqueror' command with KDE 2 — the
     implementation selects the best strategy for running Konqueror.

  2. Only on Windows platforms.

  3. Only on Mac OS X platform.

  4. Support for Chrome/Chromium has been added in version 2.7.5.

Here are some simple examples:

    url = 'http://www.python.org/'

    # Open URL in a new tab, if a browser window is already open.
    webbrowser.open_new_tab(url + 'doc/')

    # Open URL in new window, raising the window if possible.
    webbrowser.open_new(url)

* Menu:

* Browser Controller Objects::

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/webbrowser.py

(2) Executables named here without a full path will be searched in the
directories given in the `PATH' environment variable.


File: python.info,  Node: Browser Controller Objects,  Up: webbrowser — Convenient Web-browser controller

5.20.1.1 Browser Controller Objects
...................................

Browser controllers provide these methods which parallel three of the
module-level convenience functions:

 -- Method: controller.open (url, new=0, autoraise=True)
     Display `url' using the browser handled by this controller. If
     `new' is 1, a new browser window is opened if possible. If `new'
     is 2, a new browser page (“tab”) is opened if possible.

 -- Method: controller.open_new (url)
     Open `url' in a new window of the browser handled by this
     controller, if possible, otherwise, open `url' in the only browser
     window.  Alias *Note open_new(): 1c6f.

 -- Method: controller.open_new_tab (url)
     Open `url' in a new page (“tab”) of the browser handled by
     this controller, if possible, otherwise equivalent to *Note
     open_new(): 1c6f.

     New in version 2.5.



File: python.info,  Node: cgi — Common Gateway Interface support,  Next: cgitb — Traceback manager for CGI scripts,  Prev: webbrowser — Convenient Web-browser controller,  Up: Internet Protocols and Support

5.20.2 `cgi' — Common Gateway Interface support
-------------------------------------------------

`Source code:' Lib/cgi.py(1)

__________________________________________________________________

Support module for Common Gateway Interface (CGI) scripts.

This module defines a number of utilities for use by CGI scripts
written in Python.

* Menu:

* Introduction: Introduction<8>.
* Using the cgi module::
* Higher Level Interface::
* Old classes::
* Functions: Functions<5>.
* Caring about security::
* Installing your CGI script on a Unix system::
* Testing your CGI script::
* Debugging CGI scripts::
* Common problems and solutions::

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/cgi.py


File: python.info,  Node: Introduction<8>,  Next: Using the cgi module,  Up: cgi — Common Gateway Interface support

5.20.2.1 Introduction
.....................

A CGI script is invoked by an HTTP server, usually to process user input
submitted through an HTML `<FORM>' or `<ISINDEX>' element.

Most often, CGI scripts live in the server’s special `cgi-bin'
directory.  The HTTP server places all sorts of information about the
request (such as the client’s hostname, the requested URL, the query
string, and lots of other goodies) in the script’s shell environment,
executes the script, and sends the script’s output back to the client.

The script’s input is connected to the client too, and sometimes the
form data is read this way; at other times the form data is passed via
the “query string” part of the URL.  This module is intended to
take care of the different cases and provide a simpler interface to the
Python script.  It also provides a number of utilities that help in
debugging scripts, and the latest addition is support for file uploads
from a form (if your browser supports it).

The output of a CGI script should consist of two sections, separated by
a blank line.  The first section contains a number of headers, telling
the client what kind of data is following.  Python code to generate a
minimal header section looks like this:

    print "Content-Type: text/html"     # HTML is following
    print                               # blank line, end of headers

The second section is usually HTML, which allows the client software to
display nicely formatted text with header, in-line images, etc.
Here’s Python code that prints a simple piece of HTML:

    print "<TITLE>CGI script output</TITLE>"
    print "<H1>This is my first CGI script</H1>"
    print "Hello, world!"


File: python.info,  Node: Using the cgi module,  Next: Higher Level Interface,  Prev: Introduction<8>,  Up: cgi — Common Gateway Interface support

5.20.2.2 Using the cgi module
.............................

Begin by writing `import cgi'.  Do not use `from cgi import *' — the
module defines all sorts of names for its own use or for backward
compatibility that you don’t want in your namespace.

When you write a new script, consider adding these lines:

    import cgitb
    cgitb.enable()

This activates a special exception handler that will display detailed
reports in the Web browser if any errors occur.  If you’d rather not
show the guts of your program to users of your script, you can have the
reports saved to files instead, with code like this:

    import cgitb
    cgitb.enable(display=0, logdir="/path/to/logdir")

It’s very helpful to use this feature during script development. The
reports produced by *Note cgitb: 5e. provide information that can save
you a lot of time in tracking down bugs.  You can always remove the
`cgitb' line later when you have tested your script and are confident
that it works correctly.

To get at submitted form data, it’s best to use the `FieldStorage'
class.  The other classes defined in this module are provided mostly
for backward compatibility. Instantiate it exactly once, without
arguments.  This reads the form contents from standard input or the
environment (depending on the value of various environment variables
set according to the CGI standard).  Since it may consume standard
input, it should be instantiated only once.

The `FieldStorage' instance can be indexed like a Python dictionary.
It allows membership testing with the *Note in: 441. operator, and also
supports the standard dictionary method *Note keys(): 1e1. and the
built-in function *Note len(): 53c.  Form fields containing empty
strings are ignored and do not appear in the dictionary; to keep such
values, provide a true value for the optional `keep_blank_values'
keyword parameter when creating the `FieldStorage' instance.

For instance, the following code (which assumes that the `Content-Type'
header and blank line have already been printed) checks that the fields
`name' and `addr' are both set to a non-empty string:

    form = cgi.FieldStorage()
    if "name" not in form or "addr" not in form:
        print "<H1>Error</H1>"
        print "Please fill in the name and addr fields."
        return
    print "<p>name:", form["name"].value
    print "<p>addr:", form["addr"].value
    ...further form processing here...

Here the fields, accessed through `form[key]', are themselves instances
of `FieldStorage' (or `MiniFieldStorage', depending on the form
encoding). The `value' attribute of the instance yields the string
value of the field.  The `getvalue()' method returns this string value
directly; it also accepts an optional second argument as a default to
return if the requested key is not present.

If the submitted form data contains more than one field with the same
name, the object retrieved by `form[key]' is not a `FieldStorage' or
`MiniFieldStorage' instance but a list of such instances.  Similarly, in
this situation, `form.getvalue(key)' would return a list of strings. If
you expect this possibility (when your HTML form contains multiple
fields with the same name), use the *Note getlist(): 1c7e. method,
which always returns a list of values (so that you do not need to
special-case the single item case).  For example, this code
concatenates any number of username fields, separated by commas:

    value = form.getlist("username")
    usernames = ",".join(value)

If a field represents an uploaded file, accessing the value via the
`value' attribute or the `getvalue()' method reads the entire file in
memory as a string.  This may not be what you want. You can test for an
uploaded file by testing either the `filename' attribute or the `file'
attribute.  You can then read the data at leisure from the `file'
attribute:

    fileitem = form["userfile"]
    if fileitem.file:
        # It's an uploaded file; count lines
        linecount = 0
        while 1:
            line = fileitem.file.readline()
            if not line: break
            linecount = linecount + 1

If an error is encountered when obtaining the contents of an uploaded
file (for example, when the user interrupts the form submission by
clicking on a Back or Cancel button) the `done' attribute of the object
for the field will be set to the value -1.

The file upload draft standard entertains the possibility of uploading
multiple files from one field (using a recursive `multipart/*'
encoding).  When this occurs, the item will be a dictionary-like
`FieldStorage' item.  This can be determined by testing its `type'
attribute, which should be `multipart/form-data' (or perhaps another
MIME type matching `multipart/*').  In this case, it can be iterated
over recursively just like the top-level form object.

When a form is submitted in the “old” format (as the query string
or as a single data part of type `application/x-www-form-urlencoded'),
the items will actually be instances of the class `MiniFieldStorage'.
In this case, the `list', `file', and `filename' attributes are always
`None'.

A form submitted via POST that also has a query string will contain both
`FieldStorage' and `MiniFieldStorage' items.


File: python.info,  Node: Higher Level Interface,  Next: Old classes,  Prev: Using the cgi module,  Up: cgi — Common Gateway Interface support

5.20.2.3 Higher Level Interface
...............................

New in version 2.2.

The previous section explains how to read CGI form data using the
`FieldStorage' class.  This section describes a higher level interface
which was added to this class to allow one to do it in a more readable
and intuitive way.  The interface doesn’t make the techniques
described in previous sections obsolete — they are still useful to
process file uploads efficiently, for example.

The interface consists of two simple methods. Using the methods you can
process form data in a generic way, without the need to worry whether
only one or more values were posted under one name.

In the previous section, you learned to write following code anytime you
expected a user to post more than one value under one name:

    item = form.getvalue("item")
    if isinstance(item, list):
        # The user is requesting more than one item.
    else:
        # The user is requesting only one item.

This situation is common for example when a form contains a group of
multiple checkboxes with the same name:

    <input type="checkbox" name="item" value="1" />
    <input type="checkbox" name="item" value="2" />

In most situations, however, there’s only one form control with a
particular name in a form and then you expect and need only one value
associated with this name.  So you write a script containing for
example this code:

    user = form.getvalue("user").upper()

The problem with the code is that you should never expect that a client
will provide valid input to your scripts.  For example, if a curious
user appends another `user=foo' pair to the query string, then the
script would crash, because in this situation the `getvalue("user")'
method call returns a list instead of a string.  Calling the *Note
upper(): 907. method on a list is not valid (since lists do not have a
method of this name) and results in an *Note AttributeError: 1f8.
exception.

Therefore, the appropriate way to read form data values was to always
use the code which checks whether the obtained value is a single value
or a list of values.  That’s annoying and leads to less readable
scripts.

A more convenient approach is to use the methods *Note getfirst(): 1c80.
and *Note getlist(): 1c7e. provided by this higher level interface.

 -- Method: FieldStorage.getfirst (name[, default])
     This method always returns only one value associated with form
     field `name'.  The method returns only the first value in case
     that more values were posted under such name.  Please note that
     the order in which the values are received may vary from browser
     to browser and should not be counted on. (1)  If no such form
     field or value exists then the method returns the value specified
     by the optional parameter `default'.  This parameter defaults to
     `None' if not specified.

 -- Method: FieldStorage.getlist (name)
     This method always returns a list of values associated with form
     field `name'.  The method returns an empty list if no such form
     field or value exists for `name'.  It returns a list consisting of
     one item if only one such value exists.

Using these methods you can write nice compact code:

    import cgi
    form = cgi.FieldStorage()
    user = form.getfirst("user", "").upper()    # This way it's safe.
    for item in form.getlist("item"):
        do_something(item)

---------- Footnotes ----------

(1) Note that some recent versions of the HTML specification do state
what order the field values should be supplied in, but knowing whether
a request was received from a conforming browser, or even from a
browser at all, is tedious and error-prone.


File: python.info,  Node: Old classes,  Next: Functions<5>,  Prev: Higher Level Interface,  Up: cgi — Common Gateway Interface support

5.20.2.4 Old classes
....................

Deprecated since version 2.6: These classes, present in earlier
versions of the *Note cgi: 5c. module, are still supported for backward
compatibility.  New applications should use the `FieldStorage' class.

`SvFormContentDict' stores single value form content as dictionary; it
assumes each field name occurs in the form only once.

`FormContentDict' stores multiple value form content as a dictionary
(the form items are lists of values).  Useful if your form contains
multiple fields with the same name.

Other classes (`FormContent', `InterpFormContentDict') are present for
backwards compatibility with really old applications only.


File: python.info,  Node: Functions<5>,  Next: Caring about security,  Prev: Old classes,  Up: cgi — Common Gateway Interface support

5.20.2.5 Functions
..................

These are useful if you want more control, or if you want to employ
some of the algorithms implemented in this module in other
circumstances.

 -- Function: cgi.parse (fp[, environ[, keep_blank_values[,
          strict_parsing]]])
     Parse a query in the environment or from a file (the file defaults
     to `sys.stdin' and environment defaults to `os.environ').  The
     `keep_blank_values' and `strict_parsing' parameters are passed to
     *Note urlparse.parse_qs(): 1c85. unchanged.

 -- Function: cgi.parse_qs (qs[, keep_blank_values[, strict_parsing]])
     This function is deprecated in this module. Use *Note
     urlparse.parse_qs(): 1c85.  instead. It is maintained here only
     for backward compatibility.

 -- Function: cgi.parse_qsl (qs[, keep_blank_values[, strict_parsing]])
     This function is deprecated in this module. Use *Note
     urlparse.parse_qsl(): 1c88.  instead. It is maintained here only
     for backward compatibility.

 -- Function: cgi.parse_multipart (fp, pdict)
     Parse input of type `multipart/form-data' (for  file uploads).
     Arguments are `fp' for the input file and `pdict' for a dictionary
     containing other parameters in the `Content-Type' header.

     Returns a dictionary just like *Note urlparse.parse_qs(): 1c85.
     keys are the field names, each value is a list of values for that
     field.  This is easy to use but not much good if you are expecting
     megabytes to be uploaded — in that case, use the `FieldStorage'
     class instead which is much more flexible.

     Note that this does not parse nested multipart parts — use
     `FieldStorage' for that.

 -- Function: cgi.parse_header (string)
     Parse a MIME header (such as `Content-Type') into a main value and
     a dictionary of parameters.

 -- Function: cgi.test ()
     Robust test CGI script, usable as main program. Writes minimal
     HTTP headers and formats all information provided to the script in
     HTML form.

 -- Function: cgi.print_environ ()
     Format the shell environment in HTML.

 -- Function: cgi.print_form (form)
     Format a form in HTML.

 -- Function: cgi.print_directory ()
     Format the current directory in HTML.

 -- Function: cgi.print_environ_usage ()
     Print a list of useful (used by CGI) environment variables in HTML.

 -- Function: cgi.escape (s[, quote])
     Convert the characters `'&'', `'<'' and `'>'' in string `s' to
     HTML-safe sequences.  Use this if you need to display text that
     might contain such characters in HTML.  If the optional flag
     `quote' is true, the quotation mark character (`"') is also
     translated; this helps for inclusion in an HTML attribute value
     delimited by double quotes, as in `<a href="...">'.  Note that
     single quotes are never translated.

     If the value to be quoted might include single- or double-quote
     characters, or both, consider using the *Note quoteattr(): 1bf0.
     function in the *Note xml.sax.saxutils: 1a8. module instead.


File: python.info,  Node: Caring about security,  Next: Installing your CGI script on a Unix system,  Prev: Functions<5>,  Up: cgi — Common Gateway Interface support

5.20.2.6 Caring about security
..............................

There’s one important rule: if you invoke an external program (via the
*Note os.system(): 413. or *Note os.popen(): 728. functions. or others
with similar functionality), make very sure you don’t pass arbitrary
strings received from the client to the shell.  This is a well-known
security hole whereby clever hackers anywhere on the Web can exploit a
gullible CGI script to invoke arbitrary shell commands.  Even parts of
the URL or field names cannot be trusted, since the request doesn’t
have to come from your form!

To be on the safe side, if you must pass a string gotten from a form to
a shell command, you should make sure the string contains only
alphanumeric characters, dashes, underscores, and periods.

