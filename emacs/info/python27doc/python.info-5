This is python.info, produced by makeinfo version 4.8 from python.texi.

Generated by Sphinx 1.6.3.
INFO-DIR-SECTION Python
START-INFO-DIR-ENTRY
* Python: (python.info). The Python reference manual.
END-INFO-DIR-ENTRY

     Python 2.7.13, July 15, 2017

     Copyright (C) 1990-2017, Python Software Foundation


File: python.info,  Node: New-style and classic classes,  Next: Special method names,  Prev: The standard type hierarchy,  Up: Data model

4.3.3 New-style and classic classes
-----------------------------------

Classes and instances come in two flavors: old-style (or classic) and
new-style.

Up to Python 2.1 the concept of `class' was unrelated to the concept of
`type', and old-style classes were the only flavor available.  For an
old-style class, the statement `x.__class__' provides the class of `x',
but `type(x)' is always `<type 'instance'>'.  This reflects the fact
that all old-style instances, independent of their class, are
implemented with a single built-in type, called `instance'.

New-style classes were introduced in Python 2.2 to unify the concepts of
`class' and `type'.  A new-style class is simply a user-defined type,
no more, no less.  If `x' is an instance of a new-style class, then
`type(x)' is typically the same as `x.__class__' (although this is not
guaranteed – a new-style class instance is permitted to override the
value returned for `x.__class__').

The major motivation for introducing new-style classes is to provide a
unified object model with a full meta-model.  It also has a number of
practical benefits, like the ability to subclass most built-in types,
or the introduction of “descriptors”, which enable computed
properties.

For compatibility reasons, classes are still old-style by default.
New-style classes are created by specifying another new-style class
(i.e. a type) as a parent class, or the “top-level type” *Note
object: 1f1. if no other parent is needed.  The behaviour of new-style
classes differs from that of old-style classes in a number of important
details in addition to what *Note type(): 4ac.  returns.  Some of these
changes are fundamental to the new object model, like the way special
methods are invoked.  Others are “fixes” that could not be
implemented before for compatibility concerns, like the method
resolution order in case of multiple inheritance.

While this manual aims to provide comprehensive coverage of Python’s
class mechanics, it may still be lacking in some areas when it comes to
its coverage of new-style classes. Please see
<https://www.python.org/doc/newstyle/> for sources of additional
information.

Old-style classes are removed in Python 3, leaving only new-style
classes.


File: python.info,  Node: Special method names,  Prev: New-style and classic classes,  Up: Data model

4.3.4 Special method names
--------------------------

A class can implement certain operations that are invoked by special
syntax (such as arithmetic operations or subscripting and slicing) by
defining methods with special names. This is Python’s approach to
`operator overloading', allowing classes to define their own behavior
with respect to language operators.  For instance, if a class defines a
method named *Note __getitem__(): 468, and `x' is an instance of this
class, then `x[i]' is roughly equivalent to `x.__getitem__(i)' for
old-style classes and `type(x).__getitem__(x, i)' for new-style
classes.  Except where mentioned, attempts to execute an operation
raise an exception when no appropriate method is defined (typically
*Note AttributeError: 1f8. or *Note TypeError: 218.).

When implementing a class that emulates any built-in type, it is
important that the emulation only be implemented to the degree that it
makes sense for the object being modelled.  For example, some sequences
may work well with retrieval of individual elements, but extracting a
slice may not make sense.  (One example of this is the `NodeList'
interface in the W3C’s Document Object Model.)

* Menu:

* Basic customization::
* Customizing attribute access::
* Customizing class creation::
* Customizing instance and subclass checks::
* Emulating callable objects::
* Emulating container types::
* Additional methods for emulation of sequence types::
* Emulating numeric types::
* Coercion rules::
* With Statement Context Managers::
* Special method lookup for old-style classes::
* Special method lookup for new-style classes::


File: python.info,  Node: Basic customization,  Next: Customizing attribute access,  Up: Special method names

4.3.4.1 Basic customization
...........................

 -- Method: object.__new__ (cls[, ...])
     Called to create a new instance of class `cls'.  *Note __new__():
     724. is a static method (special-cased so you need not declare it
     as such) that takes the class of which an instance was requested
     as its first argument.  The remaining arguments are those passed
     to the object constructor expression (the call to the class).  The
     return value of *Note __new__(): 724. should be the new object
     instance (usually an instance of `cls').

     Typical implementations create a new instance of the class by
     invoking the superclass’s *Note __new__(): 724. method using
     `super(currentclass, cls).__new__(cls[, ...])' with appropriate
     arguments and then modifying the newly-created instance as
     necessary before returning it.

     If *Note __new__(): 724. returns an instance of `cls', then the
     new instance’s *Note __init__(): 394. method will be invoked
     like `__init__(self[, ...])', where `self' is the new instance and
     the remaining arguments are the same as were passed to *Note
     __new__(): 724.

     If *Note __new__(): 724. does not return an instance of `cls',
     then the new instance’s *Note __init__(): 394. method will not
     be invoked.

     *Note __new__(): 724. is intended mainly to allow subclasses of
     immutable types (like int, str, or tuple) to customize instance
     creation.  It is also commonly overridden in custom metaclasses in
     order to customize class creation.

 -- Method: object.__init__ (self[, ...])
     Called after the instance has been created (by *Note __new__():
     724.), but before it is returned to the caller.  The arguments are
     those passed to the class constructor expression.  If a base class
     has an *Note __init__(): 394. method, the derived class’s *Note
     __init__(): 394. method, if any, must explicitly call it to ensure
     proper initialization of the base class part of the instance; for
     example: `BaseClass.__init__(self, [args...])'.

     Because *Note __new__(): 724. and *Note __init__(): 394. work
     together in constructing objects (*Note __new__(): 724. to create
     it, and *Note __init__(): 394. to customise it), no non-`None'
     value may be returned by *Note __init__(): 394.; doing so will
     cause a *Note TypeError: 218. to be raised at runtime.

 -- Method: object.__del__ (self)
     Called when the instance is about to be destroyed.  This is also
     called a destructor.  If a base class has a *Note __del__(): 731.
     method, the derived class’s *Note __del__(): 731. method, if
     any, must explicitly call it to ensure proper deletion of the base
     class part of the instance.  Note that it is possible (though not
     recommended!) for the *Note __del__(): 731. method to postpone
     destruction of the instance by creating a new reference to it.  It
     may then be called at a later time when this new reference is
     deleted.  It is not guaranteed that *Note __del__(): 731. methods
     are called for objects that still exist when the interpreter exits.

          Note: `del x' doesn’t directly call `x.__del__()' — the
          former decrements the reference count for `x' by one, and the
          latter is only called when `x'’s reference count reaches
          zero.  Some common situations that may prevent the reference
          count of an object from going to zero include: circular
          references between objects (e.g., a doubly-linked list or a
          tree data structure with parent and child pointers); a
          reference to the object on the stack frame of a function that
          caught an exception (the traceback stored in
          `sys.exc_traceback' keeps the stack frame alive); or a
          reference to the object on the stack frame that raised an
          unhandled exception in interactive mode (the traceback stored
          in `sys.last_traceback' keeps the stack frame alive).  The
          first situation can only be remedied by explicitly breaking
          the cycles; the latter two situations can be resolved by
          storing `None' in `sys.exc_traceback' or
          `sys.last_traceback'.  Circular references which are garbage
          are detected when the option cycle detector is enabled
          (it’s on by default), but can only be cleaned up if there
          are no Python-level *Note __del__(): 731.  methods involved.
          Refer to the documentation for the *Note gc: dc. module for
          more information about how *Note __del__(): 731. methods are
          handled by the cycle detector, particularly the description
          of the `garbage' value.

          Warning: Due to the precarious circumstances under which
          *Note __del__(): 731. methods are invoked, exceptions that
          occur during their execution are ignored, and a warning is
          printed to `sys.stderr' instead.  Also, when *Note __del__():
          731. is invoked in response to a module being deleted (e.g.,
          when execution of the program is done), other globals
          referenced by the *Note __del__(): 731. method may already
          have been deleted or in the process of being torn down (e.g.
          the import machinery shutting down).  For this reason, *Note
          __del__(): 731. methods should do the absolute minimum needed
          to maintain external invariants.  Starting with version 1.5,
          Python guarantees that globals whose name begins with a
          single underscore are deleted from their module before other
          globals are deleted; if no other references to such globals
          exist, this may help in assuring that imported modules are
          still available at the time when the *Note __del__(): 731.
          method is called.

     See also the *Note -R: 667. command-line option.

 -- Method: object.__repr__ (self)
     Called by the *Note repr(): 1c6. built-in function and by string
     conversions (reverse quotes) to compute the “official” string
     representation of an object.  If at all possible, this should look
     like a valid Python expression that could be used to recreate an
     object with the same value (given an appropriate environment).  If
     this is not possible, a string of the form `<...some useful
     description...>' should be returned.  The return value must be a
     string object. If a class defines *Note __repr__(): 4a3. but not
     *Note __str__(): 4b2, then *Note __repr__(): 4a3. is also used
     when an “informal” string representation of instances of that
     class is required.

     This is typically used for debugging, so it is important that the
     representation is information-rich and unambiguous.

 -- Method: object.__str__ (self)
     Called by the *Note str(): 1ea. built-in function and by the *Note
     print: 4fd.  statement to compute the “informal” string
     representation of an object.  This differs from *Note __repr__():
     4a3. in that it does not have to be a valid Python expression: a
     more convenient or concise representation may be used instead.
     The return value must be a string object.

 -- Method: object.__lt__ (self, other)
 -- Method: object.__le__ (self, other)
 -- Method: object.__eq__ (self, other)
 -- Method: object.__ne__ (self, other)
 -- Method: object.__gt__ (self, other)
 -- Method: object.__ge__ (self, other)
     New in version 2.1.

     These are the so-called “rich comparison” methods, and are
     called for comparison operators in preference to *Note __cmp__():
     221. below. The correspondence between operator symbols and method
     names is as follows: `x<y' calls `x.__lt__(y)', `x<=y' calls
     `x.__le__(y)', `x==y' calls `x.__eq__(y)', `x!=y' and `x<>y' call
     `x.__ne__(y)', `x>y' calls `x.__gt__(y)', and `x>=y' calls
     `x.__ge__(y)'.

     A rich comparison method may return the singleton `NotImplemented'
     if it does not implement the operation for a given pair of
     arguments. By convention, `False' and `True' are returned for a
     successful comparison. However, these methods can return any
     value, so if the comparison operator is used in a Boolean context
     (e.g., in the condition of an `if' statement), Python will call
     *Note bool(): 455. on the value to determine if the result is true
     or false.

     There are no implied relationships among the comparison operators.
     The truth of `x==y' does not imply that `x!=y' is false.
     Accordingly, when defining *Note __eq__(): 21c, one should also
     define *Note __ne__(): 4d9. so that the operators will behave as
     expected.  See the paragraph on *Note __hash__(): 349. for some
     important notes on creating *Note hashable: 720. objects which
     support custom comparison operations and are usable as dictionary
     keys.

     There are no swapped-argument versions of these methods (to be
     used when the left argument does not support the operation but the
     right argument does); rather, *Note __lt__(): 21d. and *Note
     __gt__(): 21f. are each other’s reflection, *Note __le__(): 21e.
     and *Note __ge__(): 220. are each other’s reflection, and *Note
     __eq__(): 21c. and *Note __ne__(): 4d9. are their own reflection.

     Arguments to rich comparison methods are never coerced.

     To automatically generate ordering operations from a single root
     operation, see *Note functools.total_ordering(): 21b.

 -- Method: object.__cmp__ (self, other)
     Called by comparison operations if rich comparison (see above) is
     not defined.  Should return a negative integer if `self < other',
     zero if `self == other', a positive integer if `self > other'.  If
     no *Note __cmp__(): 221, *Note __eq__(): 21c. or *Note __ne__():
     4d9. operation is defined, class instances are compared by object
     identity (“address”).  See also the description of *Note
     __hash__(): 349. for some important notes on creating *Note
     hashable: 720. objects which support custom comparison operations
     and are usable as dictionary keys. (Note: the restriction that
     exceptions are not propagated by *Note __cmp__(): 221. has been
     removed since Python 1.5.)

 -- Method: object.__rcmp__ (self, other)
     Changed in version 2.1: No longer supported.


 -- Method: object.__hash__ (self)
     Called by built-in function *Note hash(): 733. and for operations
     on members of hashed collections including *Note set: 382, *Note
     frozenset: 383, and *Note dict: 319.  *Note __hash__(): 349.
     should return an integer.  The only required property is that
     objects which compare equal have the same hash value; it is
     advised to somehow mix together (e.g. using exclusive or) the hash
     values for the components of the object that also play a part in
     comparison of objects.

     If a class does not define a *Note __cmp__(): 221. or *Note
     __eq__(): 21c. method it should not define a *Note __hash__():
     349. operation either; if it defines *Note __cmp__(): 221. or
     *Note __eq__(): 21c. but not *Note __hash__(): 349, its instances
     will not be usable in hashed collections.  If a class defines
     mutable objects and implements a *Note __cmp__(): 221. or *Note
     __eq__(): 21c. method, it should not implement *Note __hash__():
     349, since hashable collection implementations require that an
     object’s hash value is immutable (if the object’s hash value
     changes, it will be in the wrong hash bucket).

     User-defined classes have *Note __cmp__(): 221. and *Note
     __hash__(): 349. methods by default; with them, all objects
     compare unequal (except with themselves) and `x.__hash__()'
     returns a result derived from `id(x)'.

     Classes which inherit a *Note __hash__(): 349. method from a
     parent class but change the meaning of *Note __cmp__(): 221. or
     *Note __eq__(): 21c. such that the hash value returned is no
     longer appropriate (e.g. by switching to a value-based concept of
     equality instead of the default identity based equality) can
     explicitly flag themselves as being unhashable by setting
     `__hash__ = None' in the class definition. Doing so means that not
     only will instances of the class raise an appropriate *Note
     TypeError: 218. when a program attempts to retrieve their hash
     value, but they will also be correctly identified as unhashable
     when checking `isinstance(obj, collections.Hashable)' (unlike
     classes which define their own *Note __hash__(): 349. to
     explicitly raise *Note TypeError: 218.).

     Changed in version 2.5: *Note __hash__(): 349. may now also return
     a long integer object; the 32-bit integer is then derived from the
     hash of that object.

     Changed in version 2.6: *Note __hash__: 349. may now be set to
     *Note None: 3b2. to explicitly flag instances of a class as
     unhashable.


 -- Method: object.__nonzero__ (self)
     Called to implement truth value testing and the built-in operation
     `bool()'; should return `False' or `True', or their integer
     equivalents `0' or `1'.  When this method is not defined, *Note
     __len__(): 423. is called, if it is defined, and the object is
     considered true if its result is nonzero.  If a class defines
     neither *Note __len__(): 423. nor *Note __nonzero__(): 734, all its
     instances are considered true.

 -- Method: object.__unicode__ (self)
     Called to implement *Note unicode(): 1f5. built-in; should return
     a Unicode object.  When this method is not defined, string
     conversion is attempted, and the result of string conversion is
     converted to Unicode using the system default encoding.


File: python.info,  Node: Customizing attribute access,  Next: Customizing class creation,  Prev: Basic customization,  Up: Special method names

4.3.4.2 Customizing attribute access
....................................

The following methods can be defined to customize the meaning of
attribute access (use of, assignment to, or deletion of `x.name') for
class instances.

 -- Method: object.__getattr__ (self, name)
     Called when an attribute lookup has not found the attribute in the
     usual places (i.e. it is not an instance attribute nor is it found
     in the class tree for `self').  `name' is the attribute name. This
     method should return the (computed) attribute value or raise an
     *Note AttributeError: 1f8. exception.

     Note that if the attribute is found through the normal mechanism,
     *Note __getattr__(): 345. is not called.  (This is an intentional
     asymmetry between *Note __getattr__(): 345. and *Note
     __setattr__(): 4a5.) This is done both for efficiency reasons and
     because otherwise *Note __getattr__(): 345. would have no way to
     access other attributes of the instance.  Note that at least for
     instance variables, you can fake total control by not inserting
     any values in the instance attribute dictionary (but instead
     inserting them in another object).  See the *Note
     __getattribute__(): 34f. method below for a way to actually get
     total control in new-style classes.

 -- Method: object.__setattr__ (self, name, value)
     Called when an attribute assignment is attempted.  This is called
     instead of the normal mechanism (i.e. store the value in the
     instance dictionary).  `name' is the attribute name, `value' is
     the value to be assigned to it.

     If *Note __setattr__(): 4a5. wants to assign to an instance
     attribute, it should not simply execute `self.name = value' —
     this would cause a recursive call to itself.  Instead, it should
     insert the value in the dictionary of instance attributes, e.g.,
     `self.__dict__[name] = value'.  For new-style classes, rather than
     accessing the instance dictionary, it should call the base class
     method with the same name, for example, `object.__setattr__(self,
     name, value)'.

 -- Method: object.__delattr__ (self, name)
     Like *Note __setattr__(): 4a5. but for attribute deletion instead
     of assignment.  This should only be implemented if `del obj.name'
     is meaningful for the object.

* Menu:

* More attribute access for new-style classes::
* Implementing Descriptors::
* Invoking Descriptors::
* __slots__::


File: python.info,  Node: More attribute access for new-style classes,  Next: Implementing Descriptors,  Up: Customizing attribute access

4.3.4.3 More attribute access for new-style classes
...................................................

The following methods only apply to new-style classes.

 -- Method: object.__getattribute__ (self, name)
     Called unconditionally to implement attribute accesses for
     instances of the class. If the class also defines *Note
     __getattr__(): 345, the latter will not be called unless *Note
     __getattribute__(): 34f. either calls it explicitly or raises an
     *Note AttributeError: 1f8. This method should return the
     (computed) attribute value or raise an *Note AttributeError: 1f8.
     exception. In order to avoid infinite recursion in this method,
     its implementation should always call the base class method with
     the same name to access any attributes it needs, for example,
     `object.__getattribute__(self, name)'.

          Note: This method may still be bypassed when looking up
          special methods as the result of implicit invocation via
          language syntax or built-in functions.  See *Note Special
          method lookup for new-style classes: 739.


File: python.info,  Node: Implementing Descriptors,  Next: Invoking Descriptors,  Prev: More attribute access for new-style classes,  Up: Customizing attribute access

4.3.4.4 Implementing Descriptors
................................

The following methods only apply when an instance of the class
containing the method (a so-called `descriptor' class) appears in an
`owner' class (the descriptor must be in either the owner’s class
dictionary or in the class dictionary for one of its parents).  In the
examples below, “the attribute” refers to the attribute whose name
is the key of the property in the owner class’ *Note __dict__: 4a0.

 -- Method: object.__get__ (self, instance, owner)
     Called to get the attribute of the owner class (class attribute
     access) or of an instance of that class (instance attribute
     access). `owner' is always the owner class, while `instance' is
     the instance that the attribute was accessed through, or `None'
     when the attribute is accessed through the `owner'.  This method
     should return the (computed) attribute value or raise an *Note
     AttributeError: 1f8.  exception.

 -- Method: object.__set__ (self, instance, value)
     Called to set the attribute on an instance `instance' of the owner
     class to a new value, `value'.

 -- Method: object.__delete__ (self, instance)
     Called to delete the attribute on an instance `instance' of the
     owner class.


File: python.info,  Node: Invoking Descriptors,  Next: __slots__,  Prev: Implementing Descriptors,  Up: Customizing attribute access

4.3.4.5 Invoking Descriptors
............................

In general, a descriptor is an object attribute with “binding
behavior”, one whose attribute access has been overridden by methods
in the descriptor protocol:  *Note __get__(): 73b, *Note __set__():
73c, and *Note __delete__(): 73d. If any of those methods are defined
for an object, it is said to be a descriptor.

The default behavior for attribute access is to get, set, or delete the
attribute from an object’s dictionary. For instance, `a.x' has a
lookup chain starting with `a.__dict__['x']', then
`type(a).__dict__['x']', and continuing through the base classes of
`type(a)' excluding metaclasses.

However, if the looked-up value is an object defining one of the
descriptor methods, then Python may override the default behavior and
invoke the descriptor method instead.  Where this occurs in the
precedence chain depends on which descriptor methods were defined and
how they were called.  Note that descriptors are only invoked for new
style objects or classes (ones that subclass *Note object(): 1f1. or
*Note type(): 4ac.).

The starting point for descriptor invocation is a binding, `a.x'. How
the arguments are assembled depends on `a':

Direct Call
     The simplest and least common call is when user code directly
     invokes a descriptor method:    `x.__get__(a)'.

Instance Binding
     If binding to a new-style object instance, `a.x' is transformed
     into the call: `type(a).__dict__['x'].__get__(a, type(a))'.

Class Binding
     If binding to a new-style class, `A.x' is transformed into the
     call: `A.__dict__['x'].__get__(None, A)'.

Super Binding
     If `a' is an instance of *Note super: 395, then the binding
     `super(B, obj).m()' searches `obj.__class__.__mro__' for the base
     class `A' immediately preceding `B' and then invokes the
     descriptor with the call: `A.__dict__['m'].__get__(obj,
     obj.__class__)'.

For instance bindings, the precedence of descriptor invocation depends
on the which descriptor methods are defined.  A descriptor can define
any combination of *Note __get__(): 73b, *Note __set__(): 73c. and
*Note __delete__(): 73d.  If it does not define *Note __get__(): 73b,
then accessing the attribute will return the descriptor object itself
unless there is a value in the object’s instance dictionary.  If the
descriptor defines *Note __set__(): 73c. and/or *Note __delete__():
73d, it is a data descriptor; if it defines neither, it is a non-data
descriptor.  Normally, data descriptors define both *Note __get__():
73b. and *Note __set__(): 73c, while non-data descriptors have just the
*Note __get__(): 73b. method.  Data descriptors with *Note __set__():
73c. and *Note __get__(): 73b. defined always override a redefinition
in an instance dictionary.  In contrast, non-data descriptors can be
overridden by instances.

Python methods (including *Note staticmethod(): 40e. and *Note
classmethod(): 40f.) are implemented as non-data descriptors.
Accordingly, instances can redefine and override methods.  This allows
individual instances to acquire behaviors that differ from other
instances of the same class.

The *Note property(): 4a4. function is implemented as a data
descriptor. Accordingly, instances cannot override the behavior of a
property.


File: python.info,  Node: __slots__,  Prev: Invoking Descriptors,  Up: Customizing attribute access

4.3.4.6 __slots__
.................

By default, instances of both old and new-style classes have a
dictionary for attribute storage.  This wastes space for objects having
very few instance variables.  The space consumption can become acute
when creating large numbers of instances.

The default can be overridden by defining `__slots__' in a new-style
class definition.  The `__slots__' declaration takes a sequence of
instance variables and reserves just enough space in each instance to
hold a value for each variable.  Space is saved because `__dict__' is
not created for each instance.

 -- Data: __slots__
     This class variable can be assigned a string, iterable, or
     sequence of strings with variable names used by instances.  If
     defined in a new-style class, `__slots__' reserves space for the
     declared variables and prevents the automatic creation of
     `__dict__' and `__weakref__' for each instance.

     New in version 2.2.


Notes on using `__slots__'

   * When inheriting from a class without `__slots__', the `__dict__'
     attribute of that class will always be accessible, so a
     `__slots__' definition in the subclass is meaningless.

   * Without a `__dict__' variable, instances cannot be assigned new
     variables not listed in the `__slots__' definition.  Attempts to
     assign to an unlisted variable name raises *Note AttributeError:
     1f8. If dynamic assignment of new variables is desired, then add
     `'__dict__'' to the sequence of strings in the `__slots__'
     declaration.

     Changed in version 2.3: Previously, adding `'__dict__'' to the
     `__slots__' declaration would not enable the assignment of new
     attributes not specifically listed in the sequence of instance
     variable names.

   * Without a `__weakref__' variable for each instance, classes
     defining `__slots__' do not support weak references to its
     instances. If weak reference support is needed, then add
     `'__weakref__'' to the sequence of strings in the `__slots__'
     declaration.

     Changed in version 2.3: Previously, adding `'__weakref__'' to the
     `__slots__' declaration would not enable support for weak
     references.

   * `__slots__' are implemented at the class level by creating
     descriptors (*Note Implementing Descriptors: 726.) for each
     variable name.  As a result, class attributes cannot be used to
     set default values for instance variables defined by `__slots__';
     otherwise, the class attribute would overwrite the descriptor
     assignment.

   * The action of a `__slots__' declaration is limited to the class
     where it is defined.  As a result, subclasses will have a
     `__dict__' unless they also define `__slots__' (which must only
     contain names of any `additional' slots).

   * If a class defines a slot also defined in a base class, the
     instance variable defined by the base class slot is inaccessible
     (except by retrieving its descriptor directly from the base
     class). This renders the meaning of the program undefined.  In the
     future, a check may be added to prevent this.

   * Nonempty `__slots__' does not work for classes derived from
     “variable-length” built-in types such as *Note long: 1f3,
     *Note str: 1ea. and *Note tuple: 421.

   * Any non-string iterable may be assigned to `__slots__'. Mappings
     may also be used; however, in the future, special meaning may be
     assigned to the values corresponding to each key.

   * `__class__' assignment works only if both classes have the same
     `__slots__'.

     Changed in version 2.6: Previously, `__class__' assignment raised
     an error if either new or old class had `__slots__'.



File: python.info,  Node: Customizing class creation,  Next: Customizing instance and subclass checks,  Prev: Customizing attribute access,  Up: Special method names

4.3.4.7 Customizing class creation
..................................

By default, new-style classes are constructed using *Note type(): 4ac.
A class definition is read into a separate namespace and the value of
class name is bound to the result of `type(name, bases, dict)'.

When the class definition is read, if `__metaclass__' is defined then
the callable assigned to it will be called instead of *Note type():
4ac. This allows classes or functions to be written which monitor or
alter the class creation process:

   * Modifying the class dictionary prior to the class being created.

   * Returning an instance of another class – essentially performing
     the role of a factory function.

These steps will have to be performed in the metaclass’s *Note
__new__(): 724. method – `type.__new__()' can then be called from
this method to create a class with different properties.  This example
adds a new element to the class dictionary before creating the class:

    class metacls(type):
        def __new__(mcs, name, bases, dict):
            dict['foo'] = 'metacls was here'
            return type.__new__(mcs, name, bases, dict)

You can of course also override other class methods (or add new
methods); for example defining a custom *Note __call__(): 725. method
in the metaclass allows custom behavior when the class is called, e.g.
not always creating a new instance.

 -- Data: __metaclass__
     This variable can be any callable accepting arguments for `name',
     `bases', and `dict'.  Upon class creation, the callable is used
     instead of the built-in *Note type(): 4ac.

     New in version 2.2.


The appropriate metaclass is determined by the following precedence
rules:

   * If `dict['__metaclass__']' exists, it is used.

   * Otherwise, if there is at least one base class, its metaclass is
     used (this looks for a `__class__' attribute first and if not
     found, uses its type).

   * Otherwise, if a global variable named __metaclass__ exists, it is
     used.

   * Otherwise, the old-style, classic metaclass (types.ClassType) is
     used.

The potential uses for metaclasses are boundless. Some ideas that have
been explored including logging, interface checking, automatic
delegation, automatic property creation, proxies, frameworks, and
automatic resource locking/synchronization.


File: python.info,  Node: Customizing instance and subclass checks,  Next: Emulating callable objects,  Prev: Customizing class creation,  Up: Special method names

4.3.4.8 Customizing instance and subclass checks
................................................

New in version 2.6.

The following methods are used to override the default behavior of the
*Note isinstance(): 332. and *Note issubclass(): 333. built-in
functions.

In particular, the metaclass *Note abc.ABCMeta: 746. implements these
methods in order to allow the addition of Abstract Base Classes (ABCs)
as “virtual base classes” to any class or type (including built-in
types), including other ABCs.

 -- Method: class.__instancecheck__ (self, instance)
     Return true if `instance' should be considered a (direct or
     indirect) instance of `class'. If defined, called to implement
     `isinstance(instance, class)'.

 -- Method: class.__subclasscheck__ (self, subclass)
     Return true if `subclass' should be considered a (direct or
     indirect) subclass of `class'.  If defined, called to implement
     `issubclass(subclass, class)'.

Note that these methods are looked up on the type (metaclass) of a
class.  They cannot be defined as class methods in the actual class.
This is consistent with the lookup of special methods that are called
on instances, only in this case the instance is itself a class.

See also
........

PEP 3119(1) - Introducing Abstract Base Classes
     Includes the specification for customizing *Note isinstance():
     332. and *Note issubclass(): 333. behavior through *Note
     __instancecheck__(): 747. and *Note __subclasscheck__(): 748, with
     motivation for this functionality in the context of adding
     Abstract Base Classes (see the *Note abc: 4.  module) to the
     language.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-3119


File: python.info,  Node: Emulating callable objects,  Next: Emulating container types,  Prev: Customizing instance and subclass checks,  Up: Special method names

4.3.4.9 Emulating callable objects
..................................

 -- Method: object.__call__ (self[, args...])
     Called when the instance is “called” as a function; if this
     method is defined, `x(arg1, arg2, ...)' is a shorthand for
     `x.__call__(arg1, arg2, ...)'.


File: python.info,  Node: Emulating container types,  Next: Additional methods for emulation of sequence types,  Prev: Emulating callable objects,  Up: Special method names

4.3.4.10 Emulating container types
..................................

The following methods can be defined to implement container objects.
Containers usually are sequences (such as lists or tuples) or mappings
(like dictionaries), but can represent other containers as well.  The
first set of methods is used either to emulate a sequence or to emulate
a mapping; the difference is that for a sequence, the allowable keys
should be the integers `k' for which `0 <= k < N' where `N' is the
length of the sequence, or slice objects, which define a range of
items. (For backwards compatibility, the method *Note __getslice__():
74d.  (see below) can also be defined to handle simple, but not
extended slices.) It is also recommended that mappings provide the
methods `keys()', `values()', `items()', `has_key()', `get()',
`clear()', `setdefault()', `iterkeys()', `itervalues()', `iteritems()',
`pop()', `popitem()', `copy()', and `update()' behaving similar to
those for Python’s standard dictionary objects.  The *Note UserDict:
18c. module provides a `DictMixin' class to help create those methods
from a base set of *Note __getitem__(): 468, *Note __setitem__(): 481,
*Note __delitem__(): 482, and `keys()'. Mutable sequences should
provide methods `append()', `count()', `index()', `extend()',
`insert()', `pop()', `remove()', `reverse()' and `sort()', like Python
standard list objects.  Finally, sequence types should implement
addition (meaning concatenation) and multiplication (meaning
repetition) by defining the methods *Note __add__(): 74e, *Note
__radd__(): 74f, *Note __iadd__(): 4f5, *Note __mul__(): 750, *Note
__rmul__(): 751. and *Note __imul__(): 752. described below; they
should not define *Note __coerce__(): 1ee. or other numerical
operators.  It is recommended that both mappings and sequences
implement the *Note __contains__(): 336. method to allow efficient use
of the `in' operator; for mappings, `in' should be equivalent of
`has_key()'; for sequences, it should search through the values.  It is
further recommended that both mappings and sequences implement the
*Note __iter__(): 335. method to allow efficient iteration through the
container; for mappings, *Note __iter__(): 335. should be the same as
`iterkeys()'; for sequences, it should iterate through the values.

 -- Method: object.__len__ (self)
     Called to implement the built-in function *Note len(): 53c.
     Should return the length of the object, an integer `>=' 0.  Also,
     an object that doesn’t define a *Note __nonzero__(): 734. method
     and whose *Note __len__(): 423. method returns zero is considered
     to be false in a Boolean context.

 -- Method: object.__getitem__ (self, key)
     Called to implement evaluation of `self[key]'. For sequence types,
     the accepted keys should be integers and slice objects.  Note that
     the special interpretation of negative indexes (if the class
     wishes to emulate a sequence type) is up to the *Note
     __getitem__(): 468. method. If `key' is of an inappropriate type,
     *Note TypeError: 218. may be raised; if of a value outside the set
     of indexes for the sequence (after any special interpretation of
     negative values), *Note IndexError: 4fe. should be raised. For
     mapping types, if `key' is missing (not in the container), *Note
     KeyError: 205. should be raised.

          Note: *Note for: 303. loops expect that an *Note IndexError:
          4fe. will be raised for illegal indexes to allow proper
          detection of the end of the sequence.

 -- Method: object.__missing__ (self, key)
     Called by *Note dict: 319.*Note __getitem__(): 468. to implement
     `self[key]' for dict subclasses when key is not in the dictionary.

 -- Method: object.__setitem__ (self, key, value)
     Called to implement assignment to `self[key]'.  Same note as for
     *Note __getitem__(): 468.  This should only be implemented for
     mappings if the objects support changes to the values for keys, or
     if new keys can be added, or for sequences if elements can be
     replaced.  The same exceptions should be raised for improper `key'
     values as for the *Note __getitem__(): 468. method.

 -- Method: object.__delitem__ (self, key)
     Called to implement deletion of `self[key]'.  Same note as for
     *Note __getitem__(): 468.  This should only be implemented for
     mappings if the objects support removal of keys, or for sequences
     if elements can be removed from the sequence.  The same exceptions
     should be raised for improper `key' values as for the *Note
     __getitem__(): 468. method.

 -- Method: object.__iter__ (self)
     This method is called when an iterator is required for a
     container. This method should return a new iterator object that
     can iterate over all the objects in the container.  For mappings,
     it should iterate over the keys of the container, and should also
     be made available as the method `iterkeys()'.

     Iterator objects also need to implement this method; they are
     required to return themselves.  For more information on iterator
     objects, see *Note Iterator Types: 754.

 -- Method: object.__reversed__ (self)
     Called (if present) by the *Note reversed(): 411. built-in to
     implement reverse iteration.  It should return a new iterator
     object that iterates over all the objects in the container in
     reverse order.

     If the *Note __reversed__(): 755. method is not provided, the
     *Note reversed(): 411.  built-in will fall back to using the
     sequence protocol (*Note __len__(): 423. and *Note __getitem__():
     468.).  Objects that support the sequence protocol should only
     provide *Note __reversed__(): 755. if they can provide an
     implementation that is more efficient than the one provided by
     *Note reversed(): 411.

     New in version 2.6.


The membership test operators (*Note in: 441. and *Note not in: 756.)
are normally implemented as an iteration through a sequence.  However,
container objects can supply the following special method with a more
efficient implementation, which also does not require the object be a
sequence.

 -- Method: object.__contains__ (self, item)
     Called to implement membership test operators.  Should return true
     if `item' is in `self', false otherwise.  For mapping objects,
     this should consider the keys of the mapping rather than the
     values or the key-item pairs.

     For objects that don’t define *Note __contains__(): 336, the
     membership test first tries iteration via *Note __iter__(): 335,
     then the old sequence iteration protocol via *Note __getitem__():
     468, see *Note this section in the language reference: 757.


File: python.info,  Node: Additional methods for emulation of sequence types,  Next: Emulating numeric types,  Prev: Emulating container types,  Up: Special method names

4.3.4.11 Additional methods for emulation of sequence types
...........................................................

The following optional methods can be defined to further emulate
sequence objects.  Immutable sequences methods should at most only
define *Note __getslice__(): 74d.; mutable sequences might define all
three methods.

 -- Method: object.__getslice__ (self, i, j)
     Deprecated since version 2.0: Support slice objects as parameters
     to the *Note __getitem__(): 468. method.  (However, built-in types
     in CPython currently still implement *Note __getslice__(): 74d.
     Therefore, you have to override it in derived classes when
     implementing slicing.)

     Called to implement evaluation of `self[i:j]'. The returned object
     should be of the same type as `self'.  Note that missing `i' or
     `j' in the slice expression are replaced by zero or *Note
     sys.maxsize: 75a, respectively.  If negative indexes are used in
     the slice, the length of the sequence is added to that index. If
     the instance does not implement the *Note __len__(): 423. method,
     an *Note AttributeError: 1f8. is raised. No guarantee is made that
     indexes adjusted this way are not still negative.  Indexes which
     are greater than the length of the sequence are not modified. If
     no *Note __getslice__(): 74d. is found, a slice object is created
     instead, and passed to *Note __getitem__(): 468. instead.

 -- Method: object.__setslice__ (self, i, j, sequence)
     Called to implement assignment to `self[i:j]'. Same notes for `i'
     and `j' as for *Note __getslice__(): 74d.

     This method is deprecated. If no *Note __setslice__(): 75b. is
     found, or for extended slicing of the form `self[i:j:k]', a slice
     object is created, and passed to *Note __setitem__(): 481, instead
     of *Note __setslice__(): 75b. being called.

 -- Method: object.__delslice__ (self, i, j)
     Called to implement deletion of `self[i:j]'. Same notes for `i'
     and `j' as for *Note __getslice__(): 74d. This method is
     deprecated. If no *Note __delslice__(): 75c. is found, or for
     extended slicing of the form `self[i:j:k]', a slice object is
     created, and passed to *Note __delitem__(): 482, instead of *Note
     __delslice__(): 75c.  being called.

Notice that these methods are only invoked when a single slice with a
single colon is used, and the slice method is available.  For slice
operations involving extended slice notation, or in absence of the
slice methods, *Note __getitem__(): 468, *Note __setitem__(): 481. or
*Note __delitem__(): 482. is called with a slice object as argument.

The following example demonstrate how to make your program or module
compatible with earlier versions of Python (assuming that methods *Note
__getitem__(): 468, *Note __setitem__(): 481. and *Note __delitem__():
482. support slice objects as arguments):

    class MyClass:
        ...
        def __getitem__(self, index):
            ...
        def __setitem__(self, index, value):
            ...
        def __delitem__(self, index):
            ...

        if sys.version_info < (2, 0):
            # They won't be defined if version is at least 2.0 final

            def __getslice__(self, i, j):
                return self[max(0, i):max(0, j):]
            def __setslice__(self, i, j, seq):
                self[max(0, i):max(0, j):] = seq
            def __delslice__(self, i, j):
                del self[max(0, i):max(0, j):]
        ...

Note the calls to *Note max(): 225.; these are necessary because of the
handling of negative indices before the `__*slice__()' methods are
called.  When negative indexes are used, the `__*item__()' methods
receive them as provided, but the `__*slice__()' methods get a
“cooked” form of the index values.  For each negative index value,
the length of the sequence is added to the index before calling the
method (which may still result in a negative index); this is the
customary handling of negative indexes by the built-in sequence types,
and the `__*item__()' methods are expected to do this as well.
However, since they should already be doing that, negative indexes
cannot be passed in; they must be constrained to the bounds of the
sequence before being passed to the `__*item__()' methods. Calling
`max(0, i)' conveniently returns the proper value.


File: python.info,  Node: Emulating numeric types,  Next: Coercion rules,  Prev: Additional methods for emulation of sequence types,  Up: Special method names

4.3.4.12 Emulating numeric types
................................

The following methods can be defined to emulate numeric objects. Methods
corresponding to operations that are not supported by the particular
kind of number implemented (e.g., bitwise operations for non-integral
numbers) should be left undefined.

 -- Method: object.__add__ (self, other)
 -- Method: object.__sub__ (self, other)
 -- Method: object.__mul__ (self, other)
 -- Method: object.__floordiv__ (self, other)
 -- Method: object.__mod__ (self, other)
 -- Method: object.__divmod__ (self, other)
 -- Method: object.__pow__ (self, other[, modulo])
 -- Method: object.__lshift__ (self, other)
 -- Method: object.__rshift__ (self, other)
 -- Method: object.__and__ (self, other)
 -- Method: object.__xor__ (self, other)
 -- Method: object.__or__ (self, other)
     These methods are called to implement the binary arithmetic
     operations (`+', `-', `*', `//', `%', *Note divmod(): 768, *Note
     pow(): 4d1, `**', `<<', `>>', `&', `^', `|').  For instance, to
     evaluate the expression `x + y', where `x' is an instance of a
     class that has an *Note __add__(): 74e.  method, `x.__add__(y)' is
     called.  The *Note __divmod__(): 761. method should be the
     equivalent to using *Note __floordiv__(): 4af. and *Note
     __mod__(): 760.; it should not be related to *Note __truediv__():
     4ae. (described below).  Note that *Note __pow__(): 762.  should
     be defined to accept an optional third argument if the ternary
     version of the built-in *Note pow(): 4d1. function is to be
     supported.

     If one of those methods does not support the operation with the
     supplied arguments, it should return `NotImplemented'.

 -- Method: object.__div__ (self, other)
 -- Method: object.__truediv__ (self, other)
     The division operator (`/') is implemented by these methods.  The
     *Note __truediv__(): 4ae. method is used when
     `__future__.division' is in effect, otherwise *Note __div__():
     769. is used.  If only one of these two methods is defined, the
     object will not support division in the alternate context; *Note
     TypeError: 218.  will be raised instead.

 -- Method: object.__radd__ (self, other)
 -- Method: object.__rsub__ (self, other)
 -- Method: object.__rmul__ (self, other)
 -- Method: object.__rdiv__ (self, other)
 -- Method: object.__rtruediv__ (self, other)
 -- Method: object.__rfloordiv__ (self, other)
 -- Method: object.__rmod__ (self, other)
 -- Method: object.__rdivmod__ (self, other)
 -- Method: object.__rpow__ (self, other)
 -- Method: object.__rlshift__ (self, other)
 -- Method: object.__rrshift__ (self, other)
 -- Method: object.__rand__ (self, other)
 -- Method: object.__rxor__ (self, other)
 -- Method: object.__ror__ (self, other)
     These methods are called to implement the binary arithmetic
     operations (`+', `-', `*', `/', `%', *Note divmod(): 768, *Note
     pow(): 4d1, `**', `<<', `>>', `&', `^', `|') with reflected
     (swapped) operands.  These functions are only called if the left
     operand does not support the corresponding operation and the
     operands are of different types. (1) For instance, to evaluate the
     expression `x - y', where `y' is an instance of a class that has an
     *Note __rsub__(): 76a. method, `y.__rsub__(x)' is called if
     `x.__sub__(y)' returns `NotImplemented'.

     Note that ternary *Note pow(): 4d1. will not try calling *Note
     __rpow__(): 770. (the coercion rules would become too complicated).

          Note: If the right operand’s type is a subclass of the left
          operand’s type and that subclass provides the reflected
          method for the operation, this method will be called before
          the left operand’s non-reflected method.  This behavior
          allows subclasses to override their ancestors’ operations.

 -- Method: object.__iadd__ (self, other)
 -- Method: object.__isub__ (self, other)
 -- Method: object.__imul__ (self, other)
 -- Method: object.__idiv__ (self, other)
 -- Method: object.__itruediv__ (self, other)
 -- Method: object.__ifloordiv__ (self, other)
 -- Method: object.__imod__ (self, other)
 -- Method: object.__ipow__ (self, other[, modulo])
 -- Method: object.__ilshift__ (self, other)
 -- Method: object.__irshift__ (self, other)
 -- Method: object.__iand__ (self, other)
 -- Method: object.__ixor__ (self, other)
 -- Method: object.__ior__ (self, other)
     These methods are called to implement the augmented arithmetic
     assignments (`+=', `-=', `*=', `/=', `//=', `%=', `**=', `<<=',
     `>>=', `&=', `^=', `|=').  These methods should attempt to do the
     operation in-place (modifying `self') and return the result (which
     could be, but does not have to be, `self').  If a specific method
     is not defined, the augmented assignment falls back to the normal
     methods.  For instance, to execute the statement `x += y', where
     `x' is an instance of a class that has an *Note __iadd__(): 4f5.
     method, `x.__iadd__(y)' is called.  If `x' is an instance of a
     class that does not define a *Note __iadd__(): 4f5. method,
     `x.__add__(y)' and `y.__radd__(x)' are considered, as with the
     evaluation of `x + y'.

 -- Method: object.__neg__ (self)
 -- Method: object.__pos__ (self)
 -- Method: object.__abs__ (self)
 -- Method: object.__invert__ (self)
     Called to implement the unary arithmetic operations (`-', `+',
     *Note abs(): 5da.  and `~').

 -- Method: object.__complex__ (self)
 -- Method: object.__int__ (self)
 -- Method: object.__long__ (self)
 -- Method: object.__float__ (self)
     Called to implement the built-in functions *Note complex(): 1ec,
     *Note int(): 1f2, *Note long(): 1f3, and *Note float(): 1eb.
     Should return a value of the appropriate type.

 -- Method: object.__oct__ (self)
 -- Method: object.__hex__ (self)
     Called to implement the built-in functions *Note oct(): 339. and
     *Note hex(): 348.  Should return a string value.

 -- Method: object.__index__ (self)
     Called to implement *Note operator.index(): 786.  Also called
     whenever Python needs an integer object (such as in slicing).
     Must return an integer (int or long).

     New in version 2.5.


 -- Method: object.__coerce__ (self, other)
     Called to implement “mixed-mode” numeric arithmetic.  Should
     either return a 2-tuple containing `self' and `other' converted to
     a common numeric type, or `None' if conversion is impossible.
     When the common type would be the type of `other', it is
     sufficient to return `None', since the interpreter will also ask
     the other object to attempt a coercion (but sometimes, if the
     implementation of the other type cannot be changed, it is useful
     to do the conversion to the other type here).  A return value of
     `NotImplemented' is equivalent to returning `None'.

---------- Footnotes ----------

(1) For operands of the same type, it is assumed that if the
non-reflected method (such as *Note __add__(): 74e.) fails the
operation is not supported, which is why the reflected method is not
called.


File: python.info,  Node: Coercion rules,  Next: With Statement Context Managers,  Prev: Emulating numeric types,  Up: Special method names

4.3.4.13 Coercion rules
.......................

This section used to document the rules for coercion.  As the language
has evolved, the coercion rules have become hard to document precisely;
documenting what one version of one particular implementation does is
undesirable.  Instead, here are some informal guidelines regarding
coercion.  In Python 3, coercion will not be supported.

   * If the left operand of a % operator is a string or Unicode object,
     no coercion takes place and the string formatting operation is
     invoked instead.

   * It is no longer recommended to define a coercion operation.
     Mixed-mode operations on types that don’t define coercion pass
     the original arguments to the operation.

   * New-style classes (those derived from *Note object: 1f1.) never
     invoke the *Note __coerce__(): 1ee. method in response to a binary
     operator; the only time *Note __coerce__(): 1ee. is invoked is
     when the built-in function *Note coerce(): 789. is called.

   * For most intents and purposes, an operator that returns
     `NotImplemented' is treated the same as one that is not
     implemented at all.

   * Below, `__op__()' and `__rop__()' are used to signify the generic
     method names corresponding to an operator; `__iop__()' is used for
     the corresponding in-place operator.  For example, for the
     operator ‘`+'’, *Note __add__(): 74e. and *Note __radd__():
     74f. are used for the left and right variant of the binary
     operator, and *Note __iadd__(): 4f5. for the in-place variant.

   * For objects `x' and `y', first `x.__op__(y)' is tried.  If this is
     not implemented or returns `NotImplemented', `y.__rop__(x)' is
     tried.  If this is also not implemented or returns
     `NotImplemented', a *Note TypeError: 218.  exception is raised.
     But see the following exception:

   * Exception to the previous item: if the left operand is an instance
     of a built-in type or a new-style class, and the right operand is
     an instance of a proper subclass of that type or class and
     overrides the base’s `__rop__()' method, the right operand’s
     `__rop__()' method is tried `before' the left operand’s
     `__op__()' method.

     This is done so that a subclass can completely override binary
     operators.  Otherwise, the left operand’s `__op__()' method
     would always accept the right operand: when an instance of a given
     class is expected, an instance of a subclass of that class is
     always acceptable.

   * When either operand type defines a coercion, this coercion is
     called before that type’s `__op__()' or `__rop__()' method is
     called, but no sooner.  If the coercion returns an object of a
     different type for the operand whose coercion is invoked, part of
     the process is redone using the new object.

   * When an in-place operator (like ‘`+='’) is used, if the left
     operand implements `__iop__()', it is invoked without any
     coercion.  When the operation falls back to `__op__()' and/or
     `__rop__()', the normal coercion rules apply.

   * In `x + y', if `x' is a sequence that implements sequence
     concatenation, sequence concatenation is invoked.

   * In `x * y', if one operand is a sequence that implements sequence
     repetition, and the other is an integer (*Note int: 1f2. or *Note
     long: 1f3.), sequence repetition is invoked.

   * Rich comparisons (implemented by methods *Note __eq__(): 21c. and
     so on) never use coercion.  Three-way comparison (implemented by
     *Note __cmp__(): 221.) does use coercion under the same conditions
     as other binary operations use it.

   * In the current implementation, the built-in numeric types *Note
     int: 1f2, *Note long: 1f3, *Note float: 1eb, and *Note complex:
     1ec. do not use coercion.  All these types implement a *Note
     __coerce__(): 1ee. method, for use by the built-in *Note coerce():
     789. function.

     Changed in version 2.7: The complex type no longer makes implicit
     calls to the *Note __coerce__(): 1ee.  method for mixed-type
     binary arithmetic operations.



File: python.info,  Node: With Statement Context Managers,  Next: Special method lookup for old-style classes,  Prev: Coercion rules,  Up: Special method names

4.3.4.14 With Statement Context Managers
........................................

New in version 2.5.

A `context manager' is an object that defines the runtime context to be
established when executing a *Note with: 1c1. statement. The context
manager handles the entry into, and the exit from, the desired runtime
context for the execution of the block of code.  Context managers are
normally invoked using the *Note with: 1c1. statement (described in
section *Note The with statement: 1c1.), but can also be used by
directly invoking their methods.

Typical uses of context managers include saving and restoring various
kinds of global state, locking and unlocking resources, closing opened
files, etc.

For more information on context managers, see *Note Context Manager
Types: 78c.

 -- Method: object.__enter__ (self)
     Enter the runtime context related to this object. The *Note with:
     1c1. statement will bind this method’s return value to the
     target(s) specified in the *Note as: 30b. clause of the statement,
     if any.

 -- Method: object.__exit__ (self, exc_type, exc_value, traceback)
     Exit the runtime context related to this object. The parameters
     describe the exception that caused the context to be exited. If
     the context was exited without an exception, all three arguments
     will be *Note None: 3b2.

     If an exception is supplied, and the method wishes to suppress the
     exception (i.e., prevent it from being propagated), it should
     return a true value.  Otherwise, the exception will be processed
     normally upon exit from this method.

     Note that *Note __exit__(): 200. methods should not reraise the
     passed-in exception; this is the caller’s responsibility.

See also
........

PEP 343(1) - The “with” statement
     The specification, background, and examples for the Python *Note
     with: 1c1.  statement.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0343


File: python.info,  Node: Special method lookup for old-style classes,  Next: Special method lookup for new-style classes,  Prev: With Statement Context Managers,  Up: Special method names

4.3.4.15 Special method lookup for old-style classes
....................................................

For old-style classes, special methods are always looked up in exactly
the same way as any other method or attribute. This is the case
regardless of whether the method is being looked up explicitly as in
`x.__getitem__(i)' or implicitly as in `x[i]'.

This behaviour means that special methods may exhibit different
behaviour for different instances of a single old-style class if the
appropriate special attributes are set differently:

    >>> class C:
    ...     pass
    ...
    >>> c1 = C()
    >>> c2 = C()
    >>> c1.__len__ = lambda: 5
    >>> c2.__len__ = lambda: 9
    >>> len(c1)
    5
    >>> len(c2)
    9


File: python.info,  Node: Special method lookup for new-style classes,  Prev: Special method lookup for old-style classes,  Up: Special method names

4.3.4.16 Special method lookup for new-style classes
....................................................

For new-style classes, implicit invocations of special methods are only
guaranteed to work correctly if defined on an object’s type, not in
the object’s instance dictionary.  That behaviour is the reason why
the following code raises an exception (unlike the equivalent example
with old-style classes):

    >>> class C(object):
    ...     pass
    ...
    >>> c = C()
    >>> c.__len__ = lambda: 5
    >>> len(c)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: object of type 'C' has no len()

The rationale behind this behaviour lies with a number of special
methods such as *Note __hash__(): 349. and *Note __repr__(): 4a3. that
are implemented by all objects, including type objects. If the implicit
lookup of these methods used the conventional lookup process, they
would fail when invoked on the type object itself:

    >>> 1 .__hash__() == hash(1)
    True
    >>> int.__hash__() == hash(int)
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: descriptor '__hash__' of 'int' object needs an argument

Incorrectly attempting to invoke an unbound method of a class in this
way is sometimes referred to as ‘metaclass confusion’, and is
avoided by bypassing the instance when looking up special methods:

    >>> type(1).__hash__(1) == hash(1)
    True
    >>> type(int).__hash__(int) == hash(int)
    True

In addition to bypassing any instance attributes in the interest of
correctness, implicit special method lookup generally also bypasses the
*Note __getattribute__(): 34f. method even of the object’s metaclass:

    >>> class Meta(type):
    ...    def __getattribute__(*args):
    ...       print "Metaclass getattribute invoked"
    ...       return type.__getattribute__(*args)
    ...
    >>> class C(object):
    ...     __metaclass__ = Meta
    ...     def __len__(self):
    ...         return 10
    ...     def __getattribute__(*args):
    ...         print "Class getattribute invoked"
    ...         return object.__getattribute__(*args)
    ...
    >>> c = C()
    >>> c.__len__()                 # Explicit lookup via instance
    Class getattribute invoked
    10
    >>> type(c).__len__(c)          # Explicit lookup via type
    Metaclass getattribute invoked
    10
    >>> len(c)                      # Implicit lookup
    10

Bypassing the *Note __getattribute__(): 34f. machinery in this fashion
provides significant scope for speed optimisations within the
interpreter, at the cost of some flexibility in the handling of special
methods (the special method `must' be set on the class object itself in
order to be consistently invoked by the interpreter).


File: python.info,  Node: Execution model,  Next: Expressions,  Prev: Data model,  Up: The Python Language Reference

4.4 Execution model
===================

* Menu:

* Naming and binding::
* Exceptions: Exceptions<2>.


File: python.info,  Node: Naming and binding,  Next: Exceptions<2>,  Up: Execution model

4.4.1 Naming and binding
------------------------

`Names' refer to objects.  Names are introduced by name binding
operations.  Each occurrence of a name in the program text refers to
the `binding' of that name established in the innermost function block
containing the use.

A `block' is a piece of Python program text that is executed as a unit.
The following are blocks: a module, a function body, and a class
definition.  Each command typed interactively is a block.  A script
file (a file given as standard input to the interpreter or specified on
the interpreter command line the first argument) is a code block.  A
script command (a command specified on the interpreter command line
with the ‘`-c'’ option) is a code block.  The file read by the
built-in function *Note execfile(): 44f. is a code block.  The string
argument passed to the built-in function *Note eval(): 378. and to the
*Note exec: 41d.  statement is a code block. The expression read and
evaluated by the built-in function *Note input(): 3d9. is a code block.

A code block is executed in an `execution frame'.  A frame contains some
administrative information (used for debugging) and determines where
and how execution continues after the code block’s execution has
completed.

A `scope' defines the visibility of a name within a block.  If a local
variable is defined in a block, its scope includes that block.  If the
definition occurs in a function block, the scope extends to any blocks
contained within the defining one, unless a contained block introduces
a different binding for the name.  The scope of names defined in a
class block is limited to the class block; it does not extend to the
code blocks of methods – this includes generator expressions since
they are implemented using a function scope.  This means that the
following will fail:

    class A:
        a = 42
        b = list(a + i for i in range(10))

When a name is used in a code block, it is resolved using the nearest
enclosing scope.  The set of all such scopes visible to a code block is
called the block’s `environment'.

If a name is bound in a block, it is a local variable of that block. If
a name is bound at the module level, it is a global variable.  (The
variables of the module code block are local and global.)  If a
variable is used in a code block but not defined there, it is a `free
variable'.

When a name is not found at all, a *Note NameError: 3bb. exception is
raised.  If the name refers to a local variable that has not been
bound, a *Note UnboundLocalError: 4ff. exception is raised.  *Note
UnboundLocalError: 4ff. is a subclass of *Note NameError: 3bb.

The following constructs bind names: formal parameters to functions,
*Note import: 1f4. statements, class and function definitions (these
bind the class or function name in the defining block), and targets
that are identifiers if occurring in an assignment, *Note for: 303.
loop header, in the second position of an *Note except: 3af. clause
header or after *Note as: 30b. in a *Note with: 1c1. statement.  The
*Note import: 1f4. statement of the form `from ... import *' binds all
names defined in the imported module, except those beginning with an
underscore.  This form may only be used at the module level.

A target occurring in a *Note del: 585. statement is also considered
bound for this purpose (though the actual semantics are to unbind the
name).  It is illegal to unbind a name that is referenced by an
enclosing scope; the compiler will report a *Note SyntaxError: 4b4.

Each assignment or import statement occurs within a block defined by a
class or function definition or at the module level (the top-level code
block).

If a name binding operation occurs anywhere within a code block, all
uses of the name within the block are treated as references to the
current block.  This can lead to errors when a name is used within a
block before it is bound. This rule is subtle.  Python lacks
declarations and allows name binding operations to occur anywhere
within a code block.  The local variables of a code block can be
determined by scanning the entire text of the block for name binding
operations.

If the global statement occurs within a block, all uses of the name
specified in the statement refer to the binding of that name in the
top-level namespace.  Names are resolved in the top-level namespace by
searching the global namespace, i.e. the namespace of the module
containing the code block, and the builtins namespace, the namespace of
the module *Note __builtin__: 0.  The global namespace is searched
first.  If the name is not found there, the builtins namespace is
searched.  The global statement must precede all uses of the name.

The builtins namespace associated with the execution of a code block is
actually found by looking up the name `__builtins__' in its global
namespace; this should be a dictionary or a module (in the latter case
the module’s dictionary is used).  By default, when in the *Note
__main__: 2. module, `__builtins__' is the built-in module *Note
__builtin__: 0. (note: no ‘s’); when in any other module,
`__builtins__' is an alias for the dictionary of the *Note __builtin__:
0. module itself.  `__builtins__' can be set to a user-created
dictionary to create a weak form of restricted execution.

`CPython implementation detail:' Users should not touch `__builtins__';
it is strictly an implementation detail.  Users wanting to override
values in the builtins namespace should *Note import: 1f4. the *Note
__builtin__: 0. (no ‘s’) module and modify its attributes
appropriately.

The namespace for a module is automatically created the first time a
module is imported.  The main module for a script is always called
*Note __main__: 2.

The *Note global: 560. statement has the same scope as a name binding
operation in the same block.  If the nearest enclosing scope for a free
variable contains a global statement, the free variable is treated as a
global.

A class definition is an executable statement that may use and define
names.  These references follow the normal rules for name resolution.
The namespace of the class definition becomes the attribute dictionary
of the class.  Names defined at the class scope are not visible in
methods.

* Menu:

* Interaction with dynamic features::


File: python.info,  Node: Interaction with dynamic features,  Up: Naming and binding

4.4.1.1 Interaction with dynamic features
.........................................

There are several cases where Python statements are illegal when used in
conjunction with nested scopes that contain free variables.

If a variable is referenced in an enclosing scope, it is illegal to
delete the name.  An error will be reported at compile time.

If the wild card form of import — `import *' — is used in a
function and the function contains or is a nested block with free
variables, the compiler will raise a *Note SyntaxError: 4b4.

If *Note exec: 41d. is used in a function and the function contains or
is a nested block with free variables, the compiler will raise a *Note
SyntaxError: 4b4.  unless the exec explicitly specifies the local
namespace for the *Note exec: 41d.  (In other words, `exec obj' would
be illegal, but `exec obj in ns' would be legal.)

The *Note eval(): 378, *Note execfile(): 44f, and *Note input(): 3d9.
functions and the *Note exec: 41d. statement do not have access to the
full environment for resolving names.  Names may be resolved in the
local and global namespaces of the caller.  Free variables are not
resolved in the nearest enclosing namespace, but in the global
namespace. (1) The *Note exec: 41d. statement and the *Note eval():
378. and *Note execfile(): 44f. functions have optional arguments to
override the global and local namespace.  If only one namespace is
specified, it is used for both.

---------- Footnotes ----------

(1) This limitation occurs because the code that is executed by these
operations is not available at the time the module is compiled.


File: python.info,  Node: Exceptions<2>,  Prev: Naming and binding,  Up: Execution model

4.4.2 Exceptions
----------------

Exceptions are a means of breaking out of the normal flow of control of
a code block in order to handle errors or other exceptional conditions.
An exception is `raised' at the point where the error is detected; it
may be `handled' by the surrounding code block or by any code block
that directly or indirectly invoked the code block where the error
occurred.

The Python interpreter raises an exception when it detects a run-time
error (such as division by zero).  A Python program can also explicitly
raise an exception with the *Note raise: 5cc. statement. Exception
handlers are specified with the *Note try: 3ad. … *Note except: 3af.
statement.  The *Note finally: 3ae.  clause of such a statement can be
used to specify cleanup code which does not handle the exception, but
is executed whether an exception occurred or not in the preceding code.

Python uses the “termination” model of error handling: an exception
handler can find out what happened and continue execution at an outer
level, but it cannot repair the cause of the error and retry the
failing operation (except by re-entering the offending piece of code
from the top).

When an exception is not handled at all, the interpreter terminates
execution of the program, or returns to its interactive main loop.  In
either case, it prints a stack backtrace, except when the exception is
*Note SystemExit: 346.

Exceptions are identified by class instances.  The *Note except: 3af.
clause is selected depending on the class of the instance: it must
reference the class of the instance or a base class thereof.  The
instance can be received by the handler and can carry additional
information about the exceptional condition.

Exceptions can also be identified by strings, in which case the *Note
except: 3af. clause is selected by object identity.  An arbitrary value
can be raised along with the identifying string which can be passed to
the handler.

     Note: Messages to exceptions are not part of the Python API.
     Their contents may change from one version of Python to the next
     without warning and should not be relied on by code which will run
     under multiple versions of the interpreter.

See also the description of the *Note try: 3ad. statement in section
*Note The try statement: 3ad.  and *Note raise: 5cc. statement in
section *Note The raise statement: 5cc.


File: python.info,  Node: Expressions,  Next: Simple statements,  Prev: Execution model,  Up: The Python Language Reference

4.5 Expressions
===============

This chapter explains the meaning of the elements of expressions in
Python.

`Syntax Notes:' In this and the following chapters, extended BNF
notation will be used to describe syntax, not lexical analysis.  When
(one alternative of) a syntax rule has the form

    name ::= othername

and no semantics are given, the semantics of this form of `name' are
the same as for `othername'.

* Menu:

* Arithmetic conversions::
* Atoms::
* Primaries::
* The power operator::
* Unary arithmetic and bitwise operations::
* Binary arithmetic operations::
* Shifting operations::
* Binary bitwise operations::
* Comparisons::
* Boolean operations::
* Conditional Expressions::
* Lambdas::
* Expression lists::
* Evaluation order::
* Operator precedence::


File: python.info,  Node: Arithmetic conversions,  Next: Atoms,  Up: Expressions

4.5.1 Arithmetic conversions
----------------------------

When a description of an arithmetic operator below uses the phrase
“the numeric arguments are converted to a common type,” the
arguments are coerced using the coercion rules listed at  *Note
Coercion rules: 787.  If both arguments are standard numeric types, the
following coercions are applied:

   * If either argument is a complex number, the other is converted to
     complex;

   * otherwise, if either argument is a floating point number, the
     other is converted to floating point;

   * otherwise, if either argument is a long integer, the other is
     converted to long integer;

   * otherwise, both must be plain integers and no conversion is
     necessary.

Some additional rules apply for certain operators (e.g., a string left
argument to the ‘%’ operator). Extensions can define their own
coercions.


File: python.info,  Node: Atoms,  Next: Primaries,  Prev: Arithmetic conversions,  Up: Expressions

4.5.2 Atoms
-----------

Atoms are the most basic elements of expressions.  The simplest atoms
are identifiers or literals.  Forms enclosed in reverse quotes or in
parentheses, brackets or braces are also categorized syntactically as
atoms.  The syntax for atoms is:

    atom      ::= identifier | literal | enclosure
    enclosure ::= parenth_form | list_display
                  | generator_expression | dict_display | set_display
                  | string_conversion | yield_atom

* Menu:

* Identifiers (Names): Identifiers Names.
* Literals: Literals<2>.
* Parenthesized forms::
* List displays::
* Displays for sets and dictionaries::
* Generator expressions::
* Dictionary displays::
* Set displays::
* String conversions::
* Yield expressions::


File: python.info,  Node: Identifiers Names,  Next: Literals<2>,  Up: Atoms

4.5.2.1 Identifiers (Names)
...........................

An identifier occurring as an atom is a name.  See section *Note
Identifiers and keywords: 6da.  for lexical definition and section
*Note Naming and binding: 793. for documentation of naming and binding.

When the name is bound to an object, evaluation of the atom yields that
object.  When a name is not bound, an attempt to evaluate it raises a
*Note NameError: 3bb.  exception.

`Private name mangling:' When an identifier that textually occurs in a
class definition begins with two or more underscore characters and does
not end in two or more underscores, it is considered a `private name'
of that class.  Private names are transformed to a longer form before
code is generated for them.  The transformation inserts the class name,
with leading underscores removed and a single underscore inserted, in
front of the name.  For example, the identifier `__spam' occurring in a
class named `Ham' will be transformed to `_Ham__spam'.  This
transformation is independent of the syntactical context in which the
identifier is used.  If the transformed name is extremely long (longer
than 255 characters), implementation defined truncation may happen.  If
the class name consists only of underscores, no transformation is done.


File: python.info,  Node: Literals<2>,  Next: Parenthesized forms,  Prev: Identifiers Names,  Up: Atoms

4.5.2.2 Literals
................

Python supports string literals and various numeric literals:

    literal ::= stringliteral | integer | longinteger
                | floatnumber | imagnumber

Evaluation of a literal yields an object of the given type (string,
integer, long integer, floating point number, complex number) with the
given value.  The value may be approximated in the case of floating
point and imaginary (complex) literals.  See section *Note Literals:
6e7. for details.

All literals correspond to immutable data types, and hence the
object’s identity is less important than its value.  Multiple
evaluations of literals with the same value (either the same occurrence
in the program text or a different occurrence) may obtain the same
object or a different object with the same value.


File: python.info,  Node: Parenthesized forms,  Next: List displays,  Prev: Literals<2>,  Up: Atoms

4.5.2.3 Parenthesized forms
...........................

A parenthesized form is an optional expression list enclosed in
parentheses:

    parenth_form ::= "(" [expression_list] ")"

A parenthesized expression list yields whatever that expression list
yields: if the list contains at least one comma, it yields a tuple;
otherwise, it yields the single expression that makes up the expression
list.

An empty pair of parentheses yields an empty tuple object.  Since
tuples are immutable, the rules for literals apply (i.e., two
occurrences of the empty tuple may or may not yield the same object).

Note that tuples are not formed by the parentheses, but rather by use
of the comma operator.  The exception is the empty tuple, for which
parentheses `are' required — allowing unparenthesized “nothing”
in expressions would cause ambiguities and allow common typos to pass
uncaught.


File: python.info,  Node: List displays,  Next: Displays for sets and dictionaries,  Prev: Parenthesized forms,  Up: Atoms

4.5.2.4 List displays
.....................

A list display is a possibly empty series of expressions enclosed in
square brackets:

    list_display        ::= "[" [expression_list | list_comprehension] "]"
    list_comprehension  ::= expression list_for
    list_for            ::= "for" target_list "in" old_expression_list [list_iter]
    old_expression_list ::= old_expression [("," old_expression)+ [","]]
    old_expression      ::= or_test | old_lambda_expr
    list_iter           ::= list_for | list_if
    list_if             ::= "if" old_expression [list_iter]

A list display yields a new list object.  Its contents are specified by
providing either a list of expressions or a list comprehension.  When a
comma-separated list of expressions is supplied, its elements are
evaluated from left to right and placed into the list object in that
order.  When a list comprehension is supplied, it consists of a single
expression followed by at least one *Note for: 303. clause and zero or
more *Note for: 303. or *Note if: 445.  clauses.  In this case, the
elements of the new list are those that would be produced by
considering each of the *Note for: 303. or *Note if: 445. clauses a
block, nesting from left to right, and evaluating the expression to
produce a list element each time the innermost block is reached (1).

---------- Footnotes ----------

(1) In Python 2.3 and later releases, a list comprehension “leaks”
the control variables of each `for' it contains into the containing
scope.  However, this behavior is deprecated, and relying on it will
not work in Python 3.


File: python.info,  Node: Displays for sets and dictionaries,  Next: Generator expressions,  Prev: List displays,  Up: Atoms

4.5.2.5 Displays for sets and dictionaries
..........................................

For constructing a set or a dictionary Python provides special syntax
called “displays”, each of them in two flavors:

   * either the container contents are listed explicitly, or

   * they are computed via a set of looping and filtering instructions,
     called a `comprehension'.

Common syntax elements for comprehensions are:

    comprehension ::= expression comp_for
    comp_for      ::= "for" target_list "in" or_test [comp_iter]
    comp_iter     ::= comp_for | comp_if
    comp_if       ::= "if" expression_nocond [comp_iter]

The comprehension consists of a single expression followed by at least
one *Note for: 303. clause and zero or more *Note for: 303. or *Note
if: 445. clauses.  In this case, the elements of the new container are
those that would be produced by considering each of the *Note for: 303.
or *Note if: 445. clauses a block, nesting from left to right, and
evaluating the expression to produce an element each time the innermost
block is reached.

Note that the comprehension is executed in a separate scope, so names
assigned to in the target list don’t “leak” in the enclosing
scope.


File: python.info,  Node: Generator expressions,  Next: Dictionary displays,  Prev: Displays for sets and dictionaries,  Up: Atoms

4.5.2.6 Generator expressions
.............................

A generator expression is a compact generator notation in parentheses:

    generator_expression ::= "(" expression comp_for ")"

A generator expression yields a new generator object.  Its syntax is
the same as for comprehensions, except that it is enclosed in
parentheses instead of brackets or curly braces.

Variables used in the generator expression are evaluated lazily when the
`__next__()' method is called for generator object (in the same fashion
as normal generators).  However, the leftmost *Note for: 303. clause is
immediately evaluated, so that an error produced by it can be seen
before any other possible error in the code that handles the generator
expression.  Subsequent *Note for: 303. clauses cannot be evaluated
immediately since they may depend on the previous *Note for: 303. loop.
For example: `(x*y for x in range(10) for y in bar(x))'.

The parentheses can be omitted on calls with only one argument.  See
section *Note Calls: 722. for the detail.


File: python.info,  Node: Dictionary displays,  Next: Set displays,  Prev: Generator expressions,  Up: Atoms

4.5.2.7 Dictionary displays
...........................

A dictionary display is a possibly empty series of key/datum pairs
enclosed in curly braces:

    dict_display       ::= "{" [key_datum_list | dict_comprehension] "}"
    key_datum_list     ::= key_datum ("," key_datum)* [","]
    key_datum          ::= expression ":" expression
    dict_comprehension ::= expression ":" expression comp_for

A dictionary display yields a new dictionary object.

If a comma-separated sequence of key/datum pairs is given, they are
evaluated from left to right to define the entries of the dictionary:
each key object is used as a key into the dictionary to store the
corresponding datum.  This means that you can specify the same key
multiple times in the key/datum list, and the final dictionary’s
value for that key will be the last one given.

A dict comprehension, in contrast to list and set comprehensions, needs
two expressions separated with a colon followed by the usual “for”
and “if” clauses.  When the comprehension is run, the resulting key
and value elements are inserted in the new dictionary in the order they
are produced.

Restrictions on the types of the key values are listed earlier in
section *Note The standard type hierarchy: 719.  (To summarize, the key
type should be *Note hashable: 720, which excludes all mutable
objects.)  Clashes between duplicate keys are not detected; the last
datum (textually rightmost in the display) stored for a given key value
prevails.


File: python.info,  Node: Set displays,  Next: String conversions,  Prev: Dictionary displays,  Up: Atoms

4.5.2.8 Set displays
....................

A set display is denoted by curly braces and distinguishable from
dictionary displays by the lack of colons separating keys and values:

    set_display ::= "{" (expression_list | comprehension) "}"

A set display yields a new mutable set object, the contents being
specified by either a sequence of expressions or a comprehension.  When
a comma-separated list of expressions is supplied, its elements are
evaluated from left to right and added to the set object.  When a
comprehension is supplied, the set is constructed from the elements
resulting from the comprehension.

An empty set cannot be constructed with `{}'; this literal constructs
an empty dictionary.


File: python.info,  Node: String conversions,  Next: Yield expressions,  Prev: Set displays,  Up: Atoms

4.5.2.9 String conversions
..........................

A string conversion is an expression list enclosed in reverse (a.k.a.
backward) quotes:

    string_conversion ::= "`" expression_list "`"

A string conversion evaluates the contained expression list and
converts the resulting object into a string according to rules specific
to its type.

If the object is a string, a number, `None', or a tuple, list or
dictionary containing only objects whose type is one of these, the
resulting string is a valid Python expression which can be passed to
the built-in function *Note eval(): 378. to yield an expression with
the same value (or an approximation, if floating point numbers are
involved).

(In particular, converting a string adds quotes around it and converts
“funny” characters to escape sequences that are safe to print.)

Recursive objects (for example, lists or dictionaries that contain a
reference to themselves, directly or indirectly) use `...' to indicate
a recursive reference, and the result cannot be passed to *Note eval():
378. to get an equal value (*Note SyntaxError: 4b4. will be raised
instead).

The built-in function *Note repr(): 1c6. performs exactly the same
conversion in its argument as enclosing it in parentheses and reverse
quotes does.  The built-in function *Note str(): 1ea. performs a
similar but more user-friendly conversion.


File: python.info,  Node: Yield expressions,  Prev: String conversions,  Up: Atoms

4.5.2.10 Yield expressions
..........................

    yield_atom       ::= "(" yield_expression ")"
    yield_expression ::= "yield" [expression_list]

New in version 2.5.

The *Note yield: 30a. expression is only used when defining a generator
function, and can only be used in the body of a function definition.
Using a *Note yield: 30a. expression in a function definition is
sufficient to cause that definition to create a generator function
instead of a normal function.

When a generator function is called, it returns an iterator known as a
generator.  That generator then controls the execution of a generator
function.  The execution starts when one of the generator’s methods
is called.  At that time, the execution proceeds to the first *Note
yield: 30a. expression, where it is suspended again, returning the
value of *Note expression_list: 7cb. to generator’s caller.  By
suspended we mean that all local state is retained, including the
current bindings of local variables, the instruction pointer, and the
internal evaluation stack.  When the execution is resumed by calling
one of the generator’s methods, the function can proceed exactly as
if the *Note yield: 30a. expression was just another external call. The
value of the *Note yield: 30a. expression after resuming depends on the
method which resumed the execution.

All of this makes generator functions quite similar to coroutines; they
yield multiple times, they have more than one entry point and their
execution can be suspended.  The only difference is that a generator
function cannot control where should the execution continue after it
yields; the control is always transferred to the generator’s caller.

* Menu:

* Generator-iterator methods::


File: python.info,  Node: Generator-iterator methods,  Up: Yield expressions

4.5.2.11 Generator-iterator methods
...................................

This subsection describes the methods of a generator iterator.  They can
be used to control the execution of a generator function.

Note that calling any of the generator methods below when the generator
is already executing raises a *Note ValueError: 236. exception.

 -- Method: generator.next ()
     Starts the execution of a generator function or resumes it at the
     last executed *Note yield: 30a. expression.  When a generator
     function is resumed with a *Note next(): 5f8. method, the current
     *Note yield: 30a. expression always evaluates to *Note None: 3b2.
     The execution then continues to the next *Note yield: 30a.
     expression, where the generator is suspended again, and the value
     of the *Note expression_list: 7cb. is returned to *Note next():
     5f8.’s caller.  If the generator exits without yielding another
     value, a *Note StopIteration: 347. exception is raised.

 -- Method: generator.send (value)
     Resumes the execution and “sends” a value into the generator
     function.  The `value' argument becomes the result of the current
     *Note yield: 30a.  expression.  The *Note send(): 7cd. method
     returns the next value yielded by the generator, or raises *Note
     StopIteration: 347. if the generator exits without yielding
     another value. When *Note send(): 7cd. is called to start the
     generator, it must be called with *Note None: 3b2. as the
     argument, because there is no *Note yield: 30a. expression that
     could receive the value.

 -- Method: generator.throw (type[, value[, traceback]])
     Raises an exception of type `type' at the point where generator
     was paused, and returns the next value yielded by the generator
     function.  If the generator exits without yielding another value,
     a *Note StopIteration: 347. exception is raised.  If the generator
     function does not catch the passed-in exception, or raises a
     different exception, then that exception propagates to the caller.

 -- Method: generator.close ()
     Raises a *Note GeneratorExit: 34b. at the point where the
     generator function was paused.  If the generator function then
     raises *Note StopIteration: 347. (by exiting normally, or due to
     already being closed) or *Note GeneratorExit: 34b. (by not
     catching the exception), close returns to its caller.  If the
     generator yields a value, a *Note RuntimeError: 3b3. is raised.
     If the generator raises any other exception, it is propagated to
     the caller.  *Note close(): 7cf. does nothing if the generator has
     already exited due to an exception or normal exit.

Here is a simple example that demonstrates the behavior of generators
and generator functions:

    >>> def echo(value=None):
    ...     print "Execution starts when 'next()' is called for the first time."
    ...     try:
    ...         while True:
    ...             try:
    ...                 value = (yield value)
    ...             except Exception, e:
    ...                 value = e
    ...     finally:
    ...         print "Don't forget to clean up when 'close()' is called."
    ...
    >>> generator = echo(1)
    >>> print generator.next()
    Execution starts when 'next()' is called for the first time.
    1
    >>> print generator.next()
    None
    >>> print generator.send(2)
    2
    >>> generator.throw(TypeError, "spam")
    TypeError('spam',)
    >>> generator.close()
    Don't forget to clean up when 'close()' is called.

See also
........

PEP 342(1) - Coroutines via Enhanced Generators
     The proposal to enhance the API and syntax of generators, making
     them usable as simple coroutines.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0342


File: python.info,  Node: Primaries,  Next: The power operator,  Prev: Atoms,  Up: Expressions

4.5.3 Primaries
---------------

Primaries represent the most tightly bound operations of the language.
Their syntax is:

    primary ::= atom | attributeref | subscription | slicing | call

* Menu:

* Attribute references::
* Subscriptions::
* Slicings::
* Calls::


File: python.info,  Node: Attribute references,  Next: Subscriptions,  Up: Primaries

4.5.3.1 Attribute references
............................

An attribute reference is a primary followed by a period and a name:

    attributeref ::= primary "." identifier

The primary must evaluate to an object of a type that supports attribute
references, e.g., a module, list, or an instance.  This object is then
asked to produce the attribute whose name is the identifier.  If this
attribute is not available, the exception *Note AttributeError: 1f8. is
raised. Otherwise, the type and value of the object produced is
determined by the object.  Multiple evaluations of the same attribute
reference may yield different objects.


File: python.info,  Node: Subscriptions,  Next: Slicings,  Prev: Attribute references,  Up: Primaries

4.5.3.2 Subscriptions
.....................

A subscription selects an item of a sequence (string, tuple or list) or
mapping (dictionary) object:

    subscription ::= primary "[" expression_list "]"

The primary must evaluate to an object of a sequence or mapping type.

If the primary is a mapping, the expression list must evaluate to an
object whose value is one of the keys of the mapping, and the
subscription selects the value in the mapping that corresponds to that
key.  (The expression list is a tuple except if it has exactly one
item.)

If the primary is a sequence, the expression (list) must evaluate to a
plain integer.  If this value is negative, the length of the sequence
is added to it (so that, e.g., `x[-1]' selects the last item of `x'.)
The resulting value must be a nonnegative integer less than the number
of items in the sequence, and the subscription selects the item whose
index is that value (counting from zero).

A string’s items are characters.  A character is not a separate data
type but a string of exactly one character.


File: python.info,  Node: Slicings,  Next: Calls,  Prev: Subscriptions,  Up: Primaries

4.5.3.3 Slicings
................

A slicing selects a range of items in a sequence object (e.g., a
string, tuple or list).  Slicings may be used as expressions or as
targets in assignment or *Note del: 585. statements.  The syntax for a
slicing:

    slicing          ::= simple_slicing | extended_slicing
    simple_slicing   ::= primary "[" short_slice "]"
    extended_slicing ::= primary "[" slice_list "]"
    slice_list       ::= slice_item ("," slice_item)* [","]
    slice_item       ::= expression | proper_slice | ellipsis
    proper_slice     ::= short_slice | long_slice
    short_slice      ::= [lower_bound] ":" [upper_bound]
    long_slice       ::= short_slice ":" [stride]
    lower_bound      ::= expression
    upper_bound      ::= expression
    stride           ::= expression
    ellipsis         ::= "..."

There is ambiguity in the formal syntax here: anything that looks like
an expression list also looks like a slice list, so any subscription
can be interpreted as a slicing.  Rather than further complicating the
syntax, this is disambiguated by defining that in this case the
interpretation as a subscription takes priority over the interpretation
as a slicing (this is the case if the slice list contains no proper
slice nor ellipses).  Similarly, when the slice list has exactly one
short slice and no trailing comma, the interpretation as a simple
slicing takes priority over that as an extended slicing.

The semantics for a simple slicing are as follows.  The primary must
evaluate to a sequence object.  The lower and upper bound expressions,
if present, must evaluate to plain integers; defaults are zero and the
`sys.maxint', respectively.  If either bound is negative, the
sequence’s length is added to it.  The slicing now selects all items
with index `k' such that `i <= k < j' where `i' and `j' are the
specified lower and upper bounds.  This may be an empty sequence.  It
is not an error if `i' or `j' lie outside the range of valid indexes
(such items don’t exist so they aren’t selected).

The semantics for an extended slicing are as follows.  The primary must
evaluate to a mapping object, and it is indexed with a key that is
constructed from the slice list, as follows.  If the slice list
contains at least one comma, the key is a tuple containing the
conversion of the slice items; otherwise, the conversion of the lone
slice item is the key.  The conversion of a slice item that is an
expression is that expression.  The conversion of an ellipsis slice
item is the built-in `Ellipsis' object.  The conversion of a proper
slice is a slice object (see section *Note The standard type hierarchy:
719.) whose `start', `stop' and `step' attributes are the values of the
expressions given as lower bound, upper bound and stride, respectively,
substituting `None' for missing expressions.


File: python.info,  Node: Calls,  Prev: Slicings,  Up: Primaries

4.5.3.4 Calls
.............

A call calls a callable object (e.g., a *Note function: 7e8.) with a
possibly empty series of *Note arguments: 7e9.:

    call                 ::= primary "(" [argument_list [","]
                             | expression genexpr_for] ")"
    argument_list        ::= positional_arguments ["," keyword_arguments]
                               ["," "*" expression] ["," keyword_arguments]
                               ["," "**" expression]
                             | keyword_arguments ["," "*" expression]
                               ["," "**" expression]
                             | "*" expression ["," keyword_arguments] ["," "**" expression]
                             | "**" expression
    positional_arguments ::= expression ("," expression)*
    keyword_arguments    ::= keyword_item ("," keyword_item)*
    keyword_item         ::= identifier "=" expression

A trailing comma may be present after the positional and keyword
arguments but does not affect the semantics.

The primary must evaluate to a callable object (user-defined functions,
built-in functions, methods of built-in objects, class objects, methods
of class instances, and certain class instances themselves are
callable; extensions may define additional callable object types).  All
argument expressions are evaluated before the call is attempted.
Please refer to section *Note Function definitions: 723.  for the
syntax of formal *Note parameter: 7ef. lists.

If keyword arguments are present, they are first converted to positional
arguments, as follows.  First, a list of unfilled slots is created for
the formal parameters.  If there are N positional arguments, they are
placed in the first N slots.  Next, for each keyword argument, the
identifier is used to determine the corresponding slot (if the
identifier is the same as the first formal parameter name, the first
slot is used, and so on).  If the slot is already filled, a *Note
TypeError: 218. exception is raised. Otherwise, the value of the
argument is placed in the slot, filling it (even if the expression is
`None', it fills the slot).  When all arguments have been processed,
the slots that are still unfilled are filled with the corresponding
default value from the function definition.  (Default values are
calculated, once, when the function is defined; thus, a mutable object
such as a list or dictionary used as default value will be shared by
all calls that don’t specify an argument value for the corresponding
slot; this should usually be avoided.)  If there are any unfilled slots
for which no default value is specified, a *Note TypeError: 218.
exception is raised.  Otherwise, the list of filled slots is used as
the argument list for the call.

`CPython implementation detail:' An implementation may provide built-in
functions whose positional parameters do not have names, even if they
are ‘named’ for the purpose of documentation, and which therefore
cannot be supplied by keyword.  In CPython, this is the case for
functions implemented in C that use *Note PyArg_ParseTuple(): 32f. to
parse their arguments.

If there are more positional arguments than there are formal parameter
slots, a *Note TypeError: 218. exception is raised, unless a formal
parameter using the syntax `*identifier' is present; in this case, that
formal parameter receives a tuple containing the excess positional
arguments (or an empty tuple if there were no excess positional
arguments).

If any keyword argument does not correspond to a formal parameter name,
a *Note TypeError: 218. exception is raised, unless a formal parameter
using the syntax `**identifier' is present; in this case, that formal
parameter receives a dictionary containing the excess keyword arguments
(using the keywords as keys and the argument values as corresponding
values), or a (new) empty dictionary if there were no excess keyword
arguments.

If the syntax `*expression' appears in the function call, `expression'
must evaluate to an iterable.  Elements from this iterable are treated
as if they were additional positional arguments; if there are
positional arguments `x1', …, `xN', and `expression' evaluates to a
sequence `y1', …, `yM', this is equivalent to a call with M+N
positional arguments `x1', …, `xN', `y1', …, `yM'.

A consequence of this is that although the `*expression' syntax may
appear `after' some keyword arguments, it is processed `before' the
keyword arguments (and the `**expression' argument, if any – see
below).  So:

    >>> def f(a, b):
    ...     print a, b
    ...
    >>> f(b=1, *(2,))
    2 1
    >>> f(a=1, *(2,))
    Traceback (most recent call last):
      File "<stdin>", line 1, in ?
    TypeError: f() got multiple values for keyword argument 'a'
    >>> f(1, *(2,))
    1 2

It is unusual for both keyword arguments and the `*expression' syntax
to be used in the same call, so in practice this confusion does not
arise.

If the syntax `**expression' appears in the function call, `expression'
must evaluate to a mapping, the contents of which are treated as
additional keyword arguments.  In the case of a keyword appearing in
both `expression' and as an explicit keyword argument, a *Note
TypeError: 218. exception is raised.

Formal parameters using the syntax `*identifier' or `**identifier'
cannot be used as positional argument slots or as keyword argument
names.  Formal parameters using the syntax `(sublist)' cannot be used
as keyword argument names; the outermost sublist corresponds to a
single unnamed argument slot, and the argument value is assigned to the
sublist using the usual tuple assignment rules after all other
parameter processing is done.

A call always returns some value, possibly `None', unless it raises an
exception.  How this value is computed depends on the type of the
callable object.

If it is—

a user-defined function:
     The code block for the function is executed, passing it the
     argument list.  The first thing the code block will do is bind the
     formal parameters to the arguments; this is described in section
     *Note Function definitions: 723.  When the code block executes a
     *Note return: 307. statement, this specifies the return value of
     the function call.

a built-in function or method:
     The result is up to the interpreter; see *Note Built-in Functions:
     7f0. for the descriptions of built-in functions and methods.

a class object:
     A new instance of that class is returned.

a class instance method:
     The corresponding user-defined function is called, with an
     argument list that is one longer than the argument list of the
     call: the instance becomes the first argument.

a class instance:
     The class must define a *Note __call__(): 725. method; the effect
     is then the same as if that method was called.


File: python.info,  Node: The power operator,  Next: Unary arithmetic and bitwise operations,  Prev: Primaries,  Up: Expressions

4.5.4 The power operator
------------------------

The power operator binds more tightly than unary operators on its left;
it binds less tightly than unary operators on its right.  The syntax is:

    power ::= primary ["**" u_expr]

Thus, in an unparenthesized sequence of power and unary operators, the
operators are evaluated from right to left (this does not constrain the
evaluation order for the operands): `-1**2' results in `-1'.

The power operator has the same semantics as the built-in *Note pow():
4d1. function, when called with two arguments: it yields its left
argument raised to the power of its right argument.  The numeric
arguments are first converted to a common type.  The result type is
that of the arguments after coercion.

With mixed operand types, the coercion rules for binary arithmetic
operators apply. For int and long int operands, the result has the same
type as the operands (after coercion) unless the second argument is
negative; in that case, all arguments are converted to float and a
float result is delivered. For example, `10**2' returns `100', but
`10**-2' returns `0.01'. (This last feature was added in Python 2.2. In
Python 2.1 and before, if both arguments were of integer types and the
second argument was negative, an exception was raised).

Raising `0.0' to a negative power results in a *Note ZeroDivisionError:
5c7.  Raising a negative number to a fractional power results in a
*Note ValueError: 236.


File: python.info,  Node: Unary arithmetic and bitwise operations,  Next: Binary arithmetic operations,  Prev: The power operator,  Up: Expressions

4.5.5 Unary arithmetic and bitwise operations
---------------------------------------------

All unary arithmetic and bitwise operations have the same priority:

    u_expr ::= power | "-" u_expr | "+" u_expr | "~" u_expr

The unary `-' (minus) operator yields the negation of its numeric
argument.

The unary `+' (plus) operator yields its numeric argument unchanged.

The unary `~' (invert) operator yields the bitwise inversion of its
plain or long integer argument.  The bitwise inversion of `x' is
defined as `-(x+1)'.  It only applies to integral numbers.

In all three cases, if the argument does not have the proper type, a
*Note TypeError: 218. exception is raised.


File: python.info,  Node: Binary arithmetic operations,  Next: Shifting operations,  Prev: Unary arithmetic and bitwise operations,  Up: Expressions

4.5.6 Binary arithmetic operations
----------------------------------

The binary arithmetic operations have the conventional priority levels.
Note that some of these operations also apply to certain non-numeric
types.  Apart from the power operator, there are only two levels, one
for multiplicative operators and one for additive operators:

    m_expr ::= u_expr | m_expr "*" u_expr | m_expr "//" u_expr | m_expr "/" u_expr
               | m_expr "%" u_expr
    a_expr ::= m_expr | a_expr "+" m_expr | a_expr "-" m_expr

The `*' (multiplication) operator yields the product of its arguments.
The arguments must either both be numbers, or one argument must be an
integer (plain or long) and the other must be a sequence. In the former
case, the numbers are converted to a common type and then multiplied
together.  In the latter case, sequence repetition is performed; a
negative repetition factor yields an empty sequence.

The `/' (division) and `//' (floor division) operators yield the
quotient of their arguments.  The numeric arguments are first converted
to a common type.  Plain or long integer division yields an integer of
the same type; the result is that of mathematical division with the
‘floor’ function applied to the result.  Division by zero raises
the *Note ZeroDivisionError: 5c7. exception.

The `%' (modulo) operator yields the remainder from the division of the
first argument by the second.  The numeric arguments are first
converted to a common type.  A zero right argument raises the *Note
ZeroDivisionError: 5c7. exception.  The arguments may be floating point
numbers, e.g., `3.14%0.7' equals `0.34' (since `3.14' equals `4*0.7 +
0.34'.)  The modulo operator always yields a result with the same sign
as its second operand (or zero); the absolute value of the result is
strictly smaller than the absolute value of the second operand (1).

The integer division and modulo operators are connected by the following
identity: `x == (x/y)*y + (x%y)'.  Integer division and modulo are also
connected with the built-in function *Note divmod(): 768.: `divmod(x,
y) == (x/y, x%y)'.  These identities don’t hold for floating point
numbers; there similar identities hold approximately where `x/y' is
replaced by `floor(x/y)' or `floor(x/y) - 1' (2).

In addition to performing the modulo operation on numbers, the `%'
operator is also overloaded by string and unicode objects to perform
string formatting (also known as interpolation). The syntax for string
formatting is described in the Python Library Reference, section *Note
String Formatting Operations: 53f.

Deprecated since version 2.3: The floor division operator, the modulo
operator, and the *Note divmod(): 768.  function are no longer defined
for complex numbers.  Instead, convert to a floating point number using
the *Note abs(): 5da. function if appropriate.

The `+' (addition) operator yields the sum of its arguments. The
arguments must either both be numbers or both sequences of the same
type.  In the former case, the numbers are converted to a common type
and then added together.  In the latter case, the sequences are
concatenated.

The `-' (subtraction) operator yields the difference of its arguments.
The numeric arguments are first converted to a common type.

---------- Footnotes ----------

(1) While `abs(x%y) < abs(y)' is true mathematically, for floats it may
not be true numerically due to roundoff.  For example, and assuming a
platform on which a Python float is an IEEE 754 double-precision
number, in order that `-1e-100 % 1e100' have the same sign as `1e100',
the computed result is `-1e-100 + 1e100', which is numerically exactly
equal to `1e100'.  The function *Note math.fmod(): 7fb. returns a
result whose sign matches the sign of the first argument instead, and
so returns `-1e-100' in this case. Which approach is more appropriate
depends on the application.

(2) If x is very close to an exact integer multiple of y, it’s
possible for `floor(x/y)' to be one larger than `(x-x%y)/y' due to
rounding.  In such cases, Python returns the latter result, in order to
preserve that `divmod(x,y)[0] * y + x % y' be very close to `x'.


File: python.info,  Node: Shifting operations,  Next: Binary bitwise operations,  Prev: Binary arithmetic operations,  Up: Expressions

4.5.7 Shifting operations
-------------------------

The shifting operations have lower priority than the arithmetic
operations:

    shift_expr ::= a_expr | shift_expr ( "<<" | ">>" ) a_expr

These operators accept plain or long integers as arguments.  The
arguments are converted to a common type.  They shift the first
argument to the left or right by the number of bits given by the second
argument.

A right shift by `n' bits is defined as division by `pow(2, n)'.  A
left shift by `n' bits is defined as multiplication with `pow(2, n)'.
Negative shift counts raise a *Note ValueError: 236. exception.

     Note: In the current implementation, the right-hand operand is
     required to be at most *Note sys.maxsize: 75a.  If the right-hand
     operand is larger than *Note sys.maxsize: 75a. an *Note
     OverflowError: 2dd. exception is raised.


File: python.info,  Node: Binary bitwise operations,  Next: Comparisons,  Prev: Shifting operations,  Up: Expressions

4.5.8 Binary bitwise operations
-------------------------------

Each of the three bitwise operations has a different priority level:

    and_expr ::= shift_expr | and_expr "&" shift_expr
    xor_expr ::= and_expr | xor_expr "^" and_expr
    or_expr  ::= xor_expr | or_expr "|" xor_expr

The `&' operator yields the bitwise AND of its arguments, which must be
plain or long integers.  The arguments are converted to a common type.

The `^' operator yields the bitwise XOR (exclusive OR) of its
arguments, which must be plain or long integers.  The arguments are
converted to a common type.

The `|' operator yields the bitwise (inclusive) OR of its arguments,
which must be plain or long integers.  The arguments are converted to a
common type.


File: python.info,  Node: Comparisons,  Next: Boolean operations,  Prev: Binary bitwise operations,  Up: Expressions

4.5.9 Comparisons
-----------------

Unlike C, all comparison operations in Python have the same priority,
which is lower than that of any arithmetic, shifting or bitwise
operation.  Also unlike C, expressions like `a < b < c' have the
interpretation that is conventional in mathematics:

    comparison    ::= or_expr ( comp_operator or_expr )*
    comp_operator ::= "<" | ">" | "==" | ">=" | "<=" | "<>" | "!="
                      | "is" ["not"] | ["not"] "in"

Comparisons yield boolean values: `True' or `False'.

Comparisons can be chained arbitrarily, e.g., `x < y <= z' is
equivalent to `x < y and y <= z', except that `y' is evaluated only
once (but in both cases `z' is not evaluated at all when `x < y' is
found to be false).

Formally, if `a', `b', `c', …, `y', `z' are expressions and `op1',
`op2', …, `opN' are comparison operators, then `a op1 b op2 c ... y
opN z' is equivalent to `a op1 b and b op2 c and ... y opN z', except
that each expression is evaluated at most once.

Note that `a op1 b op2 c' doesn’t imply any kind of comparison
between `a' and `c', so that, e.g., `x < y > z' is perfectly legal
(though perhaps not pretty).

The forms `<>' and `!=' are equivalent; for consistency with C, `!=' is
preferred; where `!=' is mentioned below `<>' is also accepted.  The
`<>' spelling is considered obsolescent.

The operators `<', `>', `==', `>=', `<=', and `!=' compare the values
of two objects.  The objects need not have the same type. If both are
numbers, they are converted to a common type.  Otherwise, objects of
different types `always' compare unequal, and are ordered consistently
but arbitrarily.  You can control comparison behavior of objects of
non-built-in types by defining a `__cmp__' method or rich comparison
methods like `__gt__', described in section *Note Special method names:
6e4.

(This unusual definition of comparison was used to simplify the
definition of operations like sorting and the *Note in: 441. and *Note
not in: 756. operators.  In the future, the comparison rules for
objects of different types are likely to change.)

Comparison of objects of the same type depends on the type:

   * Numbers are compared arithmetically.

   * Strings are compared lexicographically using the numeric
     equivalents (the result of the built-in function *Note ord():
     71f.) of their characters.  Unicode and 8-bit strings are fully
     interoperable in this behavior. (1)

   * Tuples and lists are compared lexicographically using comparison of
     corresponding elements.  This means that to compare equal, each
     element must compare equal and the two sequences must be of the
     same type and have the same length.

     If not equal, the sequences are ordered the same as their first
     differing elements.  For example, `cmp([1,2,x], [1,2,y])' returns
     the same as `cmp(x,y)'.  If the corresponding element does not
     exist, the shorter sequence is ordered first (for example, `[1,2]
     < [1,2,3]').

   * Mappings (dictionaries) compare equal if and only if their sorted
     (key, value) lists compare equal. (2) Outcomes other than equality
     are resolved consistently, but are not otherwise defined. (3)

   * Most other objects of built-in types compare unequal unless they
     are the same object; the choice whether one object is considered
     smaller or larger than another one is made arbitrarily but
     consistently within one execution of a program.

The operators *Note in: 441. and *Note not in: 756. test for collection
membership.  `x in s' evaluates to true if `x' is a member of the
collection `s', and false otherwise.  `x not in s' returns the negation
of `x in s'.  The collection membership test has traditionally been
bound to sequences; an object is a member of a collection if the
collection is a sequence and contains an element equal to that object.
However, it make sense for many other object types to support
membership tests without being a sequence.  In particular, dictionaries
(for keys) and sets support membership testing.

For the list and tuple types, `x in y' is true if and only if there
exists an index `i' such that either `x is y[i]' or `x == y[i]' is true.

For the Unicode and string types, `x in y' is true if and only if `x'
is a substring of `y'.  An equivalent test is `y.find(x) != -1'.  Note,
`x' and `y' need not be the same type; consequently, `u'ab' in 'abc''
will return `True'. Empty strings are always considered to be a
substring of any other string, so `"" in "abc"' will return `True'.

Changed in version 2.3: Previously, `x' was required to be a string of
length `1'.

For user-defined classes which define the *Note __contains__(): 336.
method, `x in y' is true if and only if `y.__contains__(x)' is true.

For user-defined classes which do not define *Note __contains__(): 336.
but do define *Note __iter__(): 335, `x in y' is true if some value `z'
with `x == z' is produced while iterating over `y'.  If an exception is
raised during the iteration, it is as if *Note in: 441. raised that
exception.

Lastly, the old-style iteration protocol is tried: if a class defines
*Note __getitem__(): 468, `x in y' is true if and only if there is a
non-negative integer index `i' such that `x == y[i]', and all lower
integer indices do not raise *Note IndexError: 4fe. exception. (If any
other exception is raised, it is as if *Note in: 441. raised that
exception).

The operator *Note not in: 756. is defined to have the inverse true
value of *Note in: 441.

The operators *Note is: 717. and *Note is not: 805. test for object
identity: `x is y' is true if and only if `x' and `y' are the same
object.  `x is not y' yields the inverse truth value. (4)

---------- Footnotes ----------

(1) While comparisons between unicode strings make sense at the byte
level, they may be counter-intuitive to users. For example, the strings
`u"\u00C7"' and `u"\u0043\u0327"' compare differently, even though they
both represent the same unicode character (LATIN CAPITAL LETTER C WITH
CEDILLA). To compare strings in a human recognizable way, compare using
*Note unicodedata.normalize(): 809.

(2) The implementation computes this efficiently, without constructing
lists or sorting.

(3) Earlier versions of Python used lexicographic comparison of the
sorted (key, value) lists, but this was very expensive for the common
case of comparing for equality.  An even earlier version of Python
compared dictionaries by identity only, but this caused surprises
because people expected to be able to test a dictionary for emptiness
by comparing it to `{}'.

(4) Due to automatic garbage-collection, free lists, and the dynamic
nature of descriptors, you may notice seemingly unusual behaviour in
certain uses of the *Note is: 717. operator, like those involving
comparisons between instance methods, or constants.  Check their
documentation for more info.


File: python.info,  Node: Boolean operations,  Next: Conditional Expressions,  Prev: Comparisons,  Up: Expressions

4.5.10 Boolean operations
-------------------------

    or_test  ::= and_test | or_test "or" and_test
    and_test ::= not_test | and_test "and" not_test
    not_test ::= comparison | "not" not_test

In the context of Boolean operations, and also when expressions are
used by control flow statements, the following values are interpreted
as false: `False', `None', numeric zero of all types, and empty strings
and containers (including strings, tuples, lists, dictionaries, sets
and frozensets).  All other values are interpreted as true.  (See the
*Note __nonzero__(): 734.  special method for a way to change this.)

The operator *Note not: 80d. yields `True' if its argument is false,
`False' otherwise.

The expression `x and y' first evaluates `x'; if `x' is false, its
value is returned; otherwise, `y' is evaluated and the resulting value
is returned.

The expression `x or y' first evaluates `x'; if `x' is true, its value
is returned; otherwise, `y' is evaluated and the resulting value is
returned.

(Note that neither *Note and: 80b. nor *Note or: 80c. restrict the
value and type they return to `False' and `True', but rather return the
last evaluated argument. This is sometimes useful, e.g., if `s' is a
string that should be replaced by a default value if it is empty, the
expression `s or 'foo'' yields the desired value.  Because *Note not:
80d. has to invent a value anyway, it does not bother to return a value
of the same type as its argument, so e.g., `not 'foo'' yields `False',
not `'''.)


File: python.info,  Node: Conditional Expressions,  Next: Lambdas,  Prev: Boolean operations,  Up: Expressions

4.5.11 Conditional Expressions
------------------------------

New in version 2.5.

    conditional_expression ::= or_test ["if" or_test "else" expression]
    expression             ::= conditional_expression | lambda_expr

Conditional expressions (sometimes called a “ternary operator”)
have the lowest priority of all Python operations.

The expression `x if C else y' first evaluates the condition, `C'
(`not' `x'); if `C' is true, `x' is evaluated and its value is
returned; otherwise, `y' is evaluated and its value is returned.

See PEP 308(1) for more details about conditional expressions.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0308


File: python.info,  Node: Lambdas,  Next: Expression lists,  Prev: Conditional Expressions,  Up: Expressions

4.5.12 Lambdas
--------------

    lambda_expr     ::= "lambda" [parameter_list]: expression
    old_lambda_expr ::= "lambda" [parameter_list]: old_expression

Lambda expressions (sometimes called lambda forms) have the same
syntactic position as expressions.  They are a shorthand to create
anonymous functions; the expression `lambda arguments: expression'
yields a function object.  The unnamed object behaves like a function
object defined with

    def name(arguments):
        return expression

See section *Note Function definitions: 723. for the syntax of
parameter lists.  Note that functions created with lambda expressions
cannot contain statements.


File: python.info,  Node: Expression lists,  Next: Evaluation order,  Prev: Lambdas,  Up: Expressions

4.5.13 Expression lists
-----------------------

    expression_list ::= expression ( "," expression )* [","]

An expression list containing at least one comma yields a tuple.  The
length of the tuple is the number of expressions in the list.  The
expressions are evaluated from left to right.

The trailing comma is required only to create a single tuple (a.k.a. a
`singleton'); it is optional in all other cases.  A single expression
without a trailing comma doesn’t create a tuple, but rather yields
the value of that expression. (To create an empty tuple, use an empty
pair of parentheses: `()'.)


File: python.info,  Node: Evaluation order,  Next: Operator precedence,  Prev: Expression lists,  Up: Expressions

4.5.14 Evaluation order
-----------------------

Python evaluates expressions from left to right. Notice that while
evaluating an assignment, the right-hand side is evaluated before the
left-hand side.

In the following lines, expressions will be evaluated in the arithmetic
order of their suffixes:

    expr1, expr2, expr3, expr4
    (expr1, expr2, expr3, expr4)
    {expr1: expr2, expr3: expr4}
    expr1 + expr2 * (expr3 - expr4)
    expr1(expr2, expr3, *expr4, **expr5)
    expr3, expr4 = expr1, expr2


File: python.info,  Node: Operator precedence,  Prev: Evaluation order,  Up: Expressions

4.5.15 Operator precedence
--------------------------

The following table summarizes the operator precedences in Python, from
lowest precedence (least binding) to highest precedence (most binding).
Operators in the same box have the same precedence.  Unless the syntax
is explicitly given, operators are binary.  Operators in the same box
group left to right (except for comparisons, including tests, which all
have the same precedence and chain from left to right — see section
*Note Comparisons: 804. — and exponentiation, which groups from right
to left).

Operator                                            Description
---------------------------------------------------------------------------------------------- 
*Note lambda: 41c.                                  Lambda expression
*Note if: 445. – *Note else: 54f.                 Conditional expression
*Note or: 80c.                                      Boolean OR
*Note and: 80b.                                     Boolean AND
*Note not: 80d. `x'                                 Boolean NOT
*Note in: 441, *Note not in: 756, *Note is: 717,    Comparisons, including membership tests
*Note is not: 805, `<', `<=', `>', `>=', `<>',      and identity tests
`!=', `=='                                          
`|'                                                 Bitwise OR
`^'                                                 Bitwise XOR
`&'                                                 Bitwise AND
`<<', `>>'                                          Shifts
`+', `-'                                            Addition and subtraction
`*', `/', `//', `%'                                 Multiplication, division, remainder (1)
`+x', `-x', `~x'                                    Positive, negative, bitwise NOT
`**'                                                Exponentiation (2)
`x[index]', `x[index:index]', `x(arguments...)',    Subscription, slicing, call, attribute
`x.attribute'                                       reference
`(expressions...)', `[expressions...]', `{key:      Binding or tuple display, list display,
value...}', ``expressions...`'                      dictionary display, string conversion

---------- Footnotes ----------

(1) The `%' operator is also used for string formatting; the same
precedence applies.

(2) The power operator `**' binds less tightly than an arithmetic or
bitwise unary operator on its right, that is, `2**-1' is `0.5'.


File: python.info,  Node: Simple statements,  Next: Compound statements,  Prev: Expressions,  Up: The Python Language Reference

4.6 Simple statements
=====================

Simple statements are comprised within a single logical line. Several
simple statements may occur on a single line separated by semicolons.
The syntax for simple statements is:

    simple_stmt ::= expression_stmt
                    | assert_stmt
                    | assignment_stmt
                    | augmented_assignment_stmt
                    | pass_stmt
                    | del_stmt
                    | print_stmt
                    | return_stmt
                    | yield_stmt
                    | raise_stmt
                    | break_stmt
                    | continue_stmt
                    | import_stmt
                    | global_stmt
                    | exec_stmt

* Menu:

* Expression statements::
* Assignment statements::
* The assert statement::
* The pass statement::
* The del statement: The del statement<2>.
* The print statement::
* The return statement::
* The yield statement::
* The raise statement::
* The break statement::
* The continue statement::
* The import statement::
* The global statement::
* The exec statement::


File: python.info,  Node: Expression statements,  Next: Assignment statements,  Up: Simple statements

4.6.1 Expression statements
---------------------------

Expression statements are used (mostly interactively) to compute and
write a value, or (usually) to call a procedure (a function that
returns no meaningful result; in Python, procedures return the value
`None').  Other uses of expression statements are allowed and
occasionally useful.  The syntax for an expression statement is:

    expression_stmt ::= expression_list

An expression statement evaluates the expression list (which may be a
single expression).

In interactive mode, if the value is not `None', it is converted to a
string using the built-in *Note repr(): 1c6. function and the resulting
string is written to standard output (see section *Note The print
statement: 4fd.) on a line by itself.  (Expression statements yielding
`None' are not written, so that procedure calls do not cause any
output.)


File: python.info,  Node: Assignment statements,  Next: The assert statement,  Prev: Expression statements,  Up: Simple statements

4.6.2 Assignment statements
---------------------------

Assignment statements are used to (re)bind names to values and to modify
attributes or items of mutable objects:

    assignment_stmt ::= (target_list "=")+ (expression_list | yield_expression)
    target_list     ::= target ("," target)* [","]
    target          ::= identifier
                        | "(" target_list ")"
                        | "[" [target_list] "]"
                        | attributeref
                        | subscription
                        | slicing

(See section *Note Primaries: 7d0. for the syntax definitions for the
last three symbols.)

An assignment statement evaluates the expression list (remember that
this can be a single expression or a comma-separated list, the latter
yielding a tuple) and assigns the single resulting object to each of
the target lists, from left to right.

Assignment is defined recursively depending on the form of the target
(list).  When a target is part of a mutable object (an attribute
reference, subscription or slicing), the mutable object must ultimately
perform the assignment and decide about its validity, and may raise an
exception if the assignment is unacceptable.  The rules observed by
various types and the exceptions raised are given with the definition
of the object types (see section *Note The standard type hierarchy:
719.).

Assignment of an object to a target list is recursively defined as
follows.

   * If the target list is a single target: The object is assigned to
     that target.

   * If the target list is a comma-separated list of targets: The
     object must be an iterable with the same number of items as there
     are targets in the target list, and the items are assigned, from
     left to right, to the corresponding targets.

Assignment of an object to a single target is recursively defined as
follows.

   * If the target is an identifier (name):

 
        * If the name does not occur in a *Note global: 560. statement
          in the current code block: the name is bound to the object in
          the current local namespace.

        * Otherwise: the name is bound to the object in the current
          global namespace.

     The name is rebound if it was already bound.  This may cause the
     reference count for the object previously bound to the name to
     reach zero, causing the object to be deallocated and its
     destructor (if it has one) to be called.

   * If the target is a target list enclosed in parentheses or in
     square brackets: The object must be an iterable with the same
     number of items as there are targets in the target list, and its
     items are assigned, from left to right, to the corresponding
     targets.

   * If the target is an attribute reference: The primary expression in
     the reference is evaluated.  It should yield an object with
     assignable attributes; if this is not the case, *Note TypeError:
     218. is raised.  That object is then asked to assign the assigned
     object to the given attribute; if it cannot perform the
     assignment, it raises an exception (usually but not necessarily
     *Note AttributeError: 1f8.).

     Note: If the object is a class instance and the attribute
     reference occurs on both sides of the assignment operator, the RHS
     expression, `a.x' can access either an instance attribute or (if
     no instance attribute exists) a class attribute.  The LHS target
     `a.x' is always set as an instance attribute, creating it if
     necessary.  Thus, the two occurrences of `a.x' do not necessarily
     refer to the same attribute: if the RHS expression refers to a
     class attribute, the LHS creates a new instance attribute as the
     target of the assignment:

         class Cls:
             x = 3             # class variable
         inst = Cls()
         inst.x = inst.x + 1   # writes inst.x as 4 leaving Cls.x as 3

     This description does not necessarily apply to descriptor
     attributes, such as properties created with *Note property(): 4a4.

   * If the target is a subscription: The primary expression in the
     reference is evaluated.  It should yield either a mutable sequence
     object (such as a list) or a mapping object (such as a
     dictionary). Next, the subscript expression is evaluated.

     If the primary is a mutable sequence object (such as a list), the
     subscript must yield a plain integer.  If it is negative, the
     sequence’s length is added to it.  The resulting value must be a
     nonnegative integer less than the sequence’s length, and the
     sequence is asked to assign the assigned object to its item with
     that index.  If the index is out of range, *Note IndexError: 4fe.
     is raised (assignment to a subscripted sequence cannot add new
     items to a list).

     If the primary is a mapping object (such as a dictionary), the
     subscript must have a type compatible with the mapping’s key
     type, and the mapping is then asked to create a key/datum pair
     which maps the subscript to the assigned object.  This can either
     replace an existing key/value pair with the same key value, or
     insert a new key/value pair (if no key with the same value
     existed).

   * If the target is a slicing: The primary expression in the
     reference is evaluated.  It should yield a mutable sequence object
     (such as a list).  The assigned object should be a sequence object
     of the same type.  Next, the lower and upper bound expressions are
     evaluated, insofar they are present; defaults are zero and the
     sequence’s length.  The bounds should evaluate to (small)
     integers.  If either bound is negative, the sequence’s length is
     added to it.  The resulting bounds are clipped to lie between zero
     and the sequence’s length, inclusive.  Finally, the sequence
     object is asked to replace the slice with the items of the
     assigned sequence.  The length of the slice may be different from
     the length of the assigned sequence, thus changing the length of
     the target sequence, if the object allows it.

`CPython implementation detail:' In the current implementation, the
syntax for targets is taken to be the same as for expressions, and
invalid syntax is rejected during the code generation phase, causing
less detailed error messages.

WARNING: Although the definition of assignment implies that overlaps
between the left-hand side and the right-hand side are ‘safe’ (for
example `a, b = b, a' swaps two variables), overlaps `within' the
collection of assigned-to variables are not safe!  For instance, the
following program prints `[0, 2]':

    x = [0, 1]
    i = 0
    i, x[i] = 1, 2
    print x

* Menu:

* Augmented assignment statements::


File: python.info,  Node: Augmented assignment statements,  Up: Assignment statements

4.6.2.1 Augmented assignment statements
.......................................

Augmented assignment is the combination, in a single statement, of a
binary operation and an assignment statement:

    augmented_assignment_stmt ::= augtarget augop (expression_list | yield_expression)
    augtarget                 ::= identifier | attributeref | subscription | slicing
    augop                     ::= "+=" | "-=" | "*=" | "/=" | "//=" | "%=" | "**="
                                  | ">>=" | "<<=" | "&=" | "^=" | "|="

(See section *Note Primaries: 7d0. for the syntax definitions for the
last three symbols.)

An augmented assignment evaluates the target (which, unlike normal
assignment statements, cannot be an unpacking) and the expression list,
performs the binary operation specific to the type of assignment on the
two operands, and assigns the result to the original target.  The
target is only evaluated once.

An augmented assignment expression like `x += 1' can be rewritten as `x
= x + 1' to achieve a similar, but not exactly equal effect. In the
augmented version, `x' is only evaluated once. Also, when possible, the
actual operation is performed `in-place', meaning that rather than
creating a new object and assigning that to the target, the old object
is modified instead.

With the exception of assigning to tuples and multiple targets in a
single statement, the assignment done by augmented assignment
statements is handled the same way as normal assignments. Similarly,
with the exception of the possible `in-place' behavior, the binary
operation performed by augmented assignment is the same as the normal
binary operations.

For targets which are attribute references, the same *Note caveat about
class and instance attributes: 82b. applies as for regular assignments.


File: python.info,  Node: The assert statement,  Next: The pass statement,  Prev: Assignment statements,  Up: Simple statements

4.6.3 The `assert' statement
----------------------------

Assert statements are a convenient way to insert debugging assertions
into a program:

    assert_stmt ::= "assert" expression ["," expression]

The simple form, `assert expression', is equivalent to

    if __debug__:
        if not expression: raise AssertionError

The extended form, `assert expression1, expression2', is equivalent to

    if __debug__:
        if not expression1: raise AssertionError(expression2)

These equivalences assume that *Note __debug__: 833. and *Note
AssertionError: 834. refer to the built-in variables with those names.
In the current implementation, the built-in variable *Note __debug__:
833. is `True' under normal circumstances, `False' when optimization is
requested (command line option -O).  The current code generator emits
no code for an assert statement when optimization is requested at
compile time.  Note that it is unnecessary to include the source code
for the expression that failed in the error message; it will be
displayed as part of the stack trace.

Assignments to *Note __debug__: 833. are illegal.  The value for the
built-in variable is determined when the interpreter starts.


File: python.info,  Node: The pass statement,  Next: The del statement<2>,  Prev: The assert statement,  Up: Simple statements

4.6.4 The `pass' statement
--------------------------

    pass_stmt ::= "pass"

*Note pass: 55c. is a null operation — when it is executed, nothing
happens.  It is useful as a placeholder when a statement is required
syntactically, but no code needs to be executed, for example:

    def f(arg): pass    # a function that does nothing (yet)

    class C: pass       # a class with no methods (yet)


File: python.info,  Node: The del statement<2>,  Next: The print statement,  Prev: The pass statement,  Up: Simple statements

4.6.5 The `del' statement
-------------------------

    del_stmt ::= "del" target_list

Deletion is recursively defined very similar to the way assignment is
defined.  Rather than spelling it out in full details, here are some
hints.

Deletion of a target list recursively deletes each target, from left to
right.

Deletion of a name removes the binding of that name  from the local or
global namespace, depending on whether the name occurs in a *Note
global: 560. statement in the same code block.  If the name is unbound,
a *Note NameError: 3bb. exception will be raised.

It is illegal to delete a name from the local namespace if it occurs as
a free variable in a nested block.

Deletion of attribute references, subscriptions and slicings is passed
to the primary object involved; deletion of a slicing is in general
equivalent to assignment of an empty slice of the right type (but even
this is determined by the sliced object).


File: python.info,  Node: The print statement,  Next: The return statement,  Prev: The del statement<2>,  Up: Simple statements

4.6.6 The `print' statement
---------------------------

    print_stmt ::= "print" ([expression ("," expression)* [","]]
                   | ">>" expression [("," expression)+ [","]])

*Note print: 4fd. evaluates each expression in turn and writes the
resulting object to standard output (see below).  If an object is not a
string, it is first converted to a string using the rules for string
conversions.  The (resulting or original) string is then written.  A
space is written before each object is (converted and) written, unless
the output system believes it is positioned at the beginning of a line.
This is the case (1) when no characters have yet been written to
standard output, (2) when the last character written to standard output
is a whitespace character except `' '', or (3) when the last write
operation on standard output was not a *Note print: 4fd. statement.
(In some cases it may be functional to write an empty string to
standard output for this reason.)

     Note: Objects which act like file objects but which are not the
     built-in file objects often do not properly emulate this aspect of
     the file object’s behavior, so it is best not to rely on this.

A `'\n'' character is written at the end, unless the *Note print: 4fd.
statement ends with a comma.  This is the only action if the statement
contains just the keyword *Note print: 4fd.

Standard output is defined as the file object named `stdout' in the
built-in module *Note sys: 16d.  If no such object exists, or if it
does not have a `write()' method, a *Note RuntimeError: 3b3. exception
is raised.

*Note print: 4fd. also has an extended form, defined by the second
portion of the syntax described above. This form is sometimes referred
to as “*Note print: 4fd.  chevron.” In this form, the first
expression after the `>>' must evaluate to a “file-like” object,
specifically an object that has a `write()' method as described above.
With this extended form, the subsequent expressions are printed to this
file object.  If the first expression evaluates to `None', then
`sys.stdout' is used as the file for output.


File: python.info,  Node: The return statement,  Next: The yield statement,  Prev: The print statement,  Up: Simple statements

4.6.7 The `return' statement
----------------------------

    return_stmt ::= "return" [expression_list]

*Note return: 307. may only occur syntactically nested in a function
definition, not within a nested class definition.

If an expression list is present, it is evaluated, else `None' is
substituted.

*Note return: 307. leaves the current function call with the expression
list (or `None') as return value.

When *Note return: 307. passes control out of a *Note try: 3ad.
statement with a *Note finally: 3ae. clause, that *Note finally: 3ae.
clause is executed before really leaving the function.

In a generator function, the *Note return: 307. statement is not
allowed to include an *Note expression_list: 7cb.  In that context, a
bare *Note return: 307.  indicates that the generator is done and will
cause *Note StopIteration: 347. to be raised.


File: python.info,  Node: The yield statement,  Next: The raise statement,  Prev: The return statement,  Up: Simple statements

4.6.8 The `yield' statement
---------------------------

    yield_stmt ::= yield_expression

The *Note yield: 30a. statement is only used when defining a generator
function, and is only used in the body of the generator function. Using
a *Note yield: 30a.  statement in a function definition is sufficient
to cause that definition to create a generator function instead of a
normal function.

When a generator function is called, it returns an iterator known as a
generator iterator, or more commonly, a generator.  The body of the
generator function is executed by calling the generator’s *Note
next(): 5f8. method repeatedly until it raises an exception.

When a *Note yield: 30a. statement is executed, the state of the
generator is frozen and the value of *Note expression_list: 7cb. is
returned to *Note next(): 5f8.’s caller.  By “frozen” we mean
that all local state is retained, including the current bindings of
local variables, the instruction pointer, and the internal evaluation
stack: enough information is saved so that the next time *Note next():
5f8. is invoked, the function can proceed exactly as if the *Note
yield: 30a. statement were just another external call.

As of Python version 2.5, the *Note yield: 30a. statement is now
allowed in the *Note try: 3ad. clause of a *Note try: 3ad. …  *Note
finally: 3ae. construct.  If the generator is not resumed before it is
finalized (by reaching a zero reference count or by being garbage
collected), the generator-iterator’s `close()' method will be called,
allowing any pending *Note finally: 3ae.  clauses to execute.

For full details of *Note yield: 30a. semantics, refer to the *Note
Yield expressions: 7c8.  section.

     Note: In Python 2.2, the *Note yield: 30a. statement was only
     allowed when the `generators' feature has been enabled.  This
     `__future__' import statement was used to enable the feature:

         from __future__ import generators

See also
........

PEP 255(1) - Simple Generators
     The proposal for adding generators and the *Note yield: 30a.
     statement to Python.

PEP 342(2) - Coroutines via Enhanced Generators
     The proposal that, among other generator enhancements, proposed
     allowing *Note yield: 30a. to appear inside a *Note try: 3ad. …
     *Note finally: 3ae. block.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0255

(2) https://www.python.org/dev/peps/pep-0342


File: python.info,  Node: The raise statement,  Next: The break statement,  Prev: The yield statement,  Up: Simple statements

4.6.9 The `raise' statement
---------------------------

    raise_stmt ::= "raise" [expression ["," expression ["," expression]]]

If no expressions are present, *Note raise: 5cc. re-raises the last
exception that was active in the current scope.  If no exception is
active in the current scope, a *Note TypeError: 218. exception is
raised indicating that this is an error (if running under IDLE, a *Note
Queue.Empty: 841. exception is raised instead).

Otherwise, *Note raise: 5cc. evaluates the expressions to get three
objects, using `None' as the value of omitted expressions.  The first
two objects are used to determine the `type' and `value' of the
exception.

If the first object is an instance, the type of the exception is the
class of the instance, the instance itself is the value, and the second
object must be `None'.

If the first object is a class, it becomes the type of the exception.
The second object is used to determine the exception value: If it is an
instance of the class, the instance becomes the exception value. If the
second object is a tuple, it is used as the argument list for the class
constructor; if it is `None', an empty argument list is used, and any
other object is treated as a single argument to the constructor.  The
instance so created by calling the constructor is used as the exception
value.

If a third object is present and not `None', it must be a traceback
object (see section *Note The standard type hierarchy: 719.), and it is
substituted instead of the current location as the place where the
exception occurred.  If the third object is present and not a traceback
object or `None', a *Note TypeError: 218. exception is raised.  The
three-expression form of *Note raise: 5cc. is useful to re-raise an
exception transparently in an except clause, but *Note raise: 5cc. with
no expressions should be preferred if the exception to be re-raised was
the most recently active exception in the current scope.

Additional information on exceptions can be found in section *Note
Exceptions: 797, and information about handling exceptions is in
section *Note The try statement: 3ad.


File: python.info,  Node: The break statement,  Next: The continue statement,  Prev: The raise statement,  Up: Simple statements

4.6.10 The `break' statement
----------------------------

    break_stmt ::= "break"

*Note break: 557. may only occur syntactically nested in a *Note for:
303. or *Note while: 548. loop, but not nested in a function or class
definition within that loop.

It terminates the nearest enclosing loop, skipping the optional *Note
else: 54f.  clause if the loop has one.

If a *Note for: 303. loop is terminated by *Note break: 557, the loop
control target keeps its current value.

When *Note break: 557. passes control out of a *Note try: 3ad.
statement with a *Note finally: 3ae. clause, that *Note finally: 3ae.
clause is executed before really leaving the loop.


File: python.info,  Node: The continue statement,  Next: The import statement,  Prev: The break statement,  Up: Simple statements

4.6.11 The `continue' statement
-------------------------------

    continue_stmt ::= "continue"

*Note continue: 559. may only occur syntactically nested in a *Note
for: 303. or *Note while: 548. loop, but not nested in a function or
class definition or *Note finally: 3ae. clause within that loop.  It
continues with the next cycle of the nearest enclosing loop.

When *Note continue: 559. passes control out of a *Note try: 3ad.
statement with a *Note finally: 3ae. clause, that *Note finally: 3ae.
clause is executed before really starting the next loop cycle.


File: python.info,  Node: The import statement,  Next: The global statement,  Prev: The continue statement,  Up: Simple statements

4.6.12 The `import' statement
-----------------------------

    import_stmt     ::= "import" module ["as" name] ( "," module ["as" name] )*
                        | "from" relative_module "import" identifier ["as" name]
                        ( "," identifier ["as" name] )*
                        | "from" relative_module "import" "(" identifier ["as" name]
                        ( "," identifier ["as" name] )* [","] ")"
                        | "from" module "import" "*"
    module          ::= (identifier ".")* identifier
    relative_module ::= "."* module | "."+
    name            ::= identifier

Import statements are executed in two steps: (1) find a module, and
initialize it if necessary; (2) define a name or names in the local
namespace (of the scope where the *Note import: 1f4. statement occurs).
The statement comes in two forms differing on whether it uses the *Note
from: 847. keyword. The first form (without *Note from: 847.) repeats
these steps for each identifier in the list.  The form with *Note from:
847. performs step (1) once, and then performs step (2) repeatedly.

To understand how step (1) occurs, one must first understand how Python
handles hierarchical naming of modules. To help organize modules and
provide a hierarchy in naming, Python has a concept of packages. A
package can contain other packages and modules while modules cannot
contain other modules or packages. From a file system perspective,
packages are directories and modules are files.

Once the name of the module is known (unless otherwise specified, the
term “module” will refer to both packages and modules), searching
for the module or package can begin. The first place checked is *Note
sys.modules: 84c, the cache of all modules that have been imported
previously. If the module is found there then it is used in step (2) of
import.

If the module is not found in the cache, then *Note sys.meta_path: 84d.
is searched (the specification for *Note sys.meta_path: 84d. can be
found in PEP 302(1)).  The object is a list of *Note finder: 84e.
objects which are queried in order as to whether they know how to load
the module by calling their `find_module()' method with the name of the
module. If the module happens to be contained within a package (as
denoted by the existence of a dot in the name), then a second argument
to `find_module()' is given as the value of the `__path__' attribute
from the parent package (everything up to the last dot in the name of
the module being imported). If a finder can find the module it returns
a *Note loader: 84f. (discussed later) or returns `None'.

If none of the finders on *Note sys.meta_path: 84d. are able to find
the module then some implicitly defined finders are queried.
Implementations of Python vary in what implicit meta path finders are
defined. The one they all do define, though, is one that handles *Note
sys.path_hooks: 850, *Note sys.path_importer_cache: 851, and *Note
sys.path: 59a.

The implicit finder searches for the requested module in the
“paths” specified in one of two places (“paths” do not have to
be file system paths). If the module being imported is supposed to be
contained within a package then the second argument passed to
`find_module()', `__path__' on the parent package, is used as the
source of paths. If the module is not contained in a package then *Note
sys.path: 59a. is used as the source of paths.

Once the source of paths is chosen it is iterated over to find a finder
that can handle that path. The dict at *Note sys.path_importer_cache:
851. caches finders for paths and is checked for a finder. If the path
does not have a finder cached then *Note sys.path_hooks: 850. is
searched by calling each object in the list with a single argument of
the path, returning a finder or raises *Note ImportError: 388. If a
finder is returned then it is cached in *Note sys.path_importer_cache:
851. and then used for that path entry. If no finder can be found but
the path exists then a value of `None' is stored in *Note
sys.path_importer_cache: 851. to signify that an implicit, file-based
finder that handles modules stored as individual files should be used
for that path. If the path does not exist then a finder which always
returns `None' is placed in the cache for the path.

If no finder can find the module then *Note ImportError: 388. is
raised. Otherwise some finder returned a loader whose `load_module()'
method is called with the name of the module to load (see PEP 302(2)
for the original definition of loaders). A loader has several
responsibilities to perform on a module it loads. First, if the module
already exists in *Note sys.modules: 84c. (a possibility if the loader
is called outside of the import machinery) then it is to use that
module for initialization and not a new module. But if the module does
not exist in *Note sys.modules: 84c. then it is to be added to that
dict before initialization begins. If an error occurs during loading of
the module and it was added to *Note sys.modules: 84c. it is to be
removed from the dict. If an error occurs but the module was already in
*Note sys.modules: 84c. it is left in the dict.

The loader must set several attributes on the module. `__name__' is to
be set to the name of the module. `__file__' is to be the “path” to
the file unless the module is built-in (and thus listed in *Note
sys.builtin_module_names: 852.) in which case the attribute is not set.
If what is being imported is a package then `__path__' is to be set to a
list of paths to be searched when looking for modules and packages
contained within the package being imported. `__package__' is optional
but should be set to the name of package that contains the module or
package (the empty string is used for module not contained in a
package). `__loader__' is also optional but should be set to the loader
object that is loading the module.

If an error occurs during loading then the loader raises *Note
ImportError: 388. if some other exception is not already being
propagated. Otherwise the loader returns the module that was loaded and
initialized.

When step (1) finishes without raising an exception, step (2) can begin.

The first form of *Note import: 1f4. statement binds the module name in
the local namespace to the module object, and then goes on to import
the next identifier, if any.  If the module name is followed by *Note
as: 30b, the name following *Note as: 30b. is used as the local name
for the module.

The *Note from: 847. form does not bind the module name: it goes
through the list of identifiers, looks each one of them up in the
module found in step (1), and binds the name in the local namespace to
the object thus found.  As with the first form of *Note import: 1f4, an
alternate local name can be supplied by specifying “*Note as: 30b.
localname”.  If a name is not found, *Note ImportError: 388. is
raised.  If the list of identifiers is replaced by a star (`'*''), all
public names defined in the module are bound in the local namespace of
the *Note import: 1f4. statement..

The `public names' defined by a module are determined by checking the
module’s namespace for a variable named `__all__'; if defined, it
must be a sequence of strings which are names defined or imported by
that module.  The names given in `__all__' are all considered public
and are required to exist.  If `__all__' is not defined, the set of
public names includes all names found in the module’s namespace which
do not begin with an underscore character (`'_'').  `__all__' should
contain the entire public API. It is intended to avoid accidentally
exporting items that are not part of the API (such as library modules
which were imported and used within the module).

The *Note from: 847. form with `*' may only occur in a module scope.
If the wild card form of import — `import *' — is used in a
function and the function contains or is a nested block with free
variables, the compiler will raise a *Note SyntaxError: 4b4.

When specifying what module to import you do not have to specify the
absolute name of the module. When a module or package is contained
within another package it is possible to make a relative import within
the same top package without having to mention the package name. By
using leading dots in the specified module or package after *Note from:
847. you can specify how high to traverse up the current package
hierarchy without specifying exact names. One leading dot means the
current package where the module making the import exists. Two dots
means up one package level. Three dots is up two levels, etc.  So if
you execute `from . import mod' from a module in the `pkg' package then
you will end up importing `pkg.mod'. If you execute `from ..subpkg2
import mod' from within `pkg.subpkg1' you will import `pkg.subpkg2.mod'.
The specification for relative imports is contained within PEP 328(3).

*Note importlib.import_module(): 272. is provided to support
applications that determine which modules need to be loaded dynamically.

* Menu:

* Future statements::

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0302

(2) https://www.python.org/dev/peps/pep-0302

(3) https://www.python.org/dev/peps/pep-0328


File: python.info,  Node: Future statements,  Up: The import statement

4.6.12.1 Future statements
..........................

A `future statement' is a directive to the compiler that a particular
module should be compiled using syntax or semantics that will be
available in a specified future release of Python.  The future
statement is intended to ease migration to future versions of Python
that introduce incompatible changes to the language.  It allows use of
the new features on a per-module basis before the release in which the
feature becomes standard.

    future_statement ::= "from" "__future__" "import" feature ["as" name]
                         ("," feature ["as" name])*
                         | "from" "__future__" "import" "(" feature ["as" name]
                         ("," feature ["as" name])* [","] ")"
    feature          ::= identifier
    name             ::= identifier

A future statement must appear near the top of the module.  The only
lines that can appear before a future statement are:

   * the module docstring (if any),

   * comments,

   * blank lines, and

   * other future statements.

The features recognized by Python 2.6 are `unicode_literals',
`print_function', `absolute_import', `division', `generators',
`nested_scopes' and `with_statement'.  `generators', `with_statement',
`nested_scopes' are redundant in Python version 2.6 and above because
they are always enabled.

A future statement is recognized and treated specially at compile time:
Changes to the semantics of core constructs are often implemented by
generating different code.  It may even be the case that a new feature
introduces new incompatible syntax (such as a new reserved word), in
which case the compiler may need to parse the module differently.  Such
decisions cannot be pushed off until runtime.

For any given release, the compiler knows which feature names have been
defined, and raises a compile-time error if a future statement contains
a feature not known to it.

The direct runtime semantics are the same as for any import statement:
there is a standard module *Note __future__: 1, described later, and it
will be imported in the usual way at the time the future statement is
executed.

The interesting runtime semantics depend on the specific feature
enabled by the future statement.

Note that there is nothing special about the statement:

    import __future__ [as name]

That is not a future statement; it’s an ordinary import statement
with no special semantics or syntax restrictions.

Code compiled by an *Note exec: 41d. statement or calls to the built-in
functions *Note compile(): 1fb. and *Note execfile(): 44f. that occur
in a module `M' containing a future statement will, by default, use the
new  syntax or semantics associated with the future statement.  This
can, starting with Python 2.2 be controlled by optional arguments to
*Note compile(): 1fb. — see the documentation of that function for
details.

A future statement typed at an interactive interpreter prompt will take
effect for the rest of the interpreter session.  If an interpreter is
started with the *Note -i: 492. option, is passed a script name to
execute, and the script includes a future statement, it will be in
effect in the interactive session started after the script is executed.

See also
........

PEP 236(1) - Back to the __future__
     The original proposal for the __future__ mechanism.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0236


File: python.info,  Node: The global statement,  Next: The exec statement,  Prev: The import statement,  Up: Simple statements

4.6.13 The `global' statement
-----------------------------

    global_stmt ::= "global" identifier ("," identifier)*

The *Note global: 560. statement is a declaration which holds for the
entire current code block.  It means that the listed identifiers are to
be interpreted as globals.  It would be impossible to assign to a
global variable without *Note global: 560, although free variables may
refer to globals without being declared global.

Names listed in a *Note global: 560. statement must not be used in the
same code block textually preceding that *Note global: 560. statement.

Names listed in a *Note global: 560. statement must not be defined as
formal parameters or in a *Note for: 303. loop control target, *Note
class: 351.  definition, function definition, or *Note import: 1f4.
statement.

`CPython implementation detail:' The current implementation does not
enforce the latter two restrictions, but programs should not abuse this
freedom, as future implementations may enforce them or silently change
the meaning of the program.

`Programmer’s note:' the *Note global: 560. is a directive to the
parser.  It applies only to code parsed at the same time as the *Note
global: 560. statement.  In particular, a *Note global: 560. statement
contained in an *Note exec: 41d.  statement does not affect the code
block `containing' the *Note exec: 41d.  statement, and code contained
in an *Note exec: 41d. statement is unaffected by *Note global: 560.
statements in the code containing the *Note exec: 41d.  statement.  The
same applies to the *Note eval(): 378, *Note execfile(): 44f. and *Note
compile(): 1fb. functions.


File: python.info,  Node: The exec statement,  Prev: The global statement,  Up: Simple statements

4.6.14 The `exec' statement
---------------------------

    exec_stmt ::= "exec" or_expr ["in" expression ["," expression]]

This statement supports dynamic execution of Python code.  The first
expression should evaluate to either a Unicode string, a `Latin-1'
encoded string, an open file object, a code object, or a tuple.  If it
is a string, the string is parsed as a suite of Python statements which
is then executed (unless a syntax error occurs). (1) If it is an open
file, the file is parsed until EOF and executed.  If it is a code
object, it is simply executed.  For the interpretation of a tuple, see
below.  In all cases, the code that’s executed is expected to be
valid as file input (see section *Note File input: 85c.).  Be aware
that the *Note return: 307. and *Note yield: 30a. statements may not be
used outside of function definitions even within the context of code
passed to the *Note exec: 41d. statement.

In all cases, if the optional parts are omitted, the code is executed
in the current scope.  If only the first expression after `in' is
specified, it should be a dictionary, which will be used for both the
global and the local variables.  If two expressions are given, they are
used for the global and local variables, respectively. If provided,
`locals' can be any mapping object.  Remember that at module level,
globals and locals are the same dictionary. If two separate objects are
given as `globals' and `locals', the code will be executed as if it
were embedded in a class definition.

The first expression may also be a tuple of length 2 or 3.  In this
case, the optional parts must be omitted.  The form `exec(expr,
globals)' is equivalent to `exec expr in globals', while the form
`exec(expr, globals, locals)' is equivalent to `exec expr in globals,
locals'.  The tuple form of `exec' provides compatibility with Python
3, where `exec' is a function rather than a statement.

Changed in version 2.4: Formerly, `locals' was required to be a
dictionary.

As a side effect, an implementation may insert additional keys into the
dictionaries given besides those corresponding to variable names set by
the executed code.  For example, the current implementation may add a
reference to the dictionary of the built-in module *Note __builtin__:
0. under the key `__builtins__' (!).

`Programmer’s hints:' dynamic evaluation of expressions is supported
by the built-in function *Note eval(): 378.  The built-in functions
*Note globals(): 85d. and *Note locals(): 350. return the current
global and local dictionary, respectively, which may be useful to pass
around for use by *Note exec: 41d.

---------- Footnotes ----------

(1) Note that the parser only accepts the Unix-style end of line
convention.  If you are reading the code from a file, make sure to use
*Note universal newlines: 329. mode to convert Windows or Mac-style
newlines.


File: python.info,  Node: Compound statements,  Next: Top-level components,  Prev: Simple statements,  Up: The Python Language Reference

4.7 Compound statements
=======================

Compound statements contain (groups of) other statements; they affect
or control the execution of those other statements in some way.  In
general, compound statements span multiple lines, although in simple
incarnations a whole compound statement may be contained in one line.

The *Note if: 445, *Note while: 548. and *Note for: 303. statements
implement traditional control flow constructs.  *Note try: 3ad.
specifies exception handlers and/or cleanup code for a group of
statements.  Function and class definitions are also syntactically
compound statements.

Compound statements consist of one or more ‘clauses.’  A clause
consists of a header and a ‘suite.’  The clause headers of a
particular compound statement are all at the same indentation level.
Each clause header begins with a uniquely identifying keyword and ends
with a colon.  A suite is a group of statements controlled by a clause.
A suite can be one or more semicolon-separated simple statements on
the same line as the header, following the header’s colon, or it can
be one or more indented statements on subsequent lines.  Only the latter
form of suite can contain nested compound statements; the following is
illegal, mostly because it wouldn’t be clear to which *Note if: 445.
clause a following *Note else: 54f. clause would belong:

    if test1: if test2: print x

Also note that the semicolon binds tighter than the colon in this
context, so that in the following example, either all or none of the
*Note print: 4fd.  statements are executed:

    if x < y < z: print x; print y; print z

Summarizing:

    compound_stmt ::= if_stmt
                      | while_stmt
                      | for_stmt
                      | try_stmt
                      | with_stmt
                      | funcdef
                      | classdef
                      | decorated
    suite         ::= stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT
    statement     ::= stmt_list NEWLINE | compound_stmt
    stmt_list     ::= simple_stmt (";" simple_stmt)* [";"]

Note that statements always end in a `NEWLINE' possibly followed by a
`DEDENT'. Also note that optional continuation clauses always begin
with a keyword that cannot start a statement, thus there are no
ambiguities (the ‘dangling *Note else: 54f.’ problem is solved in
Python by requiring nested *Note if: 445. statements to be indented).

The formatting of the grammar rules in the following sections places
each clause on a separate line for clarity.

* Menu:

* The if statement::
* The while statement::
* The for statement::
* The try statement::
* The with statement::
* Function definitions::
* Class definitions::


File: python.info,  Node: The if statement,  Next: The while statement,  Up: Compound statements

4.7.1 The `if' statement
------------------------

The *Note if: 445. statement is used for conditional execution:

    if_stmt ::= "if" expression ":" suite
                ( "elif" expression ":" suite )*
                ["else" ":" suite]

It selects exactly one of the suites by evaluating the expressions one
by one until one is found to be true (see section *Note Boolean
operations: 80a. for the definition of true and false); then that suite
is executed (and no other part of the *Note if: 445. statement is
executed or evaluated).  If all expressions are false, the suite of the
*Note else: 54f. clause, if present, is executed.


File: python.info,  Node: The while statement,  Next: The for statement,  Prev: The if statement,  Up: Compound statements

4.7.2 The `while' statement
---------------------------

The *Note while: 548. statement is used for repeated execution as long
as an expression is true:

    while_stmt ::= "while" expression ":" suite
                   ["else" ":" suite]

This repeatedly tests the expression and, if it is true, executes the
first suite; if the expression is false (which may be the first time it
is tested) the suite of the *Note else: 54f. clause, if present, is
executed and the loop terminates.

A *Note break: 557. statement executed in the first suite terminates
the loop without executing the *Note else: 54f. clause’s suite.  A
*Note continue: 559.  statement executed in the first suite skips the
rest of the suite and goes back to testing the expression.


File: python.info,  Node: The for statement,  Next: The try statement,  Prev: The while statement,  Up: Compound statements

4.7.3 The `for' statement
-------------------------

The *Note for: 303. statement is used to iterate over the elements of a
sequence (such as a string, tuple or list) or other iterable object:

    for_stmt ::= "for" target_list "in" expression_list ":" suite
                 ["else" ":" suite]

The expression list is evaluated once; it should yield an iterable
object.  An iterator is created for the result of the
`expression_list'.  The suite is then executed once for each item
provided by the iterator, in the order of ascending indices.  Each item
in turn is assigned to the target list using the standard rules for
assignments, and then the suite is executed.  When the items are
exhausted (which is immediately when the sequence is empty), the suite
in the *Note else: 54f. clause, if present, is executed, and the loop
terminates.

A *Note break: 557. statement executed in the first suite terminates
the loop without executing the *Note else: 54f. clause’s suite.  A
*Note continue: 559.  statement executed in the first suite skips the
rest of the suite and continues with the next item, or with the *Note
else: 54f. clause if there was no next item.

The suite may assign to the variable(s) in the target list; this does
not affect the next item assigned to it.

The target list is not deleted when the loop is finished, but if the
sequence is empty, it will not have been assigned to at all by the
loop.  Hint: the built-in function *Note range(): 2db. returns a
sequence of integers suitable to emulate the effect of Pascal’s `for
i := a to b do'; e.g., `range(3)' returns the list `[0, 1, 2]'.

     Note: 

     There is a subtlety when the sequence is being modified by the
     loop (this can only occur for mutable sequences, i.e. lists). An
     internal counter is used to keep track of which item is used next,
     and this is incremented on each iteration.  When this counter has
     reached the length of the sequence the loop terminates.  This
     means that if the suite deletes the current (or a previous) item
     from the sequence, the next item will be skipped (since it gets
     the index of the current item which has already been treated).
     Likewise, if the suite inserts an item in the sequence before the
     current item, the current item will be treated again the next time
     through the loop. This can lead to nasty bugs that can be avoided
     by making a temporary copy using a slice of the whole sequence,
     e.g.,

         for x in a[:]:
             if x < 0: a.remove(x)


File: python.info,  Node: The try statement,  Next: The with statement,  Prev: The for statement,  Up: Compound statements

4.7.4 The `try' statement
-------------------------

The *Note try: 3ad. statement specifies exception handlers and/or
cleanup code for a group of statements:

    try_stmt  ::= try1_stmt | try2_stmt
    try1_stmt ::= "try" ":" suite
                  ("except" [expression [("as" | ",") identifier]] ":" suite)+
                  ["else" ":" suite]
                  ["finally" ":" suite]
    try2_stmt ::= "try" ":" suite
                  "finally" ":" suite

Changed in version 2.5: In previous versions of Python, *Note try:
3ad.…*Note except: 3af.…*Note finally: 3ae. did not work. *Note
try: 3ad.…*Note except: 3af. had to be nested in *Note try:
3ad.…*Note finally: 3ae.

The *Note except: 3af. clause(s) specify one or more exception
handlers. When no exception occurs in the *Note try: 3ad. clause, no
exception handler is executed.  When an exception occurs in the *Note
try: 3ad. suite, a search for an exception handler is started.  This
search inspects the except clauses in turn until one is found that
matches the exception.  An expression-less except clause, if present,
must be last; it matches any exception.  For an except clause with an
expression, that expression is evaluated, and the clause matches the
exception if the resulting object is “compatible” with the
exception.  An object is compatible with an exception if it is the
class or a base class of the exception object, or a tuple containing an
item compatible with the exception.

If no except clause matches the exception, the search for an exception
handler continues in the surrounding code and on the invocation stack.
(1)

If the evaluation of an expression in the header of an except clause
raises an exception, the original search for a handler is canceled and
a search starts for the new exception in the surrounding code and on
the call stack (it is treated as if the entire *Note try: 3ad.
statement raised the exception).

When a matching except clause is found, the exception is assigned to
the target specified in that except clause, if present, and the except
clause’s suite is executed.  All except clauses must have an
executable block.  When the end of this block is reached, execution
continues normally after the entire try statement.  (This means that if
two nested handlers exist for the same exception, and the exception
occurs in the try clause of the inner handler, the outer handler will
not handle the exception.)

Before an except clause’s suite is executed, details about the
exception are assigned to three variables in the *Note sys: 16d.
module: `sys.exc_type' receives the object identifying the exception;
`sys.exc_value' receives the exception’s parameter;
`sys.exc_traceback' receives a traceback object (see section *Note The
standard type hierarchy: 719.) identifying the point in the program
where the exception occurred. These details are also available through
the *Note sys.exc_info(): 306.  function, which returns a tuple
`(exc_type, exc_value, exc_traceback)'.  Use of the corresponding
variables is deprecated in favor of this function, since their use is
unsafe in a threaded program.  As of Python 1.5, the variables are
restored to their previous values (before the call) when returning from
a function that handled an exception.

The optional *Note else: 54f. clause is executed if and when control
flows off the end of the *Note try: 3ad. clause. (2) Exceptions in the
*Note else: 54f.  clause are not handled by the preceding *Note except:
3af. clauses.

If *Note finally: 3ae. is present, it specifies a ‘cleanup’
handler.  The *Note try: 3ad. clause is executed, including any *Note
except: 3af. and *Note else: 54f. clauses.  If an exception occurs in
any of the clauses and is not handled, the exception is temporarily
saved. The *Note finally: 3ae. clause is executed.  If there is a saved
exception, it is re-raised at the end of the *Note finally: 3ae.
clause. If the *Note finally: 3ae. clause raises another exception or
executes a *Note return: 307. or *Note break: 557. statement, the saved
exception is discarded:

    >>> def f():
    ...     try:
    ...         1/0
    ...     finally:
    ...         return 42
    ...
    >>> f()
    42

The exception information is not available to the program during
execution of the *Note finally: 3ae. clause.

When a *Note return: 307, *Note break: 557. or *Note continue: 559.
statement is executed in the *Note try: 3ad. suite of a *Note try:
3ad.…*Note finally: 3ae.  statement, the *Note finally: 3ae. clause
is also executed ‘on the way out.’ A *Note continue: 559. statement
is illegal in the *Note finally: 3ae. clause. (The reason is a problem
with the current implementation — this restriction may be lifted in
the future).

The return value of a function is determined by the last *Note return:
307.  statement executed.  Since the *Note finally: 3ae. clause always
executes, a *Note return: 307. statement executed in the *Note finally:
3ae. clause will always be the last one executed:

    >>> def foo():
    ...     try:
    ...         return 'try'
    ...     finally:
    ...         return 'finally'
    ...
    >>> foo()
    'finally'

Additional information on exceptions can be found in section *Note
Exceptions: 797, and information on using the *Note raise: 5cc.
statement to generate exceptions may be found in section *Note The
raise statement: 5cc.

---------- Footnotes ----------

(1) The exception is propagated to the invocation stack unless there is
a *Note finally: 3ae. clause which happens to raise another exception.
That new exception causes the old one to be lost.

(2) Currently, control “flows off the end” except in the case of an
exception or the execution of a *Note return: 307, *Note continue: 559,
or *Note break: 557.  statement.


File: python.info,  Node: The with statement,  Next: Function definitions,  Prev: The try statement,  Up: Compound statements

4.7.5 The `with' statement
--------------------------

New in version 2.5.

The *Note with: 1c1. statement is used to wrap the execution of a block
with methods defined by a context manager (see section *Note With
Statement Context Managers: 78b.). This allows common *Note try:
3ad.…*Note except: 3af.…*Note finally: 3ae. usage patterns to be
encapsulated for convenient reuse.

    with_stmt ::= "with" with_item ("," with_item)* ":" suite
    with_item ::= expression ["as" target]

The execution of the *Note with: 1c1. statement with one “item”
proceeds as follows:

  1. The context expression (the expression given in the *Note
     with_item: 871.) is evaluated to obtain a context manager.

  2. The context manager’s *Note __exit__(): 200. is loaded for later
     use.

  3. The context manager’s *Note __enter__(): 1ff. method is invoked.

  4. If a target was included in the *Note with: 1c1. statement, the
     return value from *Note __enter__(): 1ff. is assigned to it.

          Note: The *Note with: 1c1. statement guarantees that if the
          *Note __enter__(): 1ff. method returns without an error, then
          *Note __exit__(): 200. will always be called. Thus, if an
          error occurs during the assignment to the target list, it
          will be treated the same as an error occurring within the
          suite would be. See step 6 below.

  5. The suite is executed.

  6. The context manager’s *Note __exit__(): 200. method is invoked.
     If an exception caused the suite to be exited, its type, value,
     and traceback are passed as arguments to *Note __exit__(): 200.
     Otherwise, three *Note None: 3b2. arguments are supplied.

     If the suite was exited due to an exception, and the return value
     from the *Note __exit__(): 200. method was false, the exception is
     reraised. If the return value was true, the exception is
     suppressed, and execution continues with the statement following
     the *Note with: 1c1. statement.

     If the suite was exited for any reason other than an exception,
     the return value from *Note __exit__(): 200. is ignored, and
     execution proceeds at the normal location for the kind of exit
     that was taken.

With more than one item, the context managers are processed as if
multiple *Note with: 1c1. statements were nested:

    with A() as a, B() as b:
        suite

is equivalent to

    with A() as a:
        with B() as b:
            suite

     Note: In Python 2.5, the *Note with: 1c1. statement is only
     allowed when the `with_statement' feature has been enabled.  It is
     always enabled in Python 2.6.

Changed in version 2.7: Support for multiple context expressions.

See also
........

PEP 343(1) - The “with” statement
     The specification, background, and examples for the Python *Note
     with: 1c1.  statement.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0343


File: python.info,  Node: Function definitions,  Next: Class definitions,  Prev: The with statement,  Up: Compound statements

4.7.6 Function definitions
--------------------------

A function definition defines a user-defined function object (see
section *Note The standard type hierarchy: 719.):

    decorated      ::= decorators (classdef | funcdef)
    decorators     ::= decorator+
    decorator      ::= "@" dotted_name ["(" [argument_list [","]] ")"] NEWLINE
    funcdef        ::= "def" funcname "(" [parameter_list] ")" ":" suite
    dotted_name    ::= identifier ("." identifier)*
    parameter_list ::= (defparameter ",")*
                       (  "*" identifier ["," "**" identifier]
                       | "**" identifier
                       | defparameter [","] )
    defparameter   ::= parameter ["=" expression]
    sublist        ::= parameter ("," parameter)* [","]
    parameter      ::= identifier | "(" sublist ")"
    funcname       ::= identifier

A function definition is an executable statement.  Its execution binds
the function name in the current local namespace to a function object
(a wrapper around the executable code for the function).  This function
object contains a reference to the current global namespace as the
global namespace to be used when the function is called.

The function definition does not execute the function body; this gets
executed only when the function is called. (1)

A function definition may be wrapped by one or more *Note decorator:
87e. expressions.  Decorator expressions are evaluated when the
function is defined, in the scope that contains the function
definition.  The result must be a callable, which is invoked with the
function object as the only argument. The returned value is bound to
the function name instead of the function object.  Multiple decorators
are applied in nested fashion. For example, the following code:

    @f1(arg)
    @f2
    def func(): pass

is equivalent to:

    def func(): pass
    func = f1(arg)(f2(func))

When one or more top-level *Note parameters: 7ef. have the form
`parameter' `=' `expression', the function is said to have “default
parameter values.”  For a parameter with a default value, the
corresponding *Note argument: 7e9. may be omitted from a call, in which
case the parameter’s default value is substituted.  If a parameter
has a default value, all following parameters must also have a default
value — this is a syntactic restriction that is not expressed by the
grammar.

`Default parameter values are evaluated when the function definition is
executed.'  This means that the expression is evaluated once, when the
function is defined, and that the same “pre-computed” value is used
for each call.  This is especially important to understand when a
default parameter is a mutable object, such as a list or a dictionary:
if the function modifies the object (e.g. by appending an item to a
list), the default value is in effect modified.  This is generally not
what was intended.  A way around this  is to use `None' as the default,
and explicitly test for it in the body of the function, e.g.:

    def whats_on_the_telly(penguin=None):
        if penguin is None:
            penguin = []
        penguin.append("property of the zoo")
        return penguin

Function call semantics are described in more detail in section *Note
Calls: 722. A function call always assigns values to all parameters
mentioned in the parameter list, either from position arguments, from
keyword arguments, or from default values.  If the form
“`*identifier'” is present, it is initialized to a tuple receiving
any excess positional parameters, defaulting to the empty tuple.  If
the form “`**identifier'” is present, it is initialized to a new
dictionary receiving any excess keyword arguments, defaulting to a new
empty dictionary.

It is also possible to create anonymous functions (functions not bound
to a name), for immediate use in expressions.  This uses lambda
expressions, described in section *Note Lambdas: 41c.  Note that the
lambda expression is merely a shorthand for a simplified function
definition; a function defined in a “*Note def: 40d.” statement can
be passed around or assigned to another name just like a function
defined by a lambda expression.  The “*Note def: 40d.” form is
actually more powerful since it allows the execution of multiple
statements.

`Programmer’s note:' Functions are first-class objects.  A
“`def'” form executed inside a function definition defines a local
function that can be returned or passed around.  Free variables used in
the nested function can access the local variables of the function
containing the def.  See section *Note Naming and binding: 793. for
details.

---------- Footnotes ----------

(1) A string literal appearing as the first statement in the function
body is transformed into the function’s `__doc__' attribute and
therefore the function’s *Note docstring: 87d.


File: python.info,  Node: Class definitions,  Prev: Function definitions,  Up: Compound statements

4.7.7 Class definitions
-----------------------

A class definition defines a class object (see section *Note The
standard type hierarchy: 719.):

    classdef    ::= "class" classname [inheritance] ":" suite
    inheritance ::= "(" [expression_list] ")"
    classname   ::= identifier

A class definition is an executable statement.  It first evaluates the
inheritance list, if present.  Each item in the inheritance list should
evaluate to a class object or class type which allows subclassing.  The
class’s suite is then executed in a new execution frame (see section
*Note Naming and binding: 793.), using a newly created local namespace
and the original global namespace. (Usually, the suite contains only
function definitions.)  When the class’s suite finishes execution,
its execution frame is discarded but its local namespace is saved. (1)
A class object is then created using the inheritance list for the base
classes and the saved local namespace for the attribute dictionary.  The
class name is bound to this class object in the original local
namespace.

`Programmer’s note:' Variables defined in the class definition are
class variables; they are shared by all instances.  To create instance
variables, they can be set in a method with `self.name = value'.  Both
class and instance variables are accessible through the notation
“`self.name'”, and an instance variable hides a class variable with
the same name when accessed in this way.  Class variables can be used
as defaults for instance variables, but using mutable values there can
lead to unexpected results.  For *Note new-style class: 5ec.es,
descriptors can be used to create instance variables with different
implementation details.

Class definitions, like function definitions, may be wrapped by one or
more *Note decorator: 87e. expressions.  The evaluation rules for the
decorator expressions are the same as for functions.  The result must
be a class object, which is then bound to the class name.

---------- Footnotes ----------

(1) A string literal appearing as the first statement in the class body
is transformed into the namespace’s `__doc__' item and therefore the
class’s *Note docstring: 87d.


File: python.info,  Node: Top-level components,  Next: Full Grammar specification,  Prev: Compound statements,  Up: The Python Language Reference

4.8 Top-level components
========================

The Python interpreter can get its input from a number of sources: from
a script passed to it as standard input or as program argument, typed
in interactively, from a module source file, etc.  This chapter gives
the syntax used in these cases.

* Menu:

* Complete Python programs::
* File input::
* Interactive input::
* Expression input::


File: python.info,  Node: Complete Python programs,  Next: File input,  Up: Top-level components

4.8.1 Complete Python programs
------------------------------

While a language specification need not prescribe how the language
interpreter is invoked, it is useful to have a notion of a complete
Python program.  A complete Python program is executed in a minimally
initialized environment: all built-in and standard modules are
available, but none have been initialized, except for *Note sys: 16d.
(various system services), *Note __builtin__: 0. (built-in functions,
exceptions and `None') and *Note __main__: 2.  The latter is used to
provide the local and global namespace for execution of the complete
program.

The syntax for a complete Python program is that for file input,
described in the next section.

The interpreter may also be invoked in interactive mode; in this case,
it does not read and execute a complete program but reads and executes
one statement (possibly compound) at a time.  The initial environment
is identical to that of a complete program; each statement is executed
in the namespace of *Note __main__: 2.

Under Unix, a complete program can be passed to the interpreter in
three forms: with the *Note -c: 523. `string' command line option, as a
file passed as the first command line argument, or as standard input.
If the file or standard input is a tty device, the interpreter enters
interactive mode; otherwise, it executes the file as a complete program.


File: python.info,  Node: File input,  Next: Interactive input,  Prev: Complete Python programs,  Up: Top-level components

4.8.2 File input
----------------

All input read from non-interactive files has the same form:

    file_input ::= (NEWLINE | statement)*

This syntax is used in the following situations:

   * when parsing a complete Python program (from a file or from a
     string);

   * when parsing a module;

   * when parsing a string passed to the *Note exec: 41d. statement;


File: python.info,  Node: Interactive input,  Next: Expression input,  Prev: File input,  Up: Top-level components

4.8.3 Interactive input
-----------------------

Input in interactive mode is parsed using the following grammar:

    interactive_input ::= [stmt_list] NEWLINE | compound_stmt NEWLINE

Note that a (top-level) compound statement must be followed by a blank
line in interactive mode; this is needed to help the parser detect the
end of the input.


File: python.info,  Node: Expression input,  Prev: Interactive input,  Up: Top-level components

4.8.4 Expression input
----------------------

There are two forms of expression input.  Both ignore leading
whitespace. The string argument to *Note eval(): 378. must have the
following form:

    eval_input ::= expression_list NEWLINE*

The input line read by *Note input(): 3d9. must have the following form:

    input_input ::= expression_list NEWLINE

Note: to read ‘raw’ input line without interpretation, you can use
the built-in function *Note raw_input(): 891. or the *Note readline():
145. method of file objects.


File: python.info,  Node: Full Grammar specification,  Prev: Top-level components,  Up: The Python Language Reference

4.9 Full Grammar specification
==============================

This is the full Python grammar, as it is read by the parser generator
and used to parse Python source files:

    # Grammar for Python

    # Note:  Changing the grammar specified in this file will most likely
    #        require corresponding changes in the parser module
    #        (../Modules/parsermodule.c).  If you can't make the changes to
    #        that module yourself, please co-ordinate the required changes
    #        with someone who can; ask around on python-dev for help.  Fred
    #        Drake <fdrake@acm.org> will probably be listening there.

    # NOTE WELL: You should also follow all the steps listed in PEP 306,
    # "How to Change Python's Grammar"

    # Start symbols for the grammar:
    #       single_input is a single interactive statement;
    #       file_input is a module or sequence of commands read from an input file;
    #       eval_input is the input for the eval() and input() functions.
    # NB: compound_stmt in single_input is followed by extra NEWLINE!
    single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE
    file_input: (NEWLINE | stmt)* ENDMARKER
    eval_input: testlist NEWLINE* ENDMARKER

    decorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE
    decorators: decorator+
    decorated: decorators (classdef | funcdef)
    funcdef: 'def' NAME parameters ':' suite
    parameters: '(' [varargslist] ')'
    varargslist: ((fpdef ['=' test] ',')*
                  ('*' NAME [',' '**' NAME] | '**' NAME) |
                  fpdef ['=' test] (',' fpdef ['=' test])* [','])
    fpdef: NAME | '(' fplist ')'
    fplist: fpdef (',' fpdef)* [',']

    stmt: simple_stmt | compound_stmt
    simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE
    small_stmt: (expr_stmt | print_stmt  | del_stmt | pass_stmt | flow_stmt |
                 import_stmt | global_stmt | exec_stmt | assert_stmt)
    expr_stmt: testlist (augassign (yield_expr|testlist) |
                         ('=' (yield_expr|testlist))*)
    augassign: ('+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' |
                '<<=' | '>>=' | '**=' | '//=')
    # For normal assignments, additional restrictions enforced by the interpreter
    print_stmt: 'print' ( [ test (',' test)* [','] ] |
                          '>>' test [ (',' test)+ [','] ] )
    del_stmt: 'del' exprlist
    pass_stmt: 'pass'
    flow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt
    break_stmt: 'break'
    continue_stmt: 'continue'
    return_stmt: 'return' [testlist]
    yield_stmt: yield_expr
    raise_stmt: 'raise' [test [',' test [',' test]]]
    import_stmt: import_name | import_from
    import_name: 'import' dotted_as_names
    import_from: ('from' ('.'* dotted_name | '.'+)
                  'import' ('*' | '(' import_as_names ')' | import_as_names))
    import_as_name: NAME ['as' NAME]
    dotted_as_name: dotted_name ['as' NAME]
    import_as_names: import_as_name (',' import_as_name)* [',']
    dotted_as_names: dotted_as_name (',' dotted_as_name)*
    dotted_name: NAME ('.' NAME)*
    global_stmt: 'global' NAME (',' NAME)*
    exec_stmt: 'exec' expr ['in' test [',' test]]
    assert_stmt: 'assert' test [',' test]

    compound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | with_stmt | funcdef | classdef | decorated
    if_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]
    while_stmt: 'while' test ':' suite ['else' ':' suite]
    for_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]
    try_stmt: ('try' ':' suite
               ((except_clause ':' suite)+
                ['else' ':' suite]
                ['finally' ':' suite] |
               'finally' ':' suite))
    with_stmt: 'with' with_item (',' with_item)*  ':' suite
    with_item: test ['as' expr]
    # NB compile.c makes sure that the default except clause is last
    except_clause: 'except' [test [('as' | ',') test]]
    suite: simple_stmt | NEWLINE INDENT stmt+ DEDENT

    # Backward compatibility cruft to support:
    # [ x for x in lambda: True, lambda: False if x() ]
    # even while also allowing:
    # lambda x: 5 if x else 2
    # (But not a mix of the two)
    testlist_safe: old_test [(',' old_test)+ [',']]
    old_test: or_test | old_lambdef
    old_lambdef: 'lambda' [varargslist] ':' old_test

    test: or_test ['if' or_test 'else' test] | lambdef
    or_test: and_test ('or' and_test)*
    and_test: not_test ('and' not_test)*
    not_test: 'not' not_test | comparison
    comparison: expr (comp_op expr)*
    comp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'
    expr: xor_expr ('|' xor_expr)*
    xor_expr: and_expr ('^' and_expr)*
    and_expr: shift_expr ('&' shift_expr)*
    shift_expr: arith_expr (('<<'|'>>') arith_expr)*
    arith_expr: term (('+'|'-') term)*
    term: factor (('*'|'/'|'%'|'//') factor)*
    factor: ('+'|'-'|'~') factor | power
    power: atom trailer* ['**' factor]
    atom: ('(' [yield_expr|testlist_comp] ')' |
           '[' [listmaker] ']' |
           '{' [dictorsetmaker] '}' |
           '`' testlist1 '`' |
           NAME | NUMBER | STRING+)
    listmaker: test ( list_for | (',' test)* [','] )
    testlist_comp: test ( comp_for | (',' test)* [','] )
    lambdef: 'lambda' [varargslist] ':' test
    trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME
    subscriptlist: subscript (',' subscript)* [',']
    subscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]
    sliceop: ':' [test]
    exprlist: expr (',' expr)* [',']
    testlist: test (',' test)* [',']
    dictorsetmaker: ( (test ':' test (comp_for | (',' test ':' test)* [','])) |
                      (test (comp_for | (',' test)* [','])) )

    classdef: 'class' NAME ['(' [testlist] ')'] ':' suite

    arglist: (argument ',')* (argument [',']
                             |'*' test (',' argument)* [',' '**' test]
                             |'**' test)
    # The reason that keywords are test nodes instead of NAME is that using NAME
    # results in an ambiguity. ast.c makes sure it's a NAME.
    argument: test [comp_for] | test '=' test

    list_iter: list_for | list_if
    list_for: 'for' exprlist 'in' testlist_safe [list_iter]
    list_if: 'if' old_test [list_iter]

    comp_iter: comp_for | comp_if
    comp_for: 'for' exprlist 'in' or_test [comp_iter]
    comp_if: 'if' old_test [comp_iter]

    testlist1: test (',' test)*

    # not used in grammar, but may appear in "node" passed from Parser to Compiler
    encoding_decl: NAME

    yield_expr: 'yield' [testlist]


File: python.info,  Node: The Python Standard Library,  Next: Extending and Embedding the Python Interpreter,  Prev: The Python Language Reference,  Up: Top

5 The Python Standard Library
*****************************

While *Note The Python Language Reference: 516. describes the exact
syntax and semantics of the Python language, this library reference
manual describes the standard library that is distributed with Python.
It also describes some of the optional components that are commonly
included in Python distributions.

Python’s standard library is very extensive, offering a wide range of
facilities as indicated by the long table of contents listed below. The
library contains built-in modules (written in C) that provide access to
system functionality such as file I/O that would otherwise be
inaccessible to Python programmers, as well as modules written in Python
that provide standardized solutions for many problems that occur in
everyday programming. Some of these modules are explicitly designed to
encourage and enhance the portability of Python programs by abstracting
away platform-specifics into platform-neutral APIs.

The Python installers for the Windows platform usually include the
entire standard library and often also include many additional
components. For Unix-like operating systems Python is normally provided
as a collection of packages, so it may be necessary to use the packaging
tools provided with the operating system to obtain some or all of the
optional components.

In addition to the standard library, there is a growing collection of
several thousand components (from individual programs and modules to
packages and entire application development frameworks), available from
the Python Package Index(1).

* Menu:

* Introduction: Introduction<5>.
* Built-in Functions::
* Non-essential Built-in Functions::
* Built-in Constants::
* Built-in Types::
* Built-in Exceptions::
* String Services::
* Data Types::
* Numeric and Mathematical Modules::
* File and Directory Access::
* Data Persistence::
* Data Compression and Archiving::
* File Formats::
* Cryptographic Services::
* Generic Operating System Services::
* Optional Operating System Services::
* Interprocess Communication and Networking::
* Internet Data Handling::
* Structured Markup Processing Tools::
* Internet Protocols and Support::
* Multimedia Services::
* Internationalization::
* Program Frameworks::
* Graphical User Interfaces with Tk::
* Development Tools::
* Debugging and Profiling::
* Software Packaging and Distribution::
* Python Runtime Services::
* Custom Python Interpreters::
* Restricted Execution::
* Importing Modules::
* Python Language Services::
* Python compiler package::
* Miscellaneous Services::
* MS Windows Specific Services::
* Unix Specific Services::
* Mac OS X specific services::
* MacPython OSA Modules::
* SGI IRIX Specific Services::
* SunOS Specific Services::
* Undocumented Modules::

---------- Footnotes ----------

(1) https://pypi.python.org/pypi


File: python.info,  Node: Introduction<5>,  Next: Built-in Functions,  Up: The Python Standard Library

5.1 Introduction
================

The “Python library” contains several different kinds of components.

It contains data types that would normally be considered part of the
“core” of a language, such as numbers and lists.  For these types,
the Python language core defines the form of literals and places some
constraints on their semantics, but does not fully define the
semantics.  (On the other hand, the language core does define syntactic
properties like the spelling and priorities of operators.)

The library also contains built-in functions and exceptions — objects
that can be used by all Python code without the need of an *Note
import: 1f4. statement.  Some of these are defined by the core
language, but many are not essential for the core semantics and are
only described here.

The bulk of the library, however, consists of a collection of modules.
There are many ways to dissect this collection.  Some modules are
written in C and built in to the Python interpreter; others are written
in Python and imported in source form.  Some modules provide interfaces
that are highly specific to Python, like printing a stack trace; some
provide interfaces that are specific to particular operating systems,
such as access to specific hardware; others provide interfaces that are
specific to a particular application domain, like the World Wide Web.
Some modules are available in all versions and ports of Python; others
are only available when the underlying system supports or requires
them; yet others are available only when a particular configuration
option was chosen at the time when Python was compiled and installed.

This manual is organized “from the inside out:” it first describes
the built-in data types, then the built-in functions and exceptions,
and finally the modules, grouped in chapters of related modules.  The
ordering of the chapters as well as the ordering of the modules within
each chapter is roughly from most relevant to least important.

This means that if you start reading this manual from the start, and
skip to the next chapter when you get bored, you will get a reasonable
overview of the available modules and application areas that are
supported by the Python library.  Of course, you don’t `have' to read
it like a novel — you can also browse the table of contents (in front
of the manual), or look for a specific function, module or term in the
index (in the back).  And finally, if you enjoy learning about random
subjects, you choose a random page number (see module *Note random:
143.) and read a section or two.  Regardless of the order in which you
read the sections of this manual, it helps to start with chapter *Note
Built-in Functions: 7f0, as the remainder of the manual assumes
familiarity with this material.

Let the show begin!


File: python.info,  Node: Built-in Functions,  Next: Non-essential Built-in Functions,  Prev: Introduction<5>,  Up: The Python Standard Library

5.2 Built-in Functions
======================

The Python interpreter has a number of functions built into it that are
always available.  They are listed here in alphabetical order.

                                              Built-in Functions                           
-------------------------------------------------------------------------------------------------------------------- 
*Note abs(): 5da.       *Note divmod(): 768.  *Note input(): 3d9.    *Note open(): 2d9.    *Note staticmethod():
                                                                                           40e.
*Note all(): 3c7.       *Note enumerate():    *Note int(): 1f2.      *Note ord(): 71f.     *Note str(): 1ea.
                        440.                                                               
*Note any(): 3c6.       *Note eval(): 378.    *Note isinstance():    *Note pow(): 4d1.     *Note sum(): 43f.
                                              332.                                         
*Note basestring():     *Note execfile():     *Note issubclass():    *Note print(): 31f.   *Note super(): 395.
474.                    44f.                  333.                                         
*Note bin(): 2fd.       *Note file(): 1f9.    *Note iter(): 334.     *Note property():     *Note tuple(): 421.
                                                                     4a4.                  
*Note bool(): 455.      *Note filter(): 422.  *Note len(): 53c.      *Note range(): 2db.   *Note type(): 4ac.
*Note bytearray(): 1f7. *Note float(): 1eb.   *Note list(): 3d6.     *Note raw_input():    *Note unichr(): 4b1.
                                                                     891.                  
*Note callable(): 89b.  *Note format(): 1ef.  *Note locals(): 350.   *Note reduce(): 2fc.  *Note unicode(): 1f5.
*Note chr(): 71e.       *Note frozenset():    *Note long(): 1f3.     *Note reload(): 595.  *Note vars(): 5b3.
                        89c.                                                               
*Note classmethod():    *Note getattr(): 89d. *Note map(): 318.      *Note repr(): 89e.    *Note xrange(): 477.
40f.                                                                                       
*Note cmp(): 4da.       *Note globals(): 85d. *Note max(): 225.      *Note reversed():     *Note zip(): 41e.
                                                                     411.                  
*Note compile(): 1fb.   *Note hasattr(): 344. *Note memoryview():    *Note round(): 1c7.   *Note __import__(): 396.
                                              89f.                                         
*Note complex(): 1ec.   *Note hash(): 733.    *Note min(): 224.      *Note set(): 8a0.     
*Note delattr(): 8a1.   *Note help(): 4b6.    *Note next(): 3b1.     *Note setattr(): 8a2. 
*Note dict(): 8a3.      *Note hex(): 348.     *Note object(): 1f1.   *Note slice(): 469.   
*Note dir(): 34e.       *Note id(): 3ca.      *Note oct(): 339.      *Note sorted(): 223.  

In addition, there are other four built-in functions that are no longer
considered essential: *Note apply(): 317, *Note buffer(): 32a, *Note
coerce(): 789, and *Note intern(): 8a4.  They are documented in the
*Note Non-essential Built-in Functions: 8a5.  section.

 -- Function: abs (x)
     Return the absolute value of a number.  The argument may be a
     plain or long integer or a floating point number.  If the argument
     is a complex number, its magnitude is returned.

 -- Function: all (iterable)
     Return `True' if all elements of the `iterable' are true (or if
     the iterable is empty).  Equivalent to:

         def all(iterable):
             for element in iterable:
                 if not element:
                     return False
             return True

     New in version 2.5.


 -- Function: any (iterable)
     Return `True' if any element of the `iterable' is true.  If the
     iterable is empty, return `False'.  Equivalent to:

         def any(iterable):
             for element in iterable:
                 if element:
                     return True
             return False

     New in version 2.5.


 -- Function: basestring ()
     This abstract type is the superclass for *Note str: 1ea. and *Note
     unicode: 1f5. It cannot be called or instantiated, but it can be
     used to test whether an object is an instance of *Note str: 1ea.
     or *Note unicode: 1f5. `isinstance(obj, basestring)' is equivalent
     to `isinstance(obj, (str, unicode))'.

     New in version 2.3.


 -- Function: bin (x)
     Convert an integer number to a binary string. The result is a
     valid Python expression.  If `x' is not a Python *Note int: 1f2.
     object, it has to define an *Note __index__(): 260. method that
     returns an integer.

     New in version 2.6.


 -- Class: bool ([x])
     Return a Boolean value, i.e. one of `True' or `False'.  `x' is
     converted using the standard truth testing procedure.  If `x' is
     false or omitted, this returns *Note False: 3c9.; otherwise it
     returns *Note True: 3c8. *Note bool: 455. is also a class, which
     is a subclass of *Note int: 1f2. Class *Note bool: 455. cannot be
     subclassed further.  Its only instances are *Note False: 3c9. and
     *Note True: 3c8.

     New in version 2.2.1.

     Changed in version 2.3: If no argument is given, this function
     returns *Note False: 3c9.


 -- Class: bytearray ([source[, encoding[, errors]]])
     Return a new array of bytes.  The *Note bytearray: 1f7. class is a
     mutable sequence of integers in the range 0 <= x < 256.  It has
     most of the usual methods of mutable sequences, described in *Note
     Mutable Sequence Types: 8a6, as well as most methods that the
     *Note str: 1ea. type has, see *Note String Methods: 53e.

     The optional `source' parameter can be used to initialize the
     array in a few different ways:

        * If it is `unicode', you must also give the `encoding' (and
          optionally, `errors') parameters; *Note bytearray(): 1f7.
          then converts the unicode to bytes using `unicode.encode()'.

        * If it is an `integer', the array will have that size and will
          be initialized with null bytes.

        * If it is an object conforming to the `buffer' interface, a
          read-only buffer of the object will be used to initialize the
          bytes array.

        * If it is an `iterable', it must be an iterable of integers in
          the range `0 <= x < 256', which are used as the initial
          contents of the array.

     Without an argument, an array of size 0 is created.

     New in version 2.6.


 -- Function: callable (object)
     Return *Note True: 3c8. if the `object' argument appears callable,
     *Note False: 3c9. if not.  If this returns true, it is still
     possible that a call fails, but if it is false, calling `object'
     will never succeed.  Note that classes are callable (calling a
     class returns a new instance); class instances are callable if
     they have a *Note __call__(): 725. method.

 -- Function: chr (i)
     Return a string of one character whose ASCII code is the integer
     `i'.  For example, `chr(97)' returns the string `'a''. This is the
     inverse of *Note ord(): 71f.  The argument must be in the range
     [0..255], inclusive; *Note ValueError: 236. will be raised if `i'
     is outside that range. See also *Note unichr(): 4b1.

 -- Function: classmethod (function)
     Return a class method for `function'.

     A class method receives the class as implicit first argument, just
     like an instance method receives the instance. To declare a class
     method, use this idiom:

         class C(object):
             @classmethod
             def f(cls, arg1, arg2, ...):
                 ...

     The `@classmethod' form is a function *Note decorator: 87e. –
     see the description of function definitions in *Note Function
     definitions: 723. for details.

     It can be called either on the class (such as `C.f()') or on an
     instance (such as `C().f()').  The instance is ignored except for
     its class. If a class method is called for a derived class, the
     derived class object is passed as the implied first argument.

     Class methods are different than C++ or Java static methods. If
     you want those, see *Note staticmethod(): 40e. in this section.

     For more information on class methods, consult the documentation
     on the standard type hierarchy in *Note The standard type
     hierarchy: 719.

     New in version 2.2.

     Changed in version 2.4: Function decorator syntax added.


 -- Function: cmp (x, y)
     Compare the two objects `x' and `y' and return an integer
     according to the outcome.  The return value is negative if `x <
     y', zero if `x == y' and strictly positive if `x > y'.

 -- Function: compile (source, filename, mode[, flags[, dont_inherit]])
     Compile the `source' into a code or AST object.  Code objects can
     be executed by an *Note exec: 41d. statement or evaluated by a
     call to *Note eval(): 378.  `source' can either be a Unicode
     string, a `Latin-1' encoded string or an AST object.  Refer to the
     *Note ast: f. module documentation for information on how to work
     with AST objects.

     The `filename' argument should give the file from which the code
     was read; pass some recognizable value if it wasn’t read from a
     file (`'<string>'' is commonly used).

     The `mode' argument specifies what kind of code must be compiled;
     it can be `'exec'' if `source' consists of a sequence of
     statements, `'eval'' if it consists of a single expression, or
     `'single'' if it consists of a single interactive statement (in
     the latter case, expression statements that evaluate to something
     other than `None' will be printed).

     The optional arguments `flags' and `dont_inherit' control which
     future statements (see PEP 236(1)) affect the compilation of
     `source'.  If neither is present (or both are zero) the code is
     compiled with those future statements that are in effect in the
     code that is calling *Note compile(): 1fb.  If the `flags'
     argument is given and `dont_inherit' is not (or is zero) then the
     future statements specified by the `flags' argument are used in
     addition to those that would be used anyway. If `dont_inherit' is
     a non-zero integer then the `flags' argument is it – the future
     statements in effect around the call to compile are ignored.

     Future statements are specified by bits which can be bitwise ORed
     together to specify multiple statements.  The bitfield required to
     specify a given feature can be found as the `compiler_flag'
     attribute on the `_Feature' instance in the *Note __future__: 1.
     module.

     This function raises *Note SyntaxError: 4b4. if the compiled
     source is invalid, and *Note TypeError: 218. if the source
     contains null bytes.

     If you want to parse Python code into its AST representation, see
     *Note ast.parse(): 8a7.

          Note: When compiling a string with multi-line code in
          `'single'' or `'eval'' mode, input must be terminated by at
          least one newline character.  This is to facilitate detection
          of incomplete and complete statements in the *Note code: 62.
          module.

     Changed in version 2.3: The `flags' and `dont_inherit' arguments
     were added.

     Changed in version 2.6: Support for compiling AST objects.

     Changed in version 2.7: Allowed use of Windows and Mac newlines.
     Also input in `'exec'' mode does not have to end in a newline
     anymore.


 -- Class: complex ([real[, imag]])
     Return a complex number with the value `real' + `imag'*1j or
     convert a string or number to a complex number.  If the first
     parameter is a string, it will be interpreted as a complex number
     and the function must be called without a second parameter.  The
     second parameter can never be a string. Each argument may be any
     numeric type (including complex). If `imag' is omitted, it
     defaults to zero and the function serves as a numeric conversion
     function like *Note int(): 1f2, *Note long(): 1f3. and *Note
     float(): 1eb.  If both arguments are omitted, returns `0j'.

          Note: When converting from a string, the string must not
          contain whitespace around the central `+' or `-' operator.
          For example, `complex('1+2j')' is fine, but `complex('1 +
          2j')' raises *Note ValueError: 236.

     The complex type is described in *Note Numeric Types — int,
     float, long, complex: 538.

 -- Function: delattr (object, name)
     This is a relative of *Note setattr(): 8a2.  The arguments are an
     object and a string.  The string must be the name of one of the
     object’s attributes.  The function deletes the named attribute,
     provided the object allows it.  For example, `delattr(x,
     'foobar')' is equivalent to `del x.foobar'.

 -- Class: dict (**kwarg)
 -- Class: dict (mapping, **kwarg)
 -- Class: dict (iterable, **kwarg)
     Create a new dictionary.  The *Note dict: 319. object is the
     dictionary class.  See *Note dict: 319. and *Note Mapping Types
     — dict: 569. for documentation about this class.

     For other containers see the built-in *Note list: 3d6, *Note set:
     382, and *Note tuple: 421. classes, as well as the *Note
     collections: 65. module.

 -- Function: dir ([object])
     Without arguments, return the list of names in the current local
     scope.  With an argument, attempt to return a list of valid
     attributes for that object.

     If the object has a method named `__dir__()', this method will be
     called and must return the list of attributes. This allows objects
     that implement a custom *Note __getattr__(): 345. or *Note
     __getattribute__(): 34f. function to customize the way *Note
     dir(): 34e. reports their attributes.

     If the object does not provide `__dir__()', the function tries its
     best to gather information from the object’s *Note __dict__:
     4a0. attribute, if defined, and from its type object.  The
     resulting list is not necessarily complete, and may be inaccurate
     when the object has a custom *Note __getattr__(): 345.

     The default *Note dir(): 34e. mechanism behaves differently with
     different types of objects, as it attempts to produce the most
     relevant, rather than complete, information:

        * If the object is a module object, the list contains the names
          of the module’s attributes.

        * If the object is a type or class object, the list contains
          the names of its attributes, and recursively of the
          attributes of its bases.

        * Otherwise, the list contains the object’s attributes’
          names, the names of its class’s attributes, and recursively
          of the attributes of its class’s base classes.

     The resulting list is sorted alphabetically.  For example:

         >>> import struct
         >>> dir()   # show the names in the module namespace
         ['__builtins__', '__doc__', '__name__', 'struct']
         >>> dir(struct)   # show the names in the struct module
         ['Struct', '__builtins__', '__doc__', '__file__', '__name__',
          '__package__', '_clearcache', 'calcsize', 'error', 'pack', 'pack_into',
          'unpack', 'unpack_from']
         >>> class Shape(object):
                 def __dir__(self):
                     return ['area', 'perimeter', 'location']
         >>> s = Shape()
         >>> dir(s)
         ['area', 'perimeter', 'location']

          Note: Because *Note dir(): 34e. is supplied primarily as a
          convenience for use at an interactive prompt, it tries to
          supply an interesting set of names more than it tries to
          supply a rigorously or consistently defined set of names, and
          its detailed behavior may change across releases.  For
          example, metaclass attributes are not in the result list when
          the argument is a class.

 -- Function: divmod (a, b)
     Take two (non complex) numbers as arguments and return a pair of
     numbers consisting of their quotient and remainder when using long
     division.  With mixed operand types, the rules for binary
     arithmetic operators apply.  For plain and long integers, the
     result is the same as `(a // b, a % b)'. For floating point
     numbers the result is `(q, a % b)', where `q' is usually
     `math.floor(a / b)' but may be 1 less than that.  In any case `q *
     b + a % b' is very close to `a', if `a % b' is non-zero it has the
     same sign as `b', and `0 <= abs(a % b) < abs(b)'.

     Changed in version 2.3: Using *Note divmod(): 768. with complex
     numbers is deprecated.


 -- Function: enumerate (sequence, start=0)
     Return an enumerate object. `sequence' must be a sequence, an
     *Note iterator: 8a8, or some other object which supports
     iteration.  The `next()' method of the iterator returned by *Note
     enumerate(): 440. returns a tuple containing a count (from `start'
     which defaults to 0) and the values obtained from iterating over
     `sequence':

         >>> seasons = ['Spring', 'Summer', 'Fall', 'Winter']
         >>> list(enumerate(seasons))
         [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
         >>> list(enumerate(seasons, start=1))
         [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]

     Equivalent to:

         def enumerate(sequence, start=0):
             n = start
             for elem in sequence:
                 yield n, elem
                 n += 1

     New in version 2.3.

     Changed in version 2.6: The `start' parameter was added.


 -- Function: eval (expression[, globals[, locals]])
     The arguments are a Unicode or `Latin-1' encoded string and
     optional globals and locals.  If provided, `globals' must be a
     dictionary.  If provided, `locals' can be any mapping object.

     Changed in version 2.4: formerly `locals' was required to be a
     dictionary.

     The `expression' argument is parsed and evaluated as a Python
     expression (technically speaking, a condition list) using the
     `globals' and `locals' dictionaries as global and local namespace.
     If the `globals' dictionary is present and lacks
     ‘__builtins__’, the current globals are copied into `globals'
     before `expression' is parsed.  This means that `expression'
     normally has full access to the standard *Note __builtin__: 0.
     module and restricted environments are propagated.  If the
     `locals' dictionary is omitted it defaults to the `globals'
     dictionary.  If both dictionaries are omitted, the expression is
     executed in the environment where *Note eval(): 378. is called.
     The return value is the result of the evaluated expression. Syntax
     errors are reported as exceptions.  Example:

         >>> x = 1
         >>> print eval('x+1')
         2

     This function can also be used to execute arbitrary code objects
     (such as those created by *Note compile(): 1fb.).  In this case
     pass a code object instead of a string.  If the code object has
     been compiled with `'exec'' as the `mode' argument, *Note eval():
     378.’s return value will be `None'.

     Hints: dynamic execution of statements is supported by the *Note
     exec: 41d.  statement.  Execution of statements from a file is
     supported by the *Note execfile(): 44f. function.  The *Note
     globals(): 85d. and *Note locals(): 350. functions returns the
     current global and local dictionary, respectively, which may be
     useful to pass around for use by *Note eval(): 378. or *Note
     execfile(): 44f.

     See *Note ast.literal_eval(): 8a9. for a function that can safely
     evaluate strings with expressions containing only literals.

 -- Function: execfile (filename[, globals[, locals]])
     This function is similar to the *Note exec: 41d. statement, but
     parses a file instead of a string.  It is different from the *Note
     import: 1f4. statement in that it does not use the module
     administration — it reads the file unconditionally and does not
     create a new module. (2)

     The arguments are a file name and two optional dictionaries.  The
     file is parsed and evaluated as a sequence of Python statements
     (similarly to a module) using the `globals' and `locals'
     dictionaries as global and local namespace. If provided, `locals'
     can be any mapping object.  Remember that at module level, globals
     and locals are the same dictionary. If two separate objects are
     passed as `globals' and `locals', the code will be executed as if
     it were embedded in a class definition.

     Changed in version 2.4: formerly `locals' was required to be a
     dictionary.

     If the `locals' dictionary is omitted it defaults to the `globals'
     dictionary.  If both dictionaries are omitted, the expression is
     executed in the environment where *Note execfile(): 44f. is
     called.  The return value is `None'.

          Note: The default `locals' act as described for function
          *Note locals(): 350. below: modifications to the default
          `locals' dictionary should not be attempted.  Pass an
          explicit `locals' dictionary if you need to see effects of
          the code on `locals' after function *Note execfile(): 44f.
          returns.  *Note execfile(): 44f. cannot be used reliably to
          modify a function’s locals.

 -- Function: file (name[, mode[, buffering]])
     Constructor function for the *Note file: 1f9. type, described
     further in section *Note File Objects: 66e.  The constructor’s
     arguments are the same as those of the *Note open(): 2d9. built-in
     function described below.

     When opening a file, it’s preferable to use *Note open(): 2d9.
     instead of  invoking this constructor directly.  *Note file: 1f9.
     is more suited to type testing (for example, writing
     `isinstance(f, file)').

     New in version 2.2.


 -- Function: filter (function, iterable)
     Construct a list from those elements of `iterable' for which
     `function' returns true.  `iterable' may be either a sequence, a
     container which supports iteration, or an iterator.  If `iterable'
     is a string or a tuple, the result also has that type; otherwise
     it is always a list.  If `function' is `None', the identity
     function is assumed, that is, all elements of `iterable' that are
     false are removed.

     Note that `filter(function, iterable)' is equivalent to `[item for
     item in iterable if function(item)]' if function is not `None' and
     `[item for item in iterable if item]' if function is `None'.

     See *Note itertools.ifilter(): 8aa. and *Note
     itertools.ifilterfalse(): 8ab. for iterator versions of this
     function, including a variation that filters for elements where
     the `function' returns false.

 -- Class: float ([x])
     Return a floating point number constructed from a number or string
     `x'.

     If the argument is a string, it must contain a possibly signed
     decimal or floating point number, possibly embedded in whitespace.
     The argument may also be [+|-]nan or [+|-]inf.  Otherwise, the
     argument may be a plain or long integer or a floating point
     number, and a floating point number with the same value (within
     Python’s floating point precision) is returned.  If no argument
     is given, returns `0.0'.

          Note: 

          When passing in a string, values for NaN and Infinity may be
          returned, depending on the underlying C library.  Float
          accepts the strings nan, inf and -inf for NaN and positive or
          negative infinity. The case and a leading + are ignored as
          well as a leading - is ignored for NaN. Float always
          represents NaN and infinity as nan, inf or -inf.

     The float type is described in *Note Numeric Types — int, float,
     long, complex: 538.

 -- Function: format (value[, format_spec])
     Convert a `value' to a “formatted” representation, as
     controlled by `format_spec'.  The interpretation of `format_spec'
     will depend on the type of the `value' argument, however there is
     a standard formatting syntax that is used by most built-in types:
     *Note Format Specification Mini-Language: 8ac.

          Note: `format(value, format_spec)' merely calls
          `value.__format__(format_spec)'.

     New in version 2.6.


 -- Class: frozenset ([iterable])
     Return a new *Note frozenset: 383. object, optionally with
     elements taken from `iterable'.  `frozenset' is a built-in class.
     See *Note frozenset: 383. and *Note Set Types — set, frozenset:
     8ad. for documentation about this class.

     For other containers see the built-in *Note set: 382, *Note list:
     3d6, *Note tuple: 421, and *Note dict: 319. classes, as well as
     the *Note collections: 65.  module.

     New in version 2.4.


 -- Function: getattr (object, name[, default])
     Return the value of the named attribute of `object'.  `name' must
     be a string.  If the string is the name of one of the object’s
     attributes, the result is the value of that attribute.  For
     example, `getattr(x, 'foobar')' is equivalent to `x.foobar'.  If
     the named attribute does not exist, `default' is returned if
     provided, otherwise *Note AttributeError: 1f8. is raised.

 -- Function: globals ()
     Return a dictionary representing the current global symbol table.
     This is always the dictionary of the current module (inside a
     function or method, this is the module where it is defined, not
     the module from which it is called).

 -- Function: hasattr (object, name)
     The arguments are an object and a string.  The result is `True' if
     the string is the name of one of the object’s attributes,
     `False' if not. (This is implemented by calling `getattr(object,
     name)' and seeing whether it raises an exception or not.)

 -- Function: hash (object)
     Return the hash value of the object (if it has one).  Hash values
     are integers.  They are used to quickly compare dictionary keys
     during a dictionary lookup.  Numeric values that compare equal
     have the same hash value (even if they are of different types, as
     is the case for 1 and 1.0).

 -- Function: help ([object])
     Invoke the built-in help system.  (This function is intended for
     interactive use.)  If no argument is given, the interactive help
     system starts on the interpreter console.  If the argument is a
     string, then the string is looked up as the name of a module,
     function, class, method, keyword, or documentation topic, and a
     help page is printed on the console.  If the argument is any other
     kind of object, a help page on the object is generated.

     This function is added to the built-in namespace by the *Note
     site: 158. module.

     New in version 2.2.


 -- Function: hex (x)
     Convert an integer number (of any size) to a lowercase hexadecimal
     string prefixed with “0x”, for example:

         >>> hex(255)
         '0xff'
         >>> hex(-42)
         '-0x2a'
         >>> hex(1L)
         '0x1L'

     If x is not a Python *Note int: 1f2. or *Note long: 1f3. object,
     it has to define an __index__() method that returns an integer.

     See also *Note int(): 1f2. for converting a hexadecimal string to
     an integer using a base of 16.

          Note: To obtain a hexadecimal string representation for a
          float, use the *Note float.hex(): 8ae. method.

     Changed in version 2.4: Formerly only returned an unsigned literal.


 -- Function: id (object)
     Return the “identity” of an object.  This is an integer (or
     long integer) which is guaranteed to be unique and constant for
     this object during its lifetime.  Two objects with non-overlapping
     lifetimes may have the same *Note id(): 3ca.  value.

     `CPython implementation detail:' This is the address of the object
     in memory.

 -- Function: input ([prompt])
     Equivalent to `eval(raw_input(prompt))'.

     This function does not catch user errors. If the input is not
     syntactically valid, a *Note SyntaxError: 4b4. will be raised.
     Other exceptions may be raised if there is an error during
     evaluation.

     If the *Note readline: 145. module was loaded, then *Note input():
     3d9. will use it to provide elaborate line editing and history
     features.

     Consider using the *Note raw_input(): 891. function for general
     input from users.

 -- Class: int (x=0)
 -- Class: int (x, base=10)
     Return an integer object constructed from a number or string `x',
     or return `0' if no arguments are given.  If `x' is a number, it
     can be a plain integer, a long integer, or a floating point
     number.  If `x' is floating point, the conversion truncates
     towards zero.  If the argument is outside the integer range, the
     function returns a long object instead.

     If `x' is not a number or if `base' is given, then `x' must be a
     string or Unicode object representing an *Note integer literal:
     6f7. in radix `base'.  Optionally, the literal can be preceded by
     `+' or `-' (with no space in between) and surrounded by
     whitespace.  A base-n literal consists of the digits 0 to n-1,
     with `a' to `z' (or `A' to `Z') having values 10 to 35.  The
     default `base' is 10. The allowed values are 0 and 2–36.
     Base-2, -8, and -16 literals can be optionally prefixed with
     `0b'/`0B', `0o'/`0O'/`0', or `0x'/`0X', as with integer literals
     in code.  Base 0 means to interpret the string exactly as an
     integer literal, so that the actual base is 2, 8, 10, or 16.

     The integer type is described in *Note Numeric Types — int,
     float, long, complex: 538.

 -- Function: isinstance (object, classinfo)
     Return true if the `object' argument is an instance of the
     `classinfo' argument, or of a (direct, indirect or *Note virtual:
     8af.) subclass thereof.  Also return true if `classinfo' is a type
     object (new-style class) and `object' is an object of that type or
     of a (direct, indirect or *Note virtual: 8af.) subclass thereof.
     If `object' is not a class instance or an object of the given
     type, the function always returns false.  If `classinfo' is a
     tuple of class or type objects (or recursively, other such
     tuples), return true if `object' is an instance of any of the
     classes or types.  If `classinfo' is not a class, type, or tuple
     of classes, types, and such tuples, a *Note TypeError: 218.
     exception is raised.

     Changed in version 2.2: Support for a tuple of type information
     was added.


 -- Function: issubclass (class, classinfo)
     Return true if `class' is a subclass (direct, indirect or *Note
     virtual: 8af.) of `classinfo'.  A class is considered a subclass
     of itself. `classinfo' may be a tuple of class objects, in which
     case every entry in `classinfo' will be checked. In any other
     case, a *Note TypeError: 218. exception is raised.

     Changed in version 2.3: Support for a tuple of type information
     was added.


 -- Function: iter (o[, sentinel])
     Return an *Note iterator: 8a8. object.  The first argument is
     interpreted very differently depending on the presence of the
     second argument. Without a second argument, `o' must be a
     collection object which supports the iteration protocol (the *Note
     __iter__(): 335. method), or it must support the sequence protocol
     (the *Note __getitem__(): 468. method with integer arguments
     starting at `0').  If it does not support either of those
     protocols, *Note TypeError: 218. is raised. If the second
     argument, `sentinel', is given, then `o' must be a callable
     object.  The iterator created in this case will call `o' with no
     arguments for each call to its *Note next(): 5f4. method; if the
     value returned is equal to `sentinel', *Note StopIteration: 347.
     will be raised, otherwise the value will be returned.

     One useful application of the second form of *Note iter(): 334. is
     to read lines of a file until a certain line is reached.  The
     following example reads a file until the *Note readline(): 8b0.
     method returns an empty string:

         with open('mydata.txt') as fp:
             for line in iter(fp.readline, ''):
                 process_line(line)

     New in version 2.2.


 -- Function: len (s)
     Return the length (the number of items) of an object.  The
     argument may be a sequence (such as a string, bytes, tuple, list,
     or range) or a collection (such as a dictionary, set, or frozen
     set).

 -- Class: list ([iterable])
     Return a list whose items are the same and in the same order as
     `iterable'’s items.  `iterable' may be either a sequence, a
     container that supports iteration, or an iterator object.  If
     `iterable' is already a list, a copy is made and returned, similar
     to `iterable[:]'.  For instance, `list('abc')' returns `['a', 'b',
     'c']' and `list( (1, 2, 3) )' returns `[1, 2, 3]'.  If no argument
     is given, returns a new empty list, `[]'.

     *Note list: 3d6. is a mutable sequence type, as documented in
     *Note Sequence Types — str, unicode, list, tuple, bytearray,
     buffer, xrange: 53d. For other containers see the built in *Note
     dict: 319, *Note set: 382, and *Note tuple: 421. classes, and the
     *Note collections: 65. module.

 -- Function: locals ()
     Update and return a dictionary representing the current local
     symbol table.  Free variables are returned by *Note locals(): 350.
     when it is called in function blocks, but not in class blocks.

          Note: The contents of this dictionary should not be modified;
          changes may not affect the values of local and free variables
          used by the interpreter.

 -- Class: long (x=0)
 -- Class: long (x, base=10)
     Return a long integer object constructed from a string or number
     `x'.  If the argument is a string, it must contain a possibly
     signed number of arbitrary size, possibly embedded in whitespace.
     The `base' argument is interpreted in the same way as for *Note
     int(): 1f2, and may only be given when `x' is a string. Otherwise,
     the argument may be a plain or long integer or a floating point
     number, and a long integer with the same value is returned.
     Conversion of floating point numbers to integers truncates
     (towards zero).  If no arguments are given, returns `0L'.

     The long type is described in *Note Numeric Types — int, float,
     long, complex: 538.

 -- Function: map (function, iterable, ...)
     Apply `function' to every item of `iterable' and return a list of
     the results.  If additional `iterable' arguments are passed,
     `function' must take that many arguments and is applied to the
     items from all iterables in parallel.  If one iterable is shorter
     than another it is assumed to be extended with `None' items.  If
     `function' is `None', the identity function is assumed; if there
     are multiple arguments, *Note map(): 318. returns a list
     consisting of tuples containing the corresponding items from all
     iterables (a kind of transpose operation).  The `iterable'
     arguments may be a sequence  or any iterable object; the result is
     always a list.

 -- Function: max (iterable[, key])
 -- Function: max (arg1, arg2, *args[, key])
     Return the largest item in an iterable or the largest of two or
     more arguments.

     If one positional argument is provided, `iterable' must be a
     non-empty iterable (such as a non-empty string, tuple or list).
     The largest item in the iterable is returned.  If two or more
     positional arguments are provided, the largest of the positional
     arguments is returned.

     The optional `key' argument specifies a one-argument ordering
     function like that used for `list.sort()'.  The `key' argument, if
     supplied, must be in keyword form (for example,
     `max(a,b,c,key=func)').

     Changed in version 2.5: Added support for the optional `key'
     argument.


 -- Function: memoryview (obj)
     Return a “memory view” object created from the given argument.
     See *Note memoryview type: 8b1. for more information.

 -- Function: min (iterable[, key])
 -- Function: min (arg1, arg2, *args[, key])
     Return the smallest item in an iterable or the smallest of two or
     more arguments.

     If one positional argument is provided, `iterable' must be a
     non-empty iterable (such as a non-empty string, tuple or list).
     The smallest item in the iterable is returned.  If two or more
     positional arguments are provided, the smallest of the positional
     arguments is returned.

     The optional `key' argument specifies a one-argument ordering
     function like that used for `list.sort()'.  The `key' argument, if
     supplied, must be in keyword form (for example,
     `min(a,b,c,key=func)').

     Changed in version 2.5: Added support for the optional `key'
     argument.


 -- Function: next (iterator[, default])
     Retrieve the next item from the `iterator' by calling its *Note
     next(): 5f4. method.  If `default' is given, it is returned if the
     iterator is exhausted, otherwise *Note StopIteration: 347. is
     raised.

     New in version 2.6.


 -- Class: object
     Return a new featureless object.  *Note object: 1f1. is a base for
     all new style classes.  It has the methods that are common to all
     instances of new style classes.

     New in version 2.2.

     Changed in version 2.3: This function does not accept any
     arguments. Formerly, it accepted arguments but ignored them.


 -- Function: oct (x)
     Convert an integer number (of any size) to an octal string.  The
     result is a valid Python expression.

     Changed in version 2.4: Formerly only returned an unsigned literal.


 -- Function: open (name[, mode[, buffering]])
     Open a file, returning an object of the *Note file: 1f9. type
     described in section *Note File Objects: 66e.  If the file cannot
     be opened, *Note IOError: 1fa. is raised.  When opening a file,
     it’s preferable to use *Note open(): 2d9. instead of invoking
     the *Note file: 1f9. constructor directly.

     The first two arguments are the same as for `stdio'’s `fopen()':
     `name' is the file name to be opened, and `mode' is a string
     indicating how the file is to be opened.

     The most commonly-used values of `mode' are `'r'' for reading,
     `'w'' for writing (truncating the file if it already exists), and
     `'a'' for appending (which on `some' Unix systems means that `all'
     writes append to the end of the file regardless of the current
     seek position).  If `mode' is omitted, it defaults to `'r''.  The
     default is to use text mode, which may convert `'\n'' characters
     to a platform-specific representation on writing and back on
     reading.  Thus, when opening a binary file, you should append
     `'b'' to the `mode' value to open the file in binary mode, which
     will improve portability.  (Appending `'b'' is useful even on
     systems that don’t treat binary and text files differently,
     where it serves as documentation.)  See below for more possible
     values of `mode'.

     The optional `buffering' argument specifies the file’s desired
     buffer size: 0 means unbuffered, 1 means line buffered, any other
     positive value means use a buffer of (approximately) that size (in
     bytes).  A negative `buffering' means to use the system default,
     which is usually line buffered for tty devices and fully buffered
     for other files.  If omitted, the system default is used. (3)

     Modes `'r+'', `'w+'' and `'a+'' open the file for updating
     (reading and writing); note that `'w+'' truncates the file.
     Append `'b'' to the mode to open the file in binary mode, on
     systems that differentiate between binary and text files; on
     systems that don’t have this distinction, adding the `'b'' has
     no effect.

     In addition to the standard `fopen()' values `mode' may be `'U'' or
     `'rU''.  Python is usually built with *Note universal newlines:
     329. support; supplying `'U'' opens the file as a text file, but
     lines may be terminated by any of the following: the Unix
     end-of-line convention `'\n'',  the Macintosh convention `'\r'',
     or the Windows convention `'\r\n''. All of these external
     representations are seen as `'\n'' by the Python program.  If
     Python is built without universal newlines support a `mode' with
     `'U'' is the same as normal text mode.  Note that file objects so
     opened also have an attribute called `newlines' which has a value
     of `None' (if no newlines have yet been seen), `'\n'', `'\r'',
     `'\r\n'', or a tuple containing all the newline types seen.

     Python enforces that the mode, after stripping `'U'', begins with
     `'r'', `'w'' or `'a''.

     Python provides many file handling modules including *Note
     fileinput: cd, *Note os: 129, *Note os.path: 12a, *Note tempfile:
     173, and *Note shutil: 154.

     Changed in version 2.5: Restriction on first letter of mode string
     introduced.


 -- Function: ord (c)
     Given a string of length one, return an integer representing the
     Unicode code point of the character when the argument is a unicode
     object, or the value of the byte when the argument is an 8-bit
     string. For example, `ord('a')' returns the integer `97',
     `ord(u'\u2020')' returns `8224'.  This is the inverse of *Note
     chr(): 71e. for 8-bit strings and of *Note unichr(): 4b1. for
     unicode objects.  If a unicode argument is given and Python was
     built with UCS2 Unicode, then the character’s code point must be
     in the range [0..65535] inclusive; otherwise the string length is
     two, and a *Note TypeError: 218. will be raised.

 -- Function: pow (x, y[, z])
     Return `x' to the power `y'; if `z' is present, return `x' to the
     power `y', modulo `z' (computed more efficiently than `pow(x, y) %
     z'). The two-argument form `pow(x, y)' is equivalent to using the
     power operator: `x**y'.

     The arguments must have numeric types.  With mixed operand types,
     the coercion rules for binary arithmetic operators apply.  For int
     and long int operands, the result has the same type as the
     operands (after coercion) unless the second argument is negative;
     in that case, all arguments are converted to float and a float
     result is delivered.  For example, `10**2' returns `100', but
     `10**-2' returns `0.01'.  (This last feature was added in Python
     2.2.  In Python 2.1 and before, if both arguments were of integer
     types and the second argument was negative, an exception was
     raised.) If the second argument is negative, the third argument
     must be omitted. If `z' is present, `x' and `y' must be of integer
     types, and `y' must be non-negative.  (This restriction was added
     in Python 2.2.  In Python 2.1 and before, floating 3-argument
     `pow()' returned platform-dependent results depending on
     floating-point rounding accidents.)

 -- Function: print (*objects, sep=' ', end='\n', file=sys.stdout)
     Print `objects' to the stream `file', separated by `sep' and
     followed by `end'.  `sep', `end' and `file', if present, must be
     given as keyword arguments.

     All non-keyword arguments are converted to strings like *Note
     str(): 1ea. does and written to the stream, separated by `sep' and
     followed by `end'.  Both `sep' and `end' must be strings; they can
     also be `None', which means to use the default values.  If no
     `objects' are given, *Note print(): 31f. will just write `end'.

     The `file' argument must be an object with a `write(string)'
     method; if it is not present or `None', *Note sys.stdout: 8b2.
     will be used.  Output buffering is determined by `file'.  Use
     `file.flush()' to ensure, for instance, immediate appearance on a
     screen.

          Note: This function is not normally available as a built-in
          since the name `print' is recognized as the *Note print: 4fd.
          statement.  To disable the statement and use the *Note
          print(): 31f. function, use this future statement at the top
          of your module:

              from __future__ import print_function

     New in version 2.6.


 -- Class: property ([fget[, fset[, fdel[, doc]]]])
     Return a property attribute for *Note new-style class: 5ec.es
     (classes that derive from *Note object: 1f1.).

     `fget' is a function for getting an attribute value.  `fset' is a
     function for setting an attribute value. `fdel' is a function for
     deleting an attribute value.  And `doc' creates a docstring for
     the attribute.

     A typical use is to define a managed attribute `x':

         class C(object):
             def __init__(self):
                 self._x = None

             def getx(self):
                 return self._x

             def setx(self, value):
                 self._x = value

             def delx(self):
                 del self._x

             x = property(getx, setx, delx, "I'm the 'x' property.")

     If `c' is an instance of `C', `c.x' will invoke the getter, `c.x =
     value' will invoke the setter and `del c.x' the deleter.

     If given, `doc' will be the docstring of the property attribute.
     Otherwise, the property will copy `fget'’s docstring (if it
     exists).  This makes it possible to create read-only properties
     easily using *Note property(): 4a4. as a *Note decorator: 87e.:

         class Parrot(object):
             def __init__(self):
                 self._voltage = 100000

             @property
             def voltage(self):
                 """Get the current voltage."""
                 return self._voltage

     The `@property' decorator turns the `voltage()' method into a
     “getter” for a read-only attribute with the same name, and it
     sets the docstring for `voltage' to “Get the current voltage.”

     A property object has `getter', `setter', and `deleter' methods
     usable as decorators that create a copy of the property with the
     corresponding accessor function set to the decorated function.
     This is best explained with an example:

         class C(object):
             def __init__(self):
                 self._x = None

             @property
             def x(self):
                 """I'm the 'x' property."""
                 return self._x

             @x.setter
             def x(self, value):
                 self._x = value

             @x.deleter
             def x(self):
                 del self._x

     This code is exactly equivalent to the first example.  Be sure to
     give the additional functions the same name as the original
     property (`x' in this case.)

     The returned property object also has the attributes `fget',
     `fset', and `fdel' corresponding to the constructor arguments.

     New in version 2.2.

     Changed in version 2.5: Use `fget'’s docstring if no `doc' given.

     Changed in version 2.6: The `getter', `setter', and `deleter'
     attributes were added.


 -- Function: range (stop)
 -- Function: range (start, stop[, step])
     This is a versatile function to create lists containing arithmetic
     progressions.  It is most often used in *Note for: 303. loops.
     The arguments must be plain integers.  If the `step' argument is
     omitted, it defaults to `1'.  If the `start' argument is omitted,
     it defaults to `0'.  The full form returns a list of plain
     integers `[start, start + step, start + 2 * step, ...]'.  If `step'
     is positive, the last element is the largest `start + i * step'
     less than `stop'; if `step' is negative, the last element is the
     smallest `start + i * step' greater than `stop'.  `step' must not
     be zero (or else *Note ValueError: 236.  is raised).  Example:

         >>> range(10)
         [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
         >>> range(1, 11)
         [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
         >>> range(0, 30, 5)
         [0, 5, 10, 15, 20, 25]
         >>> range(0, 10, 3)
         [0, 3, 6, 9]
         >>> range(0, -10, -1)
         [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
         >>> range(0)
         []
         >>> range(1, 0)
         []

 -- Function: raw_input ([prompt])
     If the `prompt' argument is present, it is written to standard
     output without a trailing newline.  The function then reads a line
     from input, converts it to a string (stripping a trailing
     newline), and returns that. When EOF is read, *Note EOFError: 8b3.
     is raised. Example:

         >>> s = raw_input('--> ')
         --> Monty Python's Flying Circus
         >>> s
         "Monty Python's Flying Circus"

     If the *Note readline: 145. module was loaded, then *Note
     raw_input(): 891. will use it to provide elaborate line editing
     and history features.

 -- Function: reduce (function, iterable[, initializer])
     Apply `function' of two arguments cumulatively to the items of
     `iterable', from left to right, so as to reduce the iterable to a
     single value.  For example, `reduce(lambda x, y: x+y, [1, 2, 3, 4,
     5])' calculates `((((1+2)+3)+4)+5)'.  The left argument, `x', is
     the accumulated value and the right argument, `y', is the update
     value from the `iterable'.  If the optional `initializer' is
     present, it is placed before the items of the iterable in the
     calculation, and serves as a default when the iterable is empty.
     If `initializer' is not given and `iterable' contains only one
     item, the first item is returned.  Roughly equivalent to:

         def reduce(function, iterable, initializer=None):
             it = iter(iterable)
             if initializer is None:
                 try:
                     initializer = next(it)
                 except StopIteration:
                     raise TypeError('reduce() of empty sequence with no initial value')
             accum_value = initializer
             for x in it:
                 accum_value = function(accum_value, x)
             return accum_value

 -- Function: reload (module)
     Reload a previously imported `module'.  The argument must be a
     module object, so it must have been successfully imported before.
     This is useful if you have edited the module source file using an
     external editor and want to try out the new version without
     leaving the Python interpreter.  The return value is the module
     object (the same as the `module' argument).

     When `reload(module)' is executed:

        * Python modules’ code is recompiled and the module-level
          code reexecuted, defining a new set of objects which are
          bound to names in the module’s dictionary.  The `init'
          function of extension modules is not called a second time.

        * As with all other objects in Python the old objects are only
          reclaimed after their reference counts drop to zero.

        * The names in the module namespace are updated to point to any
          new or changed objects.

        * Other references to the old objects (such as names external
          to the module) are not rebound to refer to the new objects
          and must be updated in each namespace where they occur if
          that is desired.

     There are a number of other caveats:

     When a module is reloaded, its dictionary (containing the
     module’s global variables) is retained.  Redefinitions of names
     will override the old definitions, so this is generally not a
     problem.  If the new version of a module does not define a name
     that was defined by the old version, the old definition remains.
     This feature can be used to the module’s advantage if it
     maintains a global table or cache of objects — with a *Note try:
     3ad. statement it can test for the table’s presence and skip its
     initialization if desired:

         try:
             cache
         except NameError:
             cache = {}

     It is generally not very useful to reload built-in or dynamically
     loaded modules.  Reloading *Note sys: 16d, *Note __main__: 2,
     `builtins' and other key modules is not recommended.  In many
     cases extension modules are not designed to be initialized more
     than once, and may fail in arbitrary ways when reloaded.

     If a module imports objects from another module using *Note from:
     847. … *Note import: 1f4. …, calling *Note reload(): 595. for
     the other module does not redefine the objects imported from it
     — one way around this is to re-execute the *Note from: 847.
     statement, another is to use *Note import: 1f4. and qualified
     names (`module'.*name*) instead.

     If a module instantiates instances of a class, reloading the
     module that defines the class does not affect the method
     definitions of the instances — they continue to use the old
     class definition.  The same is true for derived classes.

 -- Function: repr (object)
     Return a string containing a printable representation of an
     object.  This is the same value yielded by conversions (reverse
     quotes).  It is sometimes useful to be able to access this
     operation as an ordinary function.  For many types, this function
     makes an attempt to return a string that would yield an object
     with the same value when passed to *Note eval(): 378, otherwise the
     representation is a string enclosed in angle brackets that
     contains the name of the type of the object together with
     additional information often including the name and address of the
     object.  A class can control what this function returns for its
     instances by defining a *Note __repr__(): 4a3. method.

 -- Function: reversed (seq)
     Return a reverse *Note iterator: 8a8.  `seq' must be an object
     which has a *Note __reversed__(): 755. method or supports the
     sequence protocol (the *Note __len__(): 423. method and the *Note
     __getitem__(): 468. method with integer arguments starting at `0').

     New in version 2.4.

     Changed in version 2.6: Added the possibility to write a custom
     *Note __reversed__(): 755. method.


 -- Function: round (number[, ndigits])
     Return the floating point value `number' rounded to `ndigits'
     digits after the decimal point.  If `ndigits' is omitted, it
     defaults to zero. The result is a floating point number.  Values
     are rounded to the closest multiple of 10 to the power minus
     `ndigits'; if two multiples are equally close, rounding is done
     away from 0 (so, for example, `round(0.5)' is `1.0' and
     `round(-0.5)' is `-1.0').

          Note: The behavior of *Note round(): 1c7. for floats can be
          surprising: for example, `round(2.675, 2)' gives `2.67'
          instead of the expected `2.68'.  This is not a bug: it’s a
          result of the fact that most decimal fractions can’t be
          represented exactly as a float.  See *Note Floating Point
          Arithmetic; Issues and Limitations: 640. for more information.

 -- Class: set ([iterable])
     Return a new *Note set: 382. object, optionally with elements
     taken from `iterable'.  `set' is a built-in class.  See *Note set:
     382. and *Note Set Types — set, frozenset: 8ad. for
     documentation about this class.

     For other containers see the built-in *Note frozenset: 383, *Note
     list: 3d6, *Note tuple: 421, and *Note dict: 319. classes, as well
     as the *Note collections: 65.  module.

     New in version 2.4.


 -- Function: setattr (object, name, value)
     This is the counterpart of *Note getattr(): 89d.  The arguments
     are an object, a string and an arbitrary value.  The string may
     name an existing attribute or a new attribute.  The function
     assigns the value to the attribute, provided the object allows it.
     For example, `setattr(x, 'foobar', 123)' is equivalent to
     `x.foobar = 123'.

 -- Class: slice (stop)
 -- Class: slice (start, stop[, step])
     Return a *Note slice: 8b4. object representing the set of indices
     specified by `range(start, stop, step)'.  The `start' and `step'
     arguments default to `None'.  Slice objects have read-only data
     attributes `start', `stop' and `step' which merely return the
     argument values (or their default).  They have no other explicit
     functionality; however they are used by Numerical Python and other
     third party extensions.  Slice objects are also generated when
     extended indexing syntax is used.  For example:
     `a[start:stop:step]' or `a[start:stop, i]'.  See *Note
     itertools.islice(): 3db. for an alternate version that returns an
     iterator.

 -- Function: sorted (iterable[, cmp[, key[, reverse]]])
     Return a new sorted list from the items in `iterable'.

     The optional arguments `cmp', `key', and `reverse' have the same
     meaning as those for the `list.sort()' method (described in section
     *Note Mutable Sequence Types: 8a6.).

     `cmp' specifies a custom comparison function of two arguments
     (iterable elements) which should return a negative, zero or
     positive number depending on whether the first argument is
     considered smaller than, equal to, or larger than the second
     argument: `cmp=lambda x,y: cmp(x.lower(), y.lower())'.  The default
     value is `None'.

     `key' specifies a function of one argument that is used to extract
     a comparison key from each list element: `key=str.lower'.  The
     default value is `None' (compare the elements directly).

     `reverse' is a boolean value.  If set to `True', then the list
     elements are sorted as if each comparison were reversed.

     In general, the `key' and `reverse' conversion processes are much
     faster than specifying an equivalent `cmp' function.  This is
     because `cmp' is called multiple times for each list element while
     `key' and `reverse' touch each element only once.  Use *Note
     functools.cmp_to_key(): 222. to convert an old-style `cmp'
     function to a `key' function.

     The built-in *Note sorted(): 223. function is guaranteed to be
     stable. A sort is stable if it guarantees not to change the
     relative order of elements that compare equal — this is helpful
     for sorting in multiple passes (for example, sort by department,
     then by salary grade).

     For sorting examples and a brief sorting tutorial, see *Note
     Sorting HOW TO: 8b5.

     New in version 2.4.


 -- Function: staticmethod (function)
     Return a static method for `function'.

     A static method does not receive an implicit first argument. To
     declare a static method, use this idiom:

         class C(object):
             @staticmethod
             def f(arg1, arg2, ...):
                 ...

     The `@staticmethod' form is a function *Note decorator: 87e. –
     see the description of function definitions in *Note Function
     definitions: 723. for details.

     It can be called either on the class (such as `C.f()') or on an
     instance (such as `C().f()').  The instance is ignored except for
     its class.

     Static methods in Python are similar to those found in Java or
     C++. Also see *Note classmethod(): 40f. for a variant that is
     useful for creating alternate class constructors.

     For more information on static methods, consult the documentation
     on the standard type hierarchy in *Note The standard type
     hierarchy: 719.

     New in version 2.2.

     Changed in version 2.4: Function decorator syntax added.


 -- Class: str (object='')
     Return a string containing a nicely printable representation of an
     object.  For strings, this returns the string itself.  The
     difference with `repr(object)' is that `str(object)' does not
     always attempt to return a string that is acceptable to *Note
     eval(): 378.; its goal is to return a printable string.  If no
     argument is given, returns the empty string, `'''.

     For more information on strings see *Note Sequence Types — str,
     unicode, list, tuple, bytearray, buffer, xrange: 53d. which
     describes sequence functionality (strings are sequences), and also
     the string-specific methods described in the *Note String Methods:
     53e. section. To output formatted strings use template strings or
     the `%' operator described in the *Note String Formatting
     Operations: 53f. section. In addition see the *Note String
     Services: 8b6.  section. See also *Note unicode(): 1f5.

 -- Function: sum (iterable[, start])
     Sums `start' and the items of an `iterable' from left to right and
     returns the total.  `start' defaults to `0'. The `iterable'’s
     items are normally numbers, and the start value is not allowed to
     be a string.

     For some use cases, there are good alternatives to *Note sum():
     43f.  The preferred, fast way to concatenate a sequence of strings
     is by calling `''.join(sequence)'.  To add floating point values
     with extended precision, see *Note math.fsum(): 361.  To
     concatenate a series of iterables, consider using *Note
     itertools.chain(): 8b7.

     New in version 2.3.


 -- Function: super (type[, object-or-type])
     Return a proxy object that delegates method calls to a parent or
     sibling class of `type'.  This is useful for accessing inherited
     methods that have been overridden in a class. The search order is
     same as that used by *Note getattr(): 89d. except that the `type'
     itself is skipped.

     The *Note __mro__: 8b8. attribute of the `type' lists the method
     resolution search order used by both *Note getattr(): 89d. and
     *Note super(): 395.  The attribute is dynamic and can change
     whenever the inheritance hierarchy is updated.

     If the second argument is omitted, the super object returned is
     unbound.  If the second argument is an object, `isinstance(obj,
     type)' must be true.  If the second argument is a type,
     `issubclass(type2, type)' must be true (this is useful for
     classmethods).

          Note: *Note super(): 395. only works for *Note new-style
          class: 5ec.es.

     There are two typical use cases for `super'.  In a class hierarchy
     with single inheritance, `super' can be used to refer to parent
     classes without naming them explicitly, thus making the code more
     maintainable.  This use closely parallels the use of `super' in
     other programming languages.

     The second use case is to support cooperative multiple inheritance
     in a dynamic execution environment.  This use case is unique to
     Python and is not found in statically compiled languages or
     languages that only support single inheritance.  This makes it
     possible to implement “diamond diagrams” where multiple base
     classes implement the same method.  Good design dictates that this
     method have the same calling signature in every case (because the
     order of calls is determined at runtime, because that order adapts
     to changes in the class hierarchy, and because that order can
     include sibling classes that are unknown prior to runtime).

     For both use cases, a typical superclass call looks like this:

         class C(B):
             def method(self, arg):
                 super(C, self).method(arg)

     Note that *Note super(): 395. is implemented as part of the
     binding process for explicit dotted attribute lookups such as
     `super().__getitem__(name)'.  It does so by implementing its own
     *Note __getattribute__(): 34f. method for searching classes in a
     predictable order that supports cooperative multiple inheritance.
     Accordingly, *Note super(): 395. is undefined for implicit lookups
     using statements or operators such as `super()[name]'.

     Also note that *Note super(): 395. is not limited to use inside
     methods.  The two argument form specifies the arguments exactly
     and makes the appropriate references.

     For practical suggestions on how to design cooperative classes
     using *Note super(): 395, see guide to using super()(4).

     New in version 2.2.


 -- Function: tuple ([iterable])
     Return a tuple whose items are the same and in the same order as
     `iterable'’s items.  `iterable' may be a sequence, a container
     that supports iteration, or an iterator object. If `iterable' is
     already a tuple, it is returned unchanged.  For instance,
     `tuple('abc')' returns `('a', 'b', 'c')' and `tuple([1, 2, 3])'
     returns `(1, 2, 3)'.  If no argument is given, returns a new empty
     tuple, `()'.

     *Note tuple: 421. is an immutable sequence type, as documented in
     *Note Sequence Types — str, unicode, list, tuple, bytearray,
     buffer, xrange: 53d. For other containers see the built in *Note
     dict: 319, *Note list: 3d6, and *Note set: 382. classes, and the
     *Note collections: 65. module.

 -- Class: type (object)
 -- Class: type (name, bases, dict)
     With one argument, return the type of an `object'.  The return
     value is a type object.  The *Note isinstance(): 332. built-in
     function is recommended for testing the type of an object.

     With three arguments, return a new type object.  This is
     essentially a dynamic form of the *Note class: 351. statement. The
     `name' string is the class name and becomes the *Note __name__:
     470. attribute; the `bases' tuple itemizes the base classes and
     becomes the *Note __bases__: 471. attribute; and the `dict'
     dictionary is the namespace containing definitions for class body
     and becomes the *Note __dict__: 4a0.  attribute.  For example, the
     following two statements create identical *Note type: 4ac. objects:

         >>> class X(object):
         ...     a = 1
         ...
         >>> X = type('X', (object,), dict(a=1))

     New in version 2.2.


 -- Function: unichr (i)
     Return the Unicode string of one character whose Unicode code is
     the integer `i'.  For example, `unichr(97)' returns the string
     `u'a''.  This is the inverse of *Note ord(): 71f. for Unicode
     strings.  The valid range for the argument depends how Python was
     configured – it may be either UCS2 [0..0xFFFF] or UCS4
     [0..0x10FFFF]. *Note ValueError: 236. is raised otherwise. For
     ASCII and 8-bit strings see *Note chr(): 71e.

     New in version 2.0.


 -- Function: unicode (object='')
 -- Function: unicode (object[, encoding[, errors]])
     Return the Unicode string version of `object' using one of the
     following modes:

     If `encoding' and/or `errors' are given, `unicode()' will decode
     the object which can either be an 8-bit string or a character
     buffer using the codec for `encoding'. The `encoding' parameter is
     a string giving the name of an encoding; if the encoding is not
     known, *Note LookupError: 8b9. is raised. Error handling is done
     according to `errors'; this specifies the treatment of characters
     which are invalid in the input encoding.  If `errors' is
     `'strict'' (the default), a *Note ValueError: 236. is raised on
     errors, while a value of `'ignore'' causes errors to be silently
     ignored, and a value of `'replace'' causes the official Unicode
     replacement character, `U+FFFD', to be used to replace input
     characters which cannot be decoded.  See also the *Note codecs:
     63. module.

     If no optional parameters are given, `unicode()' will mimic the
     behaviour of `str()' except that it returns Unicode strings
     instead of 8-bit strings. More precisely, if `object' is a Unicode
     string or subclass it will return that Unicode string without any
     additional decoding applied.

     For objects which provide a *Note __unicode__(): 1f6. method, it
     will call this method without arguments to create a Unicode
     string. For all other objects, the 8-bit string version or
     representation is requested and then converted to a Unicode string
     using the codec for the default encoding in `'strict'' mode.

     For more information on Unicode strings see *Note Sequence Types
     — str, unicode, list, tuple, bytearray, buffer, xrange: 53d.
     which describes sequence functionality (Unicode strings are
     sequences), and also the string-specific methods described in the
     *Note String Methods: 53e. section. To output formatted strings
     use template strings or the `%' operator described in the *Note
     String Formatting Operations: 53f. section. In addition see the
     *Note String Services: 8b6. section. See also *Note str(): 1ea.

     New in version 2.0.

     Changed in version 2.2: Support for *Note __unicode__(): 1f6.
     added.


 -- Function: vars ([object])
     Return the *Note __dict__: 4a0. attribute for a module, class,
     instance, or any other object with a *Note __dict__: 4a0.
     attribute.

     Objects such as modules and instances have an updateable *Note
     __dict__: 4a0.  attribute; however, other objects may have write
     restrictions on their *Note __dict__: 4a0. attributes (for
     example, new-style classes use a dictproxy to prevent direct
     dictionary updates).

     Without an argument, *Note vars(): 5b3. acts like *Note locals():
     350.  Note, the locals dictionary is only useful for reads since
     updates to the locals dictionary are ignored.

 -- Function: xrange (stop)
 -- Function: xrange (start, stop[, step])
     This function is very similar to *Note range(): 2db, but returns
     an *Note xrange object: 8ba.  instead of a list.  This is an
     opaque sequence type which yields the same values as the
     corresponding list, without actually storing them all
     simultaneously.  The advantage of *Note xrange(): 477. over *Note
     range(): 2db. is minimal (since *Note xrange(): 477. still has to
     create the values when asked for them) except when a very large
     range is used on a memory-starved machine or when all of the
     range’s elements are never used (such as when the loop is
     usually terminated with *Note break: 557.).  For more information
     on xrange objects, see *Note XRange Type: 8ba. and *Note Sequence
     Types — str, unicode, list, tuple, bytearray, buffer, xrange:
     53d.

     `CPython implementation detail:' *Note xrange(): 477. is intended
     to be simple and fast.  Implementations may impose restrictions to
     achieve this.  The C implementation of Python restricts all
     arguments to native C longs (“short” Python integers), and
     also requires that the number of elements fit in a native C long.
     If a larger range is needed, an alternate version can be crafted
     using the *Note itertools: fb. module: `islice(count(start, step),
     (stop-start+step-1+2*(step<0))//step)'.

 -- Function: zip ([iterable, ...])
     This function returns a list of tuples, where the `i'-th tuple
     contains the `i'-th element from each of the argument sequences or
     iterables. The returned list is truncated in length to the length
     of the shortest argument sequence.  When there are multiple
     arguments which are all of the same length, *Note zip(): 41e.  is
     similar to *Note map(): 318. with an initial argument of `None'.
     With a single sequence argument, it returns a list of 1-tuples.
     With no arguments, it returns an empty list.

     The left-to-right evaluation order of the iterables is guaranteed.
     This makes possible an idiom for clustering a data series into
     n-length groups using `zip(*[iter(s)]*n)'.

     *Note zip(): 41e. in conjunction with the `*' operator can be used
     to unzip a list:

         >>> x = [1, 2, 3]
         >>> y = [4, 5, 6]
         >>> zipped = zip(x, y)
         >>> zipped
         [(1, 4), (2, 5), (3, 6)]
         >>> x2, y2 = zip(*zipped)
         >>> x == list(x2) and y == list(y2)
         True

     New in version 2.0.

     Changed in version 2.4: Formerly, *Note zip(): 41e. required at
     least one argument and `zip()' raised a *Note TypeError: 218.
     instead of returning an empty list.


 -- Function: __import__ (name[, globals[, locals[, fromlist[,
          level]]]])
          Note: This is an advanced function that is not needed in
          everyday Python programming, unlike *Note
          importlib.import_module(): 272.

     This function is invoked by the *Note import: 1f4. statement.  It
     can be replaced (by importing the *Note __builtin__: 0. module and
     assigning to `__builtin__.__import__') in order to change
     semantics of the *Note import: 1f4. statement, but nowadays it is
     usually simpler to use import hooks (see PEP 302(5)).  Direct use
     of *Note __import__(): 396. is rare, except in cases where you
     want to import a module whose name is only known at runtime.

     The function imports the module `name', potentially using the
     given `globals' and `locals' to determine how to interpret the
     name in a package context.  The `fromlist' gives the names of
     objects or submodules that should be imported from the module
     given by `name'.  The standard implementation does not use its
     `locals' argument at all, and uses its `globals' only to determine
     the package context of the *Note import: 1f4. statement.

     `level' specifies whether to use absolute or relative imports.
     The default is `-1' which indicates both absolute and relative
     imports will be attempted.  `0' means only perform absolute
     imports.  Positive values for `level' indicate the number of
     parent directories to search relative to the directory of the
     module calling *Note __import__(): 396.

     When the `name' variable is of the form `package.module',
     normally, the top-level package (the name up till the first dot)
     is returned, `not' the module named by `name'.  However, when a
     non-empty `fromlist' argument is given, the module named by `name'
     is returned.

     For example, the statement `import spam' results in bytecode
     resembling the following code:

         spam = __import__('spam', globals(), locals(), [], -1)

     The statement `import spam.ham' results in this call:

         spam = __import__('spam.ham', globals(), locals(), [], -1)

     Note how *Note __import__(): 396. returns the toplevel module here
     because this is the object that is bound to a name by the *Note
     import: 1f4. statement.

     On the other hand, the statement `from spam.ham import eggs,
     sausage as saus' results in

         _temp = __import__('spam.ham', globals(), locals(), ['eggs', 'sausage'], -1)
         eggs = _temp.eggs
         saus = _temp.sausage

     Here, the `spam.ham' module is returned from *Note __import__():
     396.  From this object, the names to import are retrieved and
     assigned to their respective names.

     If you simply want to import a module (potentially within a
     package) by name, use *Note importlib.import_module(): 272.

     Changed in version 2.5: The level parameter was added.

     Changed in version 2.5: Keyword support for parameters was added.


---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0236

(2) It is used relatively rarely so does not warrant being made into a
statement.

(3) Specifying a buffer size currently has no effect on systems that
don’t have `setvbuf()'.  The interface to specify the buffer size is
not done using a method that calls `setvbuf()', because that may dump
core when called after any I/O has been performed, and there’s no
reliable way to determine whether this is the case.

(4) https://rhettinger.wordpress.com/2011/05/26/super-considered-super/

(5) https://www.python.org/dev/peps/pep-0302


File: python.info,  Node: Non-essential Built-in Functions,  Next: Built-in Constants,  Prev: Built-in Functions,  Up: The Python Standard Library

5.3 Non-essential Built-in Functions
====================================

There are several built-in functions that are no longer essential to
learn, know or use in modern Python programming.  They have been kept
here to maintain backwards compatibility with programs written for
older versions of Python.

Python programmers, trainers, students and book writers should feel
free to bypass these functions without concerns about missing something
important.

 -- Function: apply (function, args[, keywords])
     The `function' argument must be a callable object (a user-defined
     or built-in function or method, or a class object) and the `args'
     argument must be a sequence.  The `function' is called with `args'
     as the argument list; the number of arguments is the length of the
     tuple. If the optional `keywords' argument is present, it must be
     a dictionary whose keys are strings.  It specifies keyword
     arguments to be added to the end of the argument list. Calling
     *Note apply(): 317. is different from just calling
     `function(args)', since in that case there is always exactly one
     argument.  The use of *Note apply(): 317. is equivalent to
     `function(*args, **keywords)'.

     Deprecated since version 2.3: Use `function(*args, **keywords)'
     instead of `apply(function, args, keywords)' (see *Note Unpacking
     Argument Lists: 56d.).


 -- Function: buffer (object[, offset[, size]])
     The `object' argument must be an object that supports the buffer
     call interface (such as strings, arrays, and buffers).  A new
     buffer object will be created which references the `object'
     argument. The buffer object will be a slice from the beginning of
     `object' (or from the specified `offset'). The slice will extend
     to the end of `object' (or will have a length given by the `size'
     argument).

 -- Function: coerce (x, y)
     Return a tuple consisting of the two numeric arguments converted
     to a common type, using the same rules as used by arithmetic
     operations. If coercion is not possible, raise *Note TypeError:
     218.

 -- Function: intern (string)
     Enter `string' in the table of “interned” strings and return
     the interned string – which is `string' itself or a copy.
     Interning strings is useful to gain a little performance on
     dictionary lookup – if the keys in a dictionary are interned,
     and the lookup key is interned, the key comparisons (after hashing)
     can be done by a pointer compare instead of a string compare.
     Normally, the names used in Python programs are automatically
     interned, and the dictionaries used to hold module, class or
     instance attributes have interned keys.

     Changed in version 2.3: Interned strings are not immortal (like
     they used to be in Python 2.2 and before); you must keep a
     reference to the return value of *Note intern(): 8a4. around to
     benefit from it.



File: python.info,  Node: Built-in Constants,  Next: Built-in Types,  Prev: Non-essential Built-in Functions,  Up: The Python Standard Library

5.4 Built-in Constants
======================

A small number of constants live in the built-in namespace.  They are:

 -- Data: False
     The false value of the *Note bool: 455. type.

     New in version 2.3.


 -- Data: True
     The true value of the *Note bool: 455. type.

     New in version 2.3.


 -- Data: None
     The sole value of *Note types.NoneType: 8bf.  `None' is frequently
     used to represent the absence of a value, as when default
     arguments are not passed to a function.

     Changed in version 2.4: Assignments to `None' are illegal and
     raise a *Note SyntaxError: 4b4.


 -- Data: NotImplemented
     Special value which can be returned by the “rich comparison”
     special methods (*Note __eq__(): 21c, *Note __lt__(): 21d, and
     friends), to indicate that the comparison is not implemented with
     respect to the other type.

 -- Data: Ellipsis
     Special value used in conjunction with extended slicing syntax.

 -- Data: __debug__
     This constant is true if Python was not started with an *Note -O:
     46c. option.  See also the *Note assert: 46b. statement.

     Note: The names *Note None: 3b2. and *Note __debug__: 833. cannot
     be reassigned (assignments to them, even as an attribute name,
     raise *Note SyntaxError: 4b4.), so they can be considered
     “true” constants.

     Changed in version 2.7: Assignments to `__debug__' as an attribute
     became illegal.


* Menu:

* Constants added by the site module::


File: python.info,  Node: Constants added by the site module,  Up: Built-in Constants

5.4.1 Constants added by the `site' module
------------------------------------------

The *Note site: 158. module (which is imported automatically during
startup, except if the *Note -S: 66a. command-line option is given)
adds several constants to the built-in namespace.  They are useful for
the interactive interpreter shell and should not be used in programs.

 -- Data: quit ([code=None])
 -- Data: exit ([code=None])
     Objects that when printed, print a message like “Use quit() or
     Ctrl-D (i.e. EOF) to exit”, and when called, raise *Note
     SystemExit: 346. with the specified exit code.

 -- Data: copyright
 -- Data: license
 -- Data: credits
     Objects that when printed, print a message like “Type license()
     to see the full license text”, and when called, display the
     corresponding text in a pager-like fashion (one screen at a time).


File: python.info,  Node: Built-in Types,  Next: Built-in Exceptions,  Prev: Built-in Constants,  Up: The Python Standard Library

5.5 Built-in Types
==================

The following sections describe the standard types that are built into
the interpreter.

     Note: Historically (until release 2.2), Python’s built-in types
     have differed from user-defined types because it was not possible
     to use the built-in types as the basis for object-oriented
     inheritance. This limitation no longer exists.

The principal built-in types are numerics, sequences, mappings, files,
classes, instances and exceptions.

Some operations are supported by several object types; in particular,
practically all objects can be compared, tested for truth value, and
converted to a string (with the *Note repr(): 89e. function or the
slightly different *Note str(): 1ea. function).  The latter function is
implicitly used when an object is written by the *Note print(): 31f.
function.

* Menu:

* Truth Value Testing::
* Boolean Operations — and, or, not: Boolean Operations — and or not.
* Comparisons: Comparisons<2>.
* Numeric Types — int, float, long, complex: Numeric Types — int float long complex.
* Iterator Types::
* Sequence Types — str, unicode, list, tuple, bytearray, buffer, xrange: Sequence Types — str unicode list tuple bytearray buffer xrange.
* Set Types — set, frozenset: Set Types — set frozenset.
* Mapping Types — dict::
* File Objects::
* memoryview type::
* Context Manager Types::
* Other Built-in Types::
* Special Attributes::


File: python.info,  Node: Truth Value Testing,  Next: Boolean Operations — and or not,  Up: Built-in Types

5.5.1 Truth Value Testing
-------------------------

Any object can be tested for truth value, for use in an *Note if: 445.
or *Note while: 548. condition or as operand of the Boolean operations
below. The following values are considered false:

 
   * `None'

   * `False'

   * zero of any numeric type, for example, `0', `0L', `0.0', `0j'.

   * any empty sequence, for example, `''', `()', `[]'.

   * any empty mapping, for example, `{}'.

   * instances of user-defined classes, if the class defines a *Note
     __nonzero__(): 734.  or *Note __len__(): 423. method, when that
     method returns the integer zero or *Note bool: 455. value `False'.
     (1)

All other values are considered true — so objects of many types are
always true.

Operations and built-in functions that have a Boolean result always
return `0' or `False' for false and `1' or `True' for true, unless
otherwise stated.  (Important exception: the Boolean operations `or'
and `and' always return one of their operands.)

---------- Footnotes ----------

(1) Additional information on these special methods may be found in the
Python Reference Manual (*Note Basic customization: 730.).


File: python.info,  Node: Boolean Operations — and or not,  Next: Comparisons<2>,  Prev: Truth Value Testing,  Up: Built-in Types

5.5.2 Boolean Operations — `and', `or', `not'
-----------------------------------------------

These are the Boolean operations, ordered by ascending priority:

Operation         Result                                Notes
-------------------------------------------------------------------- 
`x or y'          if `x' is false, then `y', else `x'   (1)
`x and y'         if `x' is false, then `x', else `y'   (2)
`not x'           if `x' is false, then `True', else    (3)
                  `False'                               

Notes:

  1. This is a short-circuit operator, so it only evaluates the second
     argument if the first one is *Note False: 3c9.

  2. This is a short-circuit operator, so it only evaluates the second
     argument if the first one is *Note True: 3c8.

  3. `not' has a lower priority than non-Boolean operators, so `not a
     == b' is interpreted as `not (a == b)', and `a == not b' is a
     syntax error.


File: python.info,  Node: Comparisons<2>,  Next: Numeric Types — int float long complex,  Prev: Boolean Operations — and or not,  Up: Built-in Types

5.5.3 Comparisons
-----------------

Comparison operations are supported by all objects.  They all have the
same priority (which is higher than that of the Boolean operations).
Comparisons can be chained arbitrarily; for example, `x < y <= z' is
equivalent to `x < y and y <= z', except that `y' is evaluated only
once (but in both cases `z' is not evaluated at all when `x < y' is
found to be false).

This table summarizes the comparison operations:

Operation        Meaning                       Notes
----------------------------------------------------------- 
`<'              strictly less than            
`<='             less than or equal            
`>'              strictly greater than         
`>='             greater than or equal         
`=='             equal                         
`!='             not equal                     (1)
`is'             object identity               
`is not'         negated object identity       

Notes:

  1. `!=' can also be written `<>', but this is an obsolete usage kept
     for backwards compatibility only. New code should always use `!='.

Objects of different types, except different numeric types and
different string types, never compare equal; such objects are ordered
consistently but arbitrarily (so that sorting a heterogeneous array
yields a consistent result).  Furthermore, some types (for example,
file objects) support only a degenerate notion of comparison where any
two objects of that type are unequal.  Again, such objects are ordered
arbitrarily but consistently. The `<', `<=', `>' and `>=' operators
will raise a *Note TypeError: 218. exception when any operand is a
complex number.

Non-identical instances of a class normally compare as non-equal unless
the class defines the *Note __eq__(): 21c. method or the *Note
__cmp__(): 221. method.

Instances of a class cannot be ordered with respect to other instances
of the same class, or other types of object, unless the class defines
either enough of the rich comparison methods (*Note __lt__(): 21d,
*Note __le__(): 21e, *Note __gt__(): 21f, and *Note __ge__(): 220.) or
the *Note __cmp__(): 221. method.

`CPython implementation detail:' Objects of different types except
numbers are ordered by their type names; objects of the same types that
don’t support proper comparison are ordered by their address.

Two more operations with the same syntactic priority, `in' and `not
in', are supported only by sequence types (below).


File: python.info,  Node: Numeric Types — int float long complex,  Next: Iterator Types,  Prev: Comparisons<2>,  Up: Built-in Types

5.5.4 Numeric Types — `int', `float', `long', `complex'
---------------------------------------------------------

There are four distinct numeric types: `plain integers', `long
integers', `floating point numbers', and `complex numbers'. In
addition, Booleans are a subtype of plain integers. Plain integers
(also just called `integers') are implemented using `long' in C, which
gives them at least 32 bits of precision (`sys.maxint' is always set to
the maximum plain integer value for the current platform, the minimum
value is `-sys.maxint - 1').  Long integers have unlimited precision.
Floating point numbers are usually implemented using `double' in C;
information about the precision and internal representation of floating
point numbers for the machine on which your program is running is
available in *Note sys.float_info: 8d1.  Complex numbers have a real
and imaginary part, which are each a floating point number.  To extract
these parts from a complex number `z', use `z.real' and `z.imag'. (The
standard library includes additional numeric types, *Note fractions:
d7. that hold rationals, and *Note decimal: 80. that hold
floating-point numbers with user-definable precision.)

Numbers are created by numeric literals or as the result of built-in
functions and operators.  Unadorned integer literals (including binary,
hex, and octal numbers) yield plain integers unless the value they
denote is too large to be represented as a plain integer, in which case
they yield a long integer.  Integer literals with an `'L'' or `'l''
suffix yield long integers (`'L'' is preferred because `1l' looks too
much like eleven!).  Numeric literals containing a decimal point or an
exponent sign yield floating point numbers.  Appending `'j'' or `'J''
to a numeric literal yields an imaginary number (a complex number with
a zero real part) which you can add to an integer or float to get a
complex number with real and imaginary parts.

Python fully supports mixed arithmetic: when a binary arithmetic
operator has operands of different numeric types, the operand with the
“narrower” type is widened to that of the other, where plain
integer is narrower than long integer is narrower than floating point
is narrower than complex. Comparisons between numbers of mixed type use
the same rule. (1) The constructors *Note int(): 1f2, *Note long():
1f3, *Note float(): 1eb, and *Note complex(): 1ec. can be used to
produce numbers of a specific type.

All built-in numeric types support the following operations. See *Note
The power operator: 7f2. and later sections for the operators’
priorities.

Operation                Result                                Notes
---------------------------------------------------------------------------- 
`x + y'                  sum of `x' and `y'                    
`x - y'                  difference of `x' and `y'             
`x * y'                  product of `x' and `y'                
`x / y'                  quotient of `x' and `y'               (1)
`x // y'                 (floored) quotient of `x' and `y'     (4)(5)
`x % y'                  remainder of `x / y'                  (4)
`-x'                     `x' negated                           
`+x'                     `x' unchanged                         
`abs(x)'                 absolute value or magnitude of `x'    (3)
`int(x)'                 `x' converted to integer              (2)
`long(x)'                `x' converted to long integer         (2)
`float(x)'               `x' converted to floating point       (6)
`complex(re,im)'         a complex number with real part       
                         `re', imaginary part `im'.  `im'      
                         defaults to zero.                     
`c.conjugate()'          conjugate of the complex number `c'.  
                         (Identity on real numbers)            
`divmod(x, y)'           the pair `(x // y, x % y)'            (3)(4)
`pow(x, y)'              `x' to the power `y'                  (3)(7)
`x ** y'                 `x' to the power `y'                  (7)

Notes:

  1. For (plain or long) integer division, the result is an integer.
     The result is always rounded towards minus infinity: 1/2 is 0,
     (-1)/2 is -1, 1/(-2) is -1, and (-1)/(-2) is 0.  Note that the
     result is a long integer if either operand is a long integer,
     regardless of the numeric value.

  2. Conversion from floats using *Note int(): 1f2. or *Note long():
     1f3. truncates toward zero like the related function, *Note
     math.trunc(): 341.  Use the function *Note math.floor(): 33f. to
     round downward and *Note math.ceil(): 340. to round upward.

  3. See *Note Built-in Functions: 7f0. for a full description.

  4.  Deprecated since version 2.3: The floor division operator, the
     modulo operator, and the *Note divmod(): 768.  function are no
     longer defined for complex numbers.  Instead, convert to a
     floating point number using the *Note abs(): 5da. function if
     appropriate.

  5. Also referred to as integer division.  The resultant value is a
     whole integer, though the result’s type is not necessarily int.

  6. float also accepts the strings “nan” and “inf” with an
     optional prefix “+” or “-” for Not a Number (NaN) and
     positive or negative infinity.

     New in version 2.6.

  7. Python defines `pow(0, 0)' and `0 ** 0' to be `1', as is common for
     programming languages.

All *Note numbers.Real: 71c. types (*Note int: 1f2, *Note long: 1f3, and
*Note float: 1eb.) also include the following operations:

Operation                Result
--------------------------------------------------------------------------- 
*Note math.trunc(x):     `x' truncated to *Note Integral: 71b.
341.                     
*Note round(x[, n]):     `x' rounded to `n' digits, rounding ties away
1c7.                     from zero. If `n' is omitted, it defaults to 0.
*Note math.floor(x):     the greatest integer as a float <= `x'
33f.                     
*Note math.ceil(x): 340. the least integer as a float >= `x'

* Menu:

* Bitwise Operations on Integer Types::
* Additional Methods on Integer Types::
* Additional Methods on Float::

---------- Footnotes ----------

(1) As a consequence, the list `[1, 2]' is considered equal to `[1.0,
2.0]', and similarly for tuples.

