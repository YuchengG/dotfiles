This is python.info, produced by makeinfo version 4.8 from python.texi.

Generated by Sphinx 1.6.3.
INFO-DIR-SECTION Python
START-INFO-DIR-ENTRY
* Python: (python.info). The Python reference manual.
END-INFO-DIR-ENTRY

     Python 2.7.13, July 15, 2017

     Copyright (C) 1990-2017, Python Software Foundation


File: python.info,  Node: SSL Contexts,  Next: Certificates,  Prev: SSL Sockets,  Up: ssl — TLS/SSL wrapper for socket objects

5.17.3.8 SSL Contexts
.....................

New in version 2.7.9.

An SSL context holds various data longer-lived than single SSL
connections, such as SSL configuration options, certificate(s) and
private key(s).  It also manages a cache of SSL sessions for
server-side sockets, in order to speed up repeated connections from the
same clients.

 -- Class: ssl.SSLContext (protocol)
     Create a new SSL context.  You must pass `protocol' which must be
     one of the `PROTOCOL_*' constants defined in this module.  *Note
     PROTOCOL_SSLv23: 17b2. is currently recommended for maximum
     interoperability.

See also
........

     *Note create_default_context(): 17b5. lets the *Note ssl: 160.
module choose security settings for a given purpose.


*Note SSLContext: 2e5. objects have the following methods and
attributes:

 -- Method: SSLContext.cert_store_stats ()
     Get statistics about quantities of loaded X.509 certificates,
     count of X.509 certificates flagged as CA certificates and
     certificate revocation lists as dictionary.

     Example for a context with one CA cert and one other cert:

         >>> context.cert_store_stats()
         {'crl': 0, 'x509_ca': 1, 'x509': 2}

 -- Method: SSLContext.load_cert_chain (certfile, keyfile=None,
          password=None)
     Load a private key and the corresponding certificate.  The
     `certfile' string must be the path to a single file in PEM format
     containing the certificate as well as any number of CA
     certificates needed to establish the certificate’s authenticity.
     The `keyfile' string, if present, must point to a file containing
     the private key in.  Otherwise the private key will be taken from
     `certfile' as well.  See the discussion of *Note Certificates:
     17ae. for more information on how the certificate is stored in the
     `certfile'.

     The `password' argument may be a function to call to get the
     password for decrypting the private key.  It will only be called
     if the private key is encrypted and a password is necessary.  It
     will be called with no arguments, and it should return a string,
     bytes, or bytearray.  If the return value is a string it will be
     encoded as UTF-8 before using it to decrypt the key.
     Alternatively a string, bytes, or bytearray value may be supplied
     directly as the `password' argument.  It will be ignored if the
     private key is not encrypted and no password is needed.

     If the `password' argument is not specified and a password is
     required, OpenSSL’s built-in password prompting mechanism will
     be used to interactively prompt the user for a password.

     An *Note SSLError: 17a3. is raised if the private key doesn’t
     match with the certificate.

 -- Method: SSLContext.load_default_certs (purpose=Purpose.SERVER_AUTH)
     Load a set of default “certification authority” (CA)
     certificates from default locations. On Windows it loads CA certs
     from the `CA' and `ROOT' system stores. On other systems it calls
     *Note SSLContext.set_default_verify_paths(): 17c9. In the future
     the method may load CA certificates from other locations, too.

     The `purpose' flag specifies what kind of CA certificates are
     loaded. The default settings *Note Purpose.SERVER_AUTH: 17b9.
     loads certificates, that are flagged and trusted for TLS web
     server authentication (client side sockets). *Note
     Purpose.CLIENT_AUTH: 17ea. loads CA certificates for client
     certificate verification on the server side.

 -- Method: SSLContext.load_verify_locations (cafile=None, capath=None,
          cadata=None)
     Load a set of “certification authority” (CA) certificates used
     to validate other peers’ certificates when *Note verify_mode:
     17ba. is other than *Note CERT_NONE: 17af.  At least one of
     `cafile' or `capath' must be specified.

     This method can also load certification revocation lists (CRLs) in
     PEM or DER format. In order to make use of CRLs, *Note
     SSLContext.verify_flags: 17ce.  must be configured properly.

     The `cafile' string, if present, is the path to a file of
     concatenated CA certificates in PEM format. See the discussion of
     *Note Certificates: 17ae. for more information about how to
     arrange the certificates in this file.

     The `capath' string, if present, is the path to a directory
     containing several CA certificates in PEM format, following an
     OpenSSL specific layout(1).

     The `cadata' object, if present, is either an ASCII string of one
     or more PEM-encoded certificates or a bytes-like object of
     DER-encoded certificates. Like with `capath' extra lines around
     PEM-encoded certificates are ignored but at least one certificate
     must be present.

 -- Method: SSLContext.get_ca_certs (binary_form=False)
     Get a list of loaded “certification authority” (CA)
     certificates. If the `binary_form' parameter is *Note False: 3c9.
     each list entry is a dict like the output of *Note
     SSLSocket.getpeercert(): 17c2. Otherwise the method returns a list
     of DER-encoded certificates. The returned list does not contain
     certificates from `capath' unless a certificate was requested and
     loaded by a SSL connection.

 -- Method: SSLContext.set_default_verify_paths ()
     Load a set of default “certification authority” (CA)
     certificates from a filesystem path defined when building the
     OpenSSL library.  Unfortunately, there’s no easy way to know
     whether this method succeeds: no error is returned if no
     certificates are to be found.  When the OpenSSL library is
     provided as part of the operating system, though, it is likely to
     be configured properly.

 -- Method: SSLContext.set_ciphers (ciphers)
     Set the available ciphers for sockets created with this context.
     It should be a string in the OpenSSL cipher list format(2).  If no
     cipher can be selected (because compile-time options or other
     configuration forbids use of all the specified ciphers), an *Note
     SSLError: 17a3. will be raised.

          Note: when connected, the *Note SSLSocket.cipher(): 17ee.
          method of SSL sockets will give the currently selected cipher.

 -- Method: SSLContext.set_alpn_protocols (protocols)
     Specify which protocols the socket should advertise during the
     SSL/TLS handshake. It should be a list of ASCII strings, like
     `['http/1.1', 'spdy/2']', ordered by preference. The selection of
     a protocol will happen during the handshake, and will play out
     according to RFC 7301(3). After a successful handshake, the *Note
     SSLSocket.selected_alpn_protocol(): 17f0. method will return the
     agreed-upon protocol.

     This method will raise *Note NotImplementedError: 978. if *Note
     HAS_ALPN: 17e0. is False.

     OpenSSL 1.1.0+ will abort the handshake and raise *Note SSLError:
     17a3. when both sides support ALPN but cannot agree on a protocol.

     New in version 2.7.10.


 -- Method: SSLContext.set_npn_protocols (protocols)
     Specify which protocols the socket should advertise during the
     SSL/TLS handshake. It should be a list of strings, like
     `['http/1.1', 'spdy/2']', ordered by preference. The selection of
     a protocol will happen during the handshake, and will play out
     according to the NPN draft specification(4). After a successful
     handshake, the *Note SSLSocket.selected_npn_protocol(): 17f2.
     method will return the agreed-upon protocol.

     This method will raise *Note NotImplementedError: 978. if *Note
     HAS_NPN: 17e3. is False.

 -- Method: SSLContext.set_servername_callback (server_name_callback)
     Register a callback function that will be called after the TLS
     Client Hello handshake message has been received by the SSL/TLS
     server when the TLS client specifies a server name indication. The
     server name indication mechanism is specified in RFC 6066(5)
     section 3 - Server Name Indication.

     Only one callback can be set per `SSLContext'.  If
     `server_name_callback' is `None' then the callback is disabled.
     Calling this function a subsequent time will disable the
     previously registered callback.

     The callback function, `server_name_callback', will be called with
     three arguments; the first being the `ssl.SSLSocket', the second
     is a string that represents the server name that the client is
     intending to communicate (or *Note None: 3b2. if the TLS Client
     Hello does not contain a server name) and the third argument is
     the original *Note SSLContext: 2e5. The server name argument is
     the IDNA decoded server name.

     A typical use of this callback is to change the `ssl.SSLSocket'’s
     *Note SSLSocket.context: 17ed. attribute to a new object of type
     *Note SSLContext: 2e5. representing a certificate chain that
     matches the server name.

     Due to the early negotiation phase of the TLS connection, only
     limited methods and attributes are usable like *Note
     SSLSocket.selected_alpn_protocol(): 17f0. and *Note
     SSLSocket.context: 17ed.  *Note SSLSocket.getpeercert(): 17c2,
     *Note SSLSocket.getpeercert(): 17c2, *Note SSLSocket.cipher():
     17ee. and `SSLSocket.compress()' methods require that the TLS
     connection has progressed beyond the TLS Client Hello and therefore
     will not contain return meaningful values nor can they be called
     safely.

     The `server_name_callback' function must return `None' to allow the
     TLS negotiation to continue.  If a TLS failure is required, a
     constant *Note ALERT_DESCRIPTION_*: 17e8. can be returned.  Other
     return values will result in a TLS fatal error with *Note
     ALERT_DESCRIPTION_INTERNAL_ERROR: 17e8.

     If there is an IDNA decoding error on the server name, the TLS
     connection will terminate with an *Note
     ALERT_DESCRIPTION_INTERNAL_ERROR: 17e8. fatal TLS alert message to
     the client.

     If an exception is raised from the `server_name_callback' function
     the TLS connection will terminate with a fatal TLS alert message
     *Note ALERT_DESCRIPTION_HANDSHAKE_FAILURE: 17e7.

     This method will raise *Note NotImplementedError: 978. if the
     OpenSSL library had OPENSSL_NO_TLSEXT defined when it was built.

 -- Method: SSLContext.load_dh_params (dhfile)
     Load the key generation parameters for Diffie-Helman (DH) key
     exchange.  Using DH key exchange improves forward secrecy at the
     expense of computational resources (both on the server and on the
     client).  The `dhfile' parameter should be the path to a file
     containing DH parameters in PEM format.

     This setting doesn’t apply to client sockets.  You can also use
     the *Note OP_SINGLE_DH_USE: 17dd. option to further improve
     security.

 -- Method: SSLContext.set_ecdh_curve (curve_name)
     Set the curve name for Elliptic Curve-based Diffie-Hellman (ECDH)
     key exchange.  ECDH is significantly faster than regular DH while
     arguably as secure.  The `curve_name' parameter should be a string
     describing a well-known elliptic curve, for example `prime256v1'
     for a widely supported curve.

     This setting doesn’t apply to client sockets.  You can also use
     the *Note OP_SINGLE_ECDH_USE: 17de. option to further improve
     security.

     This method is not available if *Note HAS_ECDH: 17e1. is `False'.

See also
........

    SSL/TLS & Perfect Forward Secrecy(6)
          Vincent Bernat.


 -- Method: SSLContext.wrap_socket (sock, server_side=False,
          do_handshake_on_connect=True, suppress_ragged_eofs=True,
          server_hostname=None)
     Wrap an existing Python socket `sock' and return an `SSLSocket'
     object.  `sock' must be a *Note SOCK_STREAM: 1dc. socket; other
     socket types are unsupported.

     The returned SSL socket is tied to the context, its settings and
     certificates.  The parameters `server_side',
     `do_handshake_on_connect' and `suppress_ragged_eofs' have the same
     meaning as in the top-level *Note wrap_socket(): 25a. function.

     On client connections, the optional parameter `server_hostname'
     specifies the hostname of the service which we are connecting to.
     This allows a single server to host multiple SSL-based services
     with distinct certificates, quite similarly to HTTP virtual hosts.
     Specifying `server_hostname' will raise a *Note ValueError: 236.
     if `server_side' is true.

     Changed in version 2.7.9: Always allow a server_hostname to be
     passed, even if OpenSSL does not have SNI.


 -- Method: SSLContext.session_stats ()
     Get statistics about the SSL sessions created or managed by this
     context.  A dictionary is returned which maps the names of each
     piece of information(7) to their numeric values.  For example,
     here is the total number of hits and misses in the session cache
     since the context was created:

         >>> stats = context.session_stats()
         >>> stats['hits'], stats['misses']
         (0, 0)

 -- Method: SSLContext.get_ca_certs (binary_form=False)
     Returns a list of dicts with information of loaded CA certs. If the
     optional argument is true, returns a DER-encoded copy of the CA
     certificate.

          Note: Certificates in a capath directory aren’t loaded
          unless they have been used at least once.

 -- Attribute: SSLContext.check_hostname
     Wether to match the peer cert’s hostname with *Note
     match_hostname(): 17c1. in *Note SSLSocket.do_handshake(): 17b3.
     The context’s *Note verify_mode: 17ba. must be set to *Note
     CERT_OPTIONAL: 17b0. or *Note CERT_REQUIRED: 17b1, and you must
     pass `server_hostname' to *Note wrap_socket(): 17a1. in order to
     match the hostname.

     Example:

         import socket, ssl

         context = ssl.SSLContext(ssl.PROTOCOL_TLSv1)
         context.verify_mode = ssl.CERT_REQUIRED
         context.check_hostname = True
         context.load_default_certs()

         s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
         ssl_sock = context.wrap_socket(s, server_hostname='www.verisign.com')
         ssl_sock.connect(('www.verisign.com', 443))

          Note: This features requires OpenSSL 0.9.8f or newer.

 -- Attribute: SSLContext.options
     An integer representing the set of SSL options enabled on this
     context.  The default value is *Note OP_ALL: 17d8, but you can
     specify other options such as *Note OP_NO_SSLv2: 17b7. by ORing
     them together.

          Note: With versions of OpenSSL older than 0.9.8m, it is only
          possible to set options, not to clear them.  Attempting to
          clear an option (by resetting the corresponding bits) will
          raise a `ValueError'.

 -- Attribute: SSLContext.protocol
     The protocol version chosen when constructing the context.  This
     attribute is read-only.

 -- Attribute: SSLContext.verify_flags
     The flags for certificate verification operations. You can set
     flags like *Note VERIFY_CRL_CHECK_LEAF: 17cf. by ORing them
     together. By default OpenSSL does neither require nor verify
     certificate revocation lists (CRLs).  Available only with openssl
     version 0.9.8+.

 -- Attribute: SSLContext.verify_mode
     Whether to try to verify other peers’ certificates and how to
     behave if verification fails.  This attribute must be one of *Note
     CERT_NONE: 17af, *Note CERT_OPTIONAL: 17b0. or *Note
     CERT_REQUIRED: 17b1.

---------- Footnotes ----------

(1) https://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html

(2) https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT

(3) https://tools.ietf.org/html/rfc7301.html

(4) https://tools.ietf.org/html/draft-agl-tls-nextprotoneg

(5) https://tools.ietf.org/html/rfc6066.html

(6)
http://vincent.bernat.im/en/blog/2011-ssl-perfect-forward-secrecy.html

(7) https://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html


File: python.info,  Node: Certificates,  Next: Examples<8>,  Prev: SSL Contexts,  Up: ssl — TLS/SSL wrapper for socket objects

5.17.3.9 Certificates
.....................

Certificates in general are part of a public-key / private-key system.
In this system, each `principal', (which may be a machine, or a person,
or an organization) is assigned a unique two-part encryption key.  One
part of the key is public, and is called the `public key'; the other
part is kept secret, and is called the `private key'.  The two parts
are related, in that if you encrypt a message with one of the parts,
you can decrypt it with the other part, and `only' with the other part.

A certificate contains information about two principals.  It contains
the name of a `subject', and the subject’s public key.  It also
contains a statement by a second principal, the `issuer', that the
subject is who he claims to be, and that this is indeed the subject’s
public key.  The issuer’s statement is signed with the issuer’s
private key, which only the issuer knows.  However, anyone can verify
the issuer’s statement by finding the issuer’s public key,
decrypting the statement with it, and comparing it to the other
information in the certificate.  The certificate also contains
information about the time period over which it is valid.  This is
expressed as two fields, called “notBefore” and “notAfter”.

In the Python use of certificates, a client or server can use a
certificate to prove who they are.  The other side of a network
connection can also be required to produce a certificate, and that
certificate can be validated to the satisfaction of the client or
server that requires such validation.  The connection attempt can be
set to raise an exception if the validation fails.  Validation is done
automatically, by the underlying OpenSSL framework; the application
need not concern itself with its mechanics.  But the application does
usually need to provide sets of certificates to allow this process to
take place.

Python uses files to contain certificates.  They should be formatted as
“PEM” (see RFC 1422(1)), which is a base-64 encoded form wrapped
with a header line and a footer line:

    -----BEGIN CERTIFICATE-----
    ... (certificate in base64 PEM encoding) ...
    -----END CERTIFICATE-----

* Menu:

* Certificate chains::
* CA certificates::
* Combined key and certificate::
* Self-signed certificates::

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc1422.html


File: python.info,  Node: Certificate chains,  Next: CA certificates,  Up: Certificates

5.17.3.10 Certificate chains
............................

The Python files which contain certificates can contain a sequence of
certificates, sometimes called a `certificate chain'.  This chain
should start with the specific certificate for the principal who
“is” the client or server, and then the certificate for the issuer
of that certificate, and then the certificate for the issuer of `that'
certificate, and so on up the chain till you get to a certificate which
is `self-signed', that is, a certificate which has the same subject and
issuer, sometimes called a `root certificate'.  The certificates should
just be concatenated together in the certificate file.  For example,
suppose we had a three certificate chain, from our server certificate
to the certificate of the certification authority that signed our server
certificate, to the root certificate of the agency which issued the
certification authority’s certificate:

    -----BEGIN CERTIFICATE-----
    ... (certificate for your server)...
    -----END CERTIFICATE-----
    -----BEGIN CERTIFICATE-----
    ... (the certificate for the CA)...
    -----END CERTIFICATE-----
    -----BEGIN CERTIFICATE-----
    ... (the root certificate for the CA's issuer)...
    -----END CERTIFICATE-----


File: python.info,  Node: CA certificates,  Next: Combined key and certificate,  Prev: Certificate chains,  Up: Certificates

5.17.3.11 CA certificates
.........................

If you are going to require validation of the other side of the
connection’s certificate, you need to provide a “CA certs” file,
filled with the certificate chains for each issuer you are willing to
trust.  Again, this file just contains these chains concatenated
together.  For validation, Python will use the first chain it finds in
the file which matches.  The platform’s certificates file can be used
by calling *Note SSLContext.load_default_certs(): 17bb, this is done
automatically with *Note create_default_context(): 17b5.


File: python.info,  Node: Combined key and certificate,  Next: Self-signed certificates,  Prev: CA certificates,  Up: Certificates

5.17.3.12 Combined key and certificate
......................................

Often the private key is stored in the same file as the certificate; in
this case, only the `certfile' parameter to *Note
SSLContext.load_cert_chain(): 17f7.  and *Note wrap_socket(): 25a.
needs to be passed.  If the private key is stored with the certificate,
it should come before the first certificate in the certificate chain:

    -----BEGIN RSA PRIVATE KEY-----
    ... (private key in base64 encoding) ...
    -----END RSA PRIVATE KEY-----
    -----BEGIN CERTIFICATE-----
    ... (certificate in base64 PEM encoding) ...
    -----END CERTIFICATE-----


File: python.info,  Node: Self-signed certificates,  Prev: Combined key and certificate,  Up: Certificates

5.17.3.13 Self-signed certificates
..................................

If you are going to create a server that provides SSL-encrypted
connection services, you will need to acquire a certificate for that
service.  There are many ways of acquiring appropriate certificates,
such as buying one from a certification authority.  Another common
practice is to generate a self-signed certificate.  The simplest way to
do this is with the OpenSSL package, using something like the following:

    % openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout cert.pem
    Generating a 1024 bit RSA private key
    .......++++++
    .............................++++++
    writing new private key to 'cert.pem'
    -----
    You are about to be asked to enter information that will be incorporated
    into your certificate request.
    What you are about to enter is what is called a Distinguished Name or a DN.
    There are quite a few fields but you can leave some blank
    For some fields there will be a default value,
    If you enter '.', the field will be left blank.
    -----
    Country Name (2 letter code) [AU]:US
    State or Province Name (full name) [Some-State]:MyState
    Locality Name (eg, city) []:Some City
    Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Organization, Inc.
    Organizational Unit Name (eg, section) []:My Group
    Common Name (eg, YOUR name) []:myserver.mygroup.myorganization.com
    Email Address []:ops@myserver.mygroup.myorganization.com
    %

The disadvantage of a self-signed certificate is that it is its own root
certificate, and no one else will have it in their cache of known (and
trusted) root certificates.


File: python.info,  Node: Examples<8>,  Next: Notes on non-blocking sockets,  Prev: Certificates,  Up: ssl — TLS/SSL wrapper for socket objects

5.17.3.14 Examples
..................

* Menu:

* Testing for SSL support::
* Client-side operation::
* Server-side operation::


File: python.info,  Node: Testing for SSL support,  Next: Client-side operation,  Up: Examples<8>

5.17.3.15 Testing for SSL support
.................................

To test for the presence of SSL support in a Python installation, user
code should use the following idiom:

    try:
        import ssl
    except ImportError:
        pass
    else:
        ...  # do something that requires SSL support


File: python.info,  Node: Client-side operation,  Next: Server-side operation,  Prev: Testing for SSL support,  Up: Examples<8>

5.17.3.16 Client-side operation
...............................

This example creates a SSL context with the recommended security
settings for client sockets, including automatic certificate
verification:

    >>> context = ssl.create_default_context()

If you prefer to tune security settings yourself, you might create a
context from scratch (but beware that you might not get the settings
right):

    >>> context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
    >>> context.verify_mode = ssl.CERT_REQUIRED
    >>> context.check_hostname = True
    >>> context.load_verify_locations("/etc/ssl/certs/ca-bundle.crt")

(this snippet assumes your operating system places a bundle of all CA
certificates in `/etc/ssl/certs/ca-bundle.crt'; if not, you’ll get an
error and have to adjust the location)

When you use the context to connect to a server, *Note CERT_REQUIRED:
17b1.  validates the server certificate: it ensures that the server
certificate was signed with one of the CA certificates, and checks the
signature for correctness:

    >>> conn = context.wrap_socket(socket.socket(socket.AF_INET),
    ...                            server_hostname="www.python.org")
    >>> conn.connect(("www.python.org", 443))

You may then fetch the certificate:

    >>> cert = conn.getpeercert()

Visual inspection shows that the certificate does identify the desired
service (that is, the HTTPS host `www.python.org'):

    >>> pprint.pprint(cert)
    {'OCSP': ('http://ocsp.digicert.com',),
     'caIssuers': ('http://cacerts.digicert.com/DigiCertSHA2ExtendedValidationServerCA.crt',),
     'crlDistributionPoints': ('http://crl3.digicert.com/sha2-ev-server-g1.crl',
                               'http://crl4.digicert.com/sha2-ev-server-g1.crl'),
     'issuer': ((('countryName', 'US'),),
                (('organizationName', 'DigiCert Inc'),),
                (('organizationalUnitName', 'www.digicert.com'),),
                (('commonName', 'DigiCert SHA2 Extended Validation Server CA'),)),
     'notAfter': 'Sep  9 12:00:00 2016 GMT',
     'notBefore': 'Sep  5 00:00:00 2014 GMT',
     'serialNumber': '01BB6F00122B177F36CAB49CEA8B6B26',
     'subject': ((('businessCategory', 'Private Organization'),),
                 (('1.3.6.1.4.1.311.60.2.1.3', 'US'),),
                 (('1.3.6.1.4.1.311.60.2.1.2', 'Delaware'),),
                 (('serialNumber', '3359300'),),
                 (('streetAddress', '16 Allen Rd'),),
                 (('postalCode', '03894-4801'),),
                 (('countryName', 'US'),),
                 (('stateOrProvinceName', 'NH'),),
                 (('localityName', 'Wolfeboro,'),),
                 (('organizationName', 'Python Software Foundation'),),
                 (('commonName', 'www.python.org'),)),
     'subjectAltName': (('DNS', 'www.python.org'),
                        ('DNS', 'python.org'),
                        ('DNS', 'pypi.python.org'),
                        ('DNS', 'docs.python.org'),
                        ('DNS', 'testpypi.python.org'),
                        ('DNS', 'bugs.python.org'),
                        ('DNS', 'wiki.python.org'),
                        ('DNS', 'hg.python.org'),
                        ('DNS', 'mail.python.org'),
                        ('DNS', 'packaging.python.org'),
                        ('DNS', 'pythonhosted.org'),
                        ('DNS', 'www.pythonhosted.org'),
                        ('DNS', 'test.pythonhosted.org'),
                        ('DNS', 'us.pycon.org'),
                        ('DNS', 'id.python.org')),
     'version': 3}

Now the SSL channel is established and the certificate verified, you can
proceed to talk with the server:

    >>> conn.sendall(b"HEAD / HTTP/1.0\r\nHost: linuxfr.org\r\n\r\n")
    >>> pprint.pprint(conn.recv(1024).split(b"\r\n"))
    [b'HTTP/1.1 200 OK',
     b'Date: Sat, 18 Oct 2014 18:27:20 GMT',
     b'Server: nginx',
     b'Content-Type: text/html; charset=utf-8',
     b'X-Frame-Options: SAMEORIGIN',
     b'Content-Length: 45679',
     b'Accept-Ranges: bytes',
     b'Via: 1.1 varnish',
     b'Age: 2188',
     b'X-Served-By: cache-lcy1134-LCY',
     b'X-Cache: HIT',
     b'X-Cache-Hits: 11',
     b'Vary: Cookie',
     b'Strict-Transport-Security: max-age=63072000; includeSubDomains',
     b'Connection: close',
     b'',
     b'']

See the discussion of *Note Security considerations: 17a0. below.


File: python.info,  Node: Server-side operation,  Prev: Client-side operation,  Up: Examples<8>

5.17.3.17 Server-side operation
...............................

For server operation, typically you’ll need to have a server
certificate, and private key, each in a file.  You’ll first create a
context holding the key and the certificate, so that clients can check
your authenticity.  Then you’ll open a socket, bind it to a port,
call `listen()' on it, and start waiting for clients to connect:

    import socket, ssl

    context = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
    context.load_cert_chain(certfile="mycertfile", keyfile="mykeyfile")

    bindsocket = socket.socket()
    bindsocket.bind(('myaddr.mydomain.com', 10023))
    bindsocket.listen(5)

When a client connects, you’ll call `accept()' on the socket to get
the new socket from the other end, and use the context’s *Note
SSLContext.wrap_socket(): 17a1.  method to create a server-side SSL
socket for the connection:

    while True:
        newsocket, fromaddr = bindsocket.accept()
        connstream = context.wrap_socket(newsocket, server_side=True)
        try:
            deal_with_client(connstream)
        finally:
            connstream.shutdown(socket.SHUT_RDWR)
            connstream.close()

Then you’ll read data from the `connstream' and do something with it
till you are finished with the client (or the client is finished with
you):

    def deal_with_client(connstream):
        data = connstream.read()
        # null data means the client is finished with us
        while data:
            if not do_something(connstream, data):
                # we'll assume do_something returns False
                # when we're finished with client
                break
            data = connstream.read()
        # finished with client

And go back to listening for new client connections (of course, a real
server would probably handle each client connection in a separate
thread, or put the sockets in non-blocking mode and use an event loop).


File: python.info,  Node: Notes on non-blocking sockets,  Next: Security considerations,  Prev: Examples<8>,  Up: ssl — TLS/SSL wrapper for socket objects

5.17.3.18 Notes on non-blocking sockets
.......................................

When working with non-blocking sockets, there are several things you
need to be aware of:

   - Calling *Note select(): 15de. tells you that the OS-level socket
     can be read from (or written to), but it does not imply that there
     is sufficient data at the upper SSL layer.  For example, only part
     of an SSL frame might have arrived.  Therefore, you must be ready
     to handle `SSLSocket.recv()' and `SSLSocket.send()' failures, and
     retry after another call to *Note select(): 15de.

   - Conversely, since the SSL layer has its own framing, a SSL socket
     may still have data available for reading without *Note select():
     15de.  being aware of it.  Therefore, you should first call
     `SSLSocket.recv()' to drain any potentially available data, and
     then only block on a *Note select(): 15de. call if still necessary.

     (of course, similar provisions apply when using other primitives
     such as *Note poll(): 15d8, or those in the `selectors' module)

   - The SSL handshake itself will be non-blocking: the *Note
     SSLSocket.do_handshake(): 17b3. method has to be retried until it
     returns successfully.  Here is a synopsis using *Note select():
     15de. to wait for the socket’s readiness:

         while True:
             try:
                 sock.do_handshake()
                 break
             except ssl.SSLWantReadError:
                 select.select([sock], [], [])
             except ssl.SSLWantWriteError:
                 select.select([], [sock], [])


File: python.info,  Node: Security considerations,  Prev: Notes on non-blocking sockets,  Up: ssl — TLS/SSL wrapper for socket objects

5.17.3.19 Security considerations
.................................

* Menu:

* Best defaults::
* Manual settings::
* Multi-processing::


File: python.info,  Node: Best defaults,  Next: Manual settings,  Up: Security considerations

5.17.3.20 Best defaults
.......................

For `client use', if you don’t have any special requirements for your
security policy, it is highly recommended that you use the *Note
create_default_context(): 17b5. function to create your SSL context.
It will load the system’s trusted CA certificates, enable certificate
validation and hostname checking, and try to choose reasonably secure
protocol and cipher settings.

If a client certificate is needed for the connection, it can be added
with *Note SSLContext.load_cert_chain(): 17f7.

By contrast, if you create the SSL context by calling the *Note
SSLContext: 2e5.  constructor yourself, it will not have certificate
validation nor hostname checking enabled by default.  If you do so,
please read the paragraphs below to achieve a good security level.


File: python.info,  Node: Manual settings,  Next: Multi-processing,  Prev: Best defaults,  Up: Security considerations

5.17.3.21 Manual settings
.........................

* Menu:

* Verifying certificates::
* Protocol versions::
* Cipher selection::


File: python.info,  Node: Verifying certificates,  Next: Protocol versions,  Up: Manual settings

5.17.3.22 Verifying certificates
................................

When calling the *Note SSLContext: 2e5. constructor directly, *Note
CERT_NONE: 17af. is the default.  Since it does not authenticate the
other peer, it can be insecure, especially in client mode where most of
time you would like to ensure the authenticity of the server you’re
talking to.  Therefore, when in client mode, it is highly recommended
to use *Note CERT_REQUIRED: 17b1.  However, it is in itself not
sufficient; you also have to check that the server certificate, which
can be obtained by calling *Note SSLSocket.getpeercert(): 17c2, matches
the desired service.  For many protocols and applications, the service
can be identified by the hostname; in this case, the *Note
match_hostname(): 17c1. function can be used.  This common check is
automatically performed when *Note SSLContext.check_hostname: 17ec. is
enabled.

In server mode, if you want to authenticate your clients using the SSL
layer (rather than using a higher-level authentication mechanism),
you’ll also have to specify *Note CERT_REQUIRED: 17b1. and similarly
check the client certificate.

          Note: In client mode, *Note CERT_OPTIONAL: 17b0. and *Note
          CERT_REQUIRED: 17b1. are equivalent unless anonymous ciphers
          are enabled (they are disabled by default).


File: python.info,  Node: Protocol versions,  Next: Cipher selection,  Prev: Verifying certificates,  Up: Manual settings

5.17.3.23 Protocol versions
...........................

SSL versions 2 and 3 are considered insecure and are therefore
dangerous to use.  If you want maximum compatibility between clients
and servers, it is recommended to use *Note PROTOCOL_SSLv23: 17b2. as
the protocol version and then disable SSLv2 and SSLv3 explicitly using
the *Note SSLContext.options: 17fd.  attribute:

    context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
    context.options |= ssl.OP_NO_SSLv2
    context.options |= ssl.OP_NO_SSLv3

The SSL context created above will only allow TLSv1 and later (if
supported by your system) connections.


File: python.info,  Node: Cipher selection,  Prev: Protocol versions,  Up: Manual settings

5.17.3.24 Cipher selection
..........................

If you have advanced security requirements, fine-tuning of the ciphers
enabled when negotiating a SSL session is possible through the *Note
SSLContext.set_ciphers(): 17f9. method.  Starting from Python 2.7.9, the
ssl module disables certain weak ciphers by default, but you may want
to further restrict the cipher choice. Be sure to read OpenSSL’s
documentation about the cipher list format(1).  If you want to check
which ciphers are enabled by a given cipher list, use the `openssl
ciphers' command on your system.

---------- Footnotes ----------

(1) https://www.openssl.org/docs/apps/ciphers.html#CIPHER-LIST-FORMAT


File: python.info,  Node: Multi-processing,  Prev: Manual settings,  Up: Security considerations

5.17.3.25 Multi-processing
..........................

If using this module as part of a multi-processed application (using,
for example the *Note multiprocessing: 11a. or `concurrent.futures'
modules), be aware that OpenSSL’s internal random number generator
does not properly handle forked processes.  Applications must change
the PRNG state of the parent process if they use any SSL feature with
*Note os.fork(): 244.  Any successful call of *Note RAND_add(): 17bf,
`RAND_bytes()' or `RAND_pseudo_bytes()' is sufficient.

See also
........

Class *Note socket.socket: 15df.
     Documentation of underlying *Note socket: 15c. class

SSL/TLS Strong Encryption: An Introduction(1)
     Intro from the Apache webserver documentation

RFC 1422: Privacy Enhancement for Internet Electronic Mail: Part II: Certificate-Based Key Management(2)
     Steve Kent

RFC 1750: Randomness Recommendations for Security(3)
     D. Eastlake et. al.

RFC 3280: Internet X.509 Public Key Infrastructure Certificate and CRL Profile(4)
     Housley et. al.

RFC 4366: Transport Layer Security (TLS) Extensions(5)
     Blake-Wilson et. al.

RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2(6)
     T. Dierks et. al.

RFC 6066: Transport Layer Security (TLS) Extensions(7)
     D. Eastlake

IANA TLS: Transport Layer Security (TLS) Parameters(8)
     IANA

---------- Footnotes ----------

(1) https://httpd.apache.org/docs/trunk/en/ssl/ssl_intro.html

(2) https://www.ietf.org/rfc/rfc1422

(3) https://www.ietf.org/rfc/rfc1750

(4) https://www.ietf.org/rfc/rfc3280

(5) https://www.ietf.org/rfc/rfc4366

(6) https://tools.ietf.org/html/rfc5246

(7) https://tools.ietf.org/html/rfc6066

(8) https://www.iana.org/assignments/tls-parameters/tls-parameters.xml


File: python.info,  Node: signal — Set handlers for asynchronous events,  Next: popen2 — Subprocesses with accessible I/O streams,  Prev: ssl — TLS/SSL wrapper for socket objects,  Up: Interprocess Communication and Networking

5.17.4 `signal' — Set handlers for asynchronous events
--------------------------------------------------------

This module provides mechanisms to use signal handlers in Python. Some
general rules for working with signals and their handlers:

   * A handler for a particular signal, once set, remains installed
     until it is explicitly reset (Python emulates the BSD style
     interface regardless of the underlying implementation), with the
     exception of the handler for `SIGCHLD', which follows the
     underlying implementation.

   * There is no way to “block” signals temporarily from critical
     sections (since this is not supported by all Unix flavors).

   * Although Python signal handlers are called asynchronously as far
     as the Python user is concerned, they can only occur between the
     “atomic” instructions of the Python interpreter.  This means
     that signals arriving during long calculations implemented purely
     in C (such as regular expression matches on large bodies of text)
     may be delayed for an arbitrary amount of time.

   * When a signal arrives during an I/O operation, it is possible that
     the I/O operation raises an exception after the signal handler
     returns. This is dependent on the underlying Unix system’s
     semantics regarding interrupted system calls.

   * Because the C signal handler always returns, it makes little sense
     to catch synchronous errors like `SIGFPE' or `SIGSEGV'.

   * Python installs a small number of signal handlers by default:
     `SIGPIPE' is ignored (so write errors on pipes and sockets can be
     reported as ordinary Python exceptions) and `SIGINT' is translated
     into a *Note KeyboardInterrupt: 251. exception.  All of these can
     be overridden.

   * Some care must be taken if both signals and threads are used in
     the same program.  The fundamental thing to remember in using
     signals and threads simultaneously is: always perform *Note
     signal(): 155. operations in the main thread of execution.  Any
     thread can perform an *Note alarm(): 1812, *Note getsignal(): 1813,
     *Note pause(): 1814, *Note setitimer(): 1815. or *Note
     getitimer(): 1816.; only the main thread can set a new signal
     handler, and the main thread will be the only one to receive
     signals (this is enforced by the Python *Note signal: 155. module,
     even if the underlying thread implementation supports sending
     signals to individual threads).  This means that signals can’t
     be used as a means of inter-thread communication.  Use locks
     instead.

The variables defined in the *Note signal: 155. module are:

 -- Data: signal.SIG_DFL
     This is one of two standard signal handling options; it will
     simply perform the default function for the signal.  For example,
     on most systems the default action for `SIGQUIT' is to dump core
     and exit, while the default action for `SIGCHLD' is to simply
     ignore it.

 -- Data: signal.SIG_IGN
     This is another standard signal handler, which will simply ignore
     the given signal.

 -- Data: SIG*
     All the signal numbers are defined symbolically.  For example, the
     hangup signal is defined as `signal.SIGHUP'; the variable names
     are identical to the names used in C programs, as found in
     `<signal.h>'. The Unix man page for ‘`signal()'’ lists the
     existing signals (on some systems this is `signal(2)', on others
     the list is in `signal(7)'). Note that not all systems define the
     same set of signal names; only those names defined by the system
     are defined by this module.

 -- Data: signal.CTRL_C_EVENT
     The signal corresponding to the `Ctrl+C' keystroke event. This
     signal can only be used with *Note os.kill(): 2d4.

     Availability: Windows.

     New in version 2.7.


 -- Data: signal.CTRL_BREAK_EVENT
     The signal corresponding to the `Ctrl+Break' keystroke event. This
     signal can only be used with *Note os.kill(): 2d4.

     Availability: Windows.

     New in version 2.7.


 -- Data: signal.NSIG
     One more than the number of the highest signal number.

 -- Data: signal.ITIMER_REAL
     Decrements interval timer in real time, and delivers `SIGALRM'
     upon expiration.

 -- Data: signal.ITIMER_VIRTUAL
     Decrements interval timer only when the process is executing, and
     delivers SIGVTALRM upon expiration.

 -- Data: signal.ITIMER_PROF
     Decrements interval timer both when the process executes and when
     the system is executing on behalf of the process. Coupled with
     ITIMER_VIRTUAL, this timer is usually used to profile the time
     spent by the application in user and kernel space. SIGPROF is
     delivered upon expiration.

The *Note signal: 155. module defines one exception:

 -- Exception: signal.ItimerError
     Raised to signal an error from the underlying *Note setitimer():
     1815. or *Note getitimer(): 1816. implementation. Expect this
     error if an invalid interval timer or a negative time is passed to
     *Note setitimer(): 1815.  This error is a subtype of *Note
     IOError: 1fa.

The *Note signal: 155. module defines the following functions:

 -- Function: signal.alarm (time)
     If `time' is non-zero, this function requests that a `SIGALRM'
     signal be sent to the process in `time' seconds. Any previously
     scheduled alarm is canceled (only one alarm can be scheduled at
     any time).  The returned value is then the number of seconds
     before any previously set alarm was to have been delivered. If
     `time' is zero, no alarm is scheduled, and any scheduled alarm is
     canceled.  If the return value is zero, no alarm is currently
     scheduled.  (See the Unix man page `alarm(2)'.) Availability: Unix.

 -- Function: signal.getsignal (signalnum)
     Return the current signal handler for the signal `signalnum'. The
     returned value may be a callable Python object, or one of the
     special values *Note signal.SIG_IGN: 1818, *Note signal.SIG_DFL:
     1817. or *Note None: 3b2.  Here, *Note signal.SIG_IGN: 1818. means
     that the signal was previously ignored, *Note signal.SIG_DFL:
     1817. means that the default way of handling the signal was
     previously in use, and `None' means that the previous signal
     handler was not installed from Python.

 -- Function: signal.pause ()
     Cause the process to sleep until a signal is received; the
     appropriate handler will then be called.  Returns nothing.  Not on
     Windows. (See the Unix man page `signal(2)'.)

 -- Function: signal.setitimer (which, seconds[, interval])
     Sets given interval timer (one of *Note signal.ITIMER_REAL: 181a,
     *Note signal.ITIMER_VIRTUAL: 181b. or *Note signal.ITIMER_PROF:
     181c.) specified by `which' to fire after `seconds' (float is
     accepted, different from *Note alarm(): 1812.) and after that
     every `interval' seconds. The interval timer specified by `which'
     can be cleared by setting seconds to zero.

     When an interval timer fires, a signal is sent to the process.
     The signal sent is dependent on the timer being used; *Note
     signal.ITIMER_REAL: 181a. will deliver `SIGALRM', *Note
     signal.ITIMER_VIRTUAL: 181b. sends `SIGVTALRM', and *Note
     signal.ITIMER_PROF: 181c. will deliver `SIGPROF'.

     The old values are returned as a tuple: (delay, interval).

     Attempting to pass an invalid interval timer will cause an *Note
     ItimerError: 181d.  Availability: Unix.

     New in version 2.6.


 -- Function: signal.getitimer (which)
     Returns current value of a given interval timer specified by
     `which'.  Availability: Unix.

     New in version 2.6.


 -- Function: signal.set_wakeup_fd (fd)
     Set the wakeup fd to `fd'.  When a signal is received, a `'\0''
     byte is written to the fd.  This can be used by a library to
     wakeup a poll or select call, allowing the signal to be fully
     processed.

     The old wakeup fd is returned.  `fd' must be non-blocking.  It is
     up to the library to remove any bytes before calling poll or
     select again.

     When threads are enabled, this function can only be called from
     the main thread; attempting to call it from other threads will
     cause a *Note ValueError: 236.  exception to be raised.

     New in version 2.6.


 -- Function: signal.siginterrupt (signalnum, flag)
     Change system call restart behaviour: if `flag' is *Note False:
     3c9, system calls will be restarted when interrupted by signal
     `signalnum', otherwise system calls will be interrupted.  Returns
     nothing.  Availability: Unix (see the man page `siginterrupt(3)'
     for further information).

     Note that installing a signal handler with *Note signal(): 155.
     will reset the restart behaviour to interruptible by implicitly
     calling `siginterrupt()' with a true `flag' value for the given
     signal.

     New in version 2.6.


 -- Function: signal.signal (signalnum, handler)
     Set the handler for signal `signalnum' to the function `handler'.
     `handler' can be a callable Python object taking two arguments
     (see below), or one of the special values *Note signal.SIG_IGN:
     1818. or *Note signal.SIG_DFL: 1817.  The previous signal handler
     will be returned (see the description of *Note getsignal(): 1813.
     above).  (See the Unix man page `signal(2)'.)

     When threads are enabled, this function can only be called from
     the main thread; attempting to call it from other threads will
     cause a *Note ValueError: 236.  exception to be raised.

     The `handler' is called with two arguments: the signal number and
     the current stack frame (`None' or a frame object; for a
     description of frame objects, see the *Note description in the
     type hierarchy: 72a. or see the attribute descriptions in the
     *Note inspect: f9. module).

     On Windows, *Note signal(): 155. can only be called with `SIGABRT',
     `SIGFPE', `SIGILL', `SIGINT', `SIGSEGV', or `SIGTERM'. A *Note
     ValueError: 236. will be raised in any other case.

* Menu:

* Example: Example<9>.


File: python.info,  Node: Example<9>,  Up: signal — Set handlers for asynchronous events

5.17.4.1 Example
................

Here is a minimal example program. It uses the *Note alarm(): 1812.
function to limit the time spent waiting to open a file; this is useful
if the file is for a serial device that may not be turned on, which
would normally cause the *Note os.open(): 600. to hang indefinitely.
The solution is to set a 5-second alarm before opening the file; if the
operation takes too long, the alarm signal will be sent, and the
handler raises an exception.

    import signal, os

    def handler(signum, frame):
        print 'Signal handler called with signal', signum
        raise IOError("Couldn't open device!")

    # Set the signal handler and a 5-second alarm
    signal.signal(signal.SIGALRM, handler)
    signal.alarm(5)

    # This open() may hang indefinitely
    fd = os.open('/dev/ttyS0', os.O_RDWR)

    signal.alarm(0)          # Disable the alarm


File: python.info,  Node: popen2 — Subprocesses with accessible I/O streams,  Next: asyncore — Asynchronous socket handler,  Prev: signal — Set handlers for asynchronous events,  Up: Interprocess Communication and Networking

5.17.5 `popen2' — Subprocesses with accessible I/O streams
------------------------------------------------------------

Deprecated since version 2.6: This module is obsolete.  Use the *Note
subprocess: 167. module.  Check especially the *Note Replacing Older
Functions with the subprocess Module: 1135. section.

This module allows you to spawn processes and connect to their
input/output/error pipes and obtain their return codes under Unix and
Windows.

The *Note subprocess: 167. module provides more powerful facilities for
spawning new processes and retrieving their results.  Using the *Note
subprocess: 167. module is preferable to using the *Note popen2: 135.
module.

The primary interface offered by this module is a trio of factory
functions.  For each of these, if `bufsize' is specified,  it specifies
the buffer size for the I/O pipes.  `mode', if provided, should be the
string `'b'' or `'t''; on Windows this is needed to determine whether
the file objects should be opened in binary or text mode.  The default
value for `mode' is `'t''.

On Unix, `cmd' may be a sequence, in which case arguments will be passed
directly to the program without shell intervention (as with *Note
os.spawnv(): 1137.).  If `cmd' is a string it will be passed to the
shell (as with *Note os.system(): 413.).

The only way to retrieve the return codes for the child processes is by
using the `poll()' or `wait()' methods on the *Note Popen3: 1759. and
*Note Popen4: 175a. classes; these are only available on Unix.  This
information is not available when using the *Note popen2(): 135, *Note
popen3(): 1824, and *Note popen4(): 1825.  functions, or the equivalent
functions in the *Note os: 129. module. (Note that the tuples returned
by the *Note os: 129. module’s functions are in a different order
from the ones returned by the *Note popen2: 135. module.)

 -- Function: popen2.popen2 (cmd[, bufsize[, mode]])
     Executes `cmd' as a sub-process.  Returns the file objects
     `(child_stdout, child_stdin)'.

 -- Function: popen2.popen3 (cmd[, bufsize[, mode]])
     Executes `cmd' as a sub-process.  Returns the file objects
     `(child_stdout, child_stdin, child_stderr)'.

 -- Function: popen2.popen4 (cmd[, bufsize[, mode]])
     Executes `cmd' as a sub-process.  Returns the file objects
     `(child_stdout_and_stderr, child_stdin)'.

     New in version 2.0.


On Unix, a class defining the objects returned by the factory functions
is also available.  These are not used for the Windows implementation,
and are not available on that platform.

 -- Class: popen2.Popen3 (cmd[, capturestderr[, bufsize]])
     This class represents a child process.  Normally, *Note Popen3:
     1759. instances are created using the *Note popen2(): 135. and
     *Note popen3(): 1824. factory functions described above.

     If not using one of the helper functions to create *Note Popen3:
     1759. objects, the parameter `cmd' is the shell command to execute
     in a sub-process.  The `capturestderr' flag, if true, specifies
     that the object should capture standard error output of the child
     process. The default is false.  If the `bufsize' parameter is
     specified, it specifies the size of the I/O buffers to/from the
     child process.

 -- Class: popen2.Popen4 (cmd[, bufsize])
     Similar to *Note Popen3: 1759, but always captures standard error
     into the same file object as standard output.  These are typically
     created using *Note popen4(): 1825.

     New in version 2.0.


* Menu:

* Popen3 and Popen4 Objects::
* Flow Control Issues::


File: python.info,  Node: Popen3 and Popen4 Objects,  Next: Flow Control Issues,  Up: popen2 — Subprocesses with accessible I/O streams

5.17.5.1 Popen3 and Popen4 Objects
..................................

Instances of the *Note Popen3: 1759. and *Note Popen4: 175a. classes
have the following methods:

 -- Method: Popen3.poll ()
     Returns `-1' if child process hasn’t completed yet, or its
     status code (see *Note wait(): 182a.) otherwise.

 -- Method: Popen3.wait ()
     Waits for and returns the status code of the child process.  The
     status code encodes both the return code of the process and
     information about whether it exited using the `exit()' system call
     or died due to a signal.  Functions to help interpret the status
     code are defined in the *Note os: 129. module; see section *Note
     Process Management: 1190. for the `W*()' family of functions.

The following attributes are also available:

 -- Attribute: Popen3.fromchild
     A file object that provides output from the child process.  For
     *Note Popen4: 175a.  instances, this will provide both the
     standard output and standard error streams.

 -- Attribute: Popen3.tochild
     A file object that provides input to the child process.

 -- Attribute: Popen3.childerr
     A file object that provides error output from the child process, if
     `capturestderr' was true for the constructor, otherwise `None'.
     This will always be `None' for *Note Popen4: 175a. instances.

 -- Attribute: Popen3.pid
     The process ID of the child process.


File: python.info,  Node: Flow Control Issues,  Prev: Popen3 and Popen4 Objects,  Up: popen2 — Subprocesses with accessible I/O streams

5.17.5.2 Flow Control Issues
............................

Any time you are working with any form of inter-process communication,
control flow needs to be carefully thought out.  This remains the case
with the file objects provided by this module (or the *Note os: 129.
module equivalents).

When reading output from a child process that writes a lot of data to
standard error while the parent is reading from the child’s standard
output, a deadlock can occur.  A similar situation can occur with other
combinations of reads and writes.  The essential factors are that more
than `_PC_PIPE_BUF' bytes are being written by one process in a
blocking fashion, while the other process is reading from the first
process, also in a blocking fashion.

There are several ways to deal with this situation.

The simplest application change, in many cases, will be to follow this
model in the parent process:

    import popen2

    r, w, e = popen2.popen3('python slave.py')
    e.readlines()
    r.readlines()
    r.close()
    e.close()
    w.close()

with code like this in the child:

    import os
    import sys

    # note that each of these print statements
    # writes a single long string

    print >>sys.stderr, 400 * 'this is a test\n'
    os.close(sys.stderr.fileno())
    print >>sys.stdout, 400 * 'this is another test\n'

In particular, note that `sys.stderr' must be closed after writing all
data, or `readlines()' won’t return.  Also note that *Note
os.close(): 113e. must be used, as `sys.stderr.close()' won’t close
`stderr' (otherwise assigning to `sys.stderr' will silently close it,
so no further errors can be printed).

Applications which need to support a more general approach should
integrate I/O over pipes with their *Note select(): 14e. loops, or use
separate threads to read each of the individual files provided by
whichever `popen*()' function or `Popen*' class was used.

See also
........

Module *Note subprocess: 167.
     Module for spawning and managing subprocesses.


File: python.info,  Node: asyncore — Asynchronous socket handler,  Next: asynchat — Asynchronous socket command/response handler,  Prev: popen2 — Subprocesses with accessible I/O streams,  Up: Interprocess Communication and Networking

5.17.6 `asyncore' — Asynchronous socket handler
-------------------------------------------------

`Source code:' Lib/asyncore.py(1)

__________________________________________________________________

This module provides the basic infrastructure for writing asynchronous
socket service clients and servers.

There are only two ways to have a program on a single processor do
“more than one thing at a time.” Multi-threaded programming is the
simplest and most popular way to do it, but there is another very
different technique, that lets you have nearly all the advantages of
multi-threading, without actually using multiple threads.  It’s
really  only practical if your program is largely I/O bound.  If your
program is processor bound, then pre-emptive scheduled threads are
probably what you really need.  Network servers are rarely processor
bound, however.

If your operating system supports the `select()' system call in its I/O
library (and nearly all do), then you can use it to juggle multiple
communication channels at once; doing other work while your I/O is
taking place in the “background.”  Although this strategy can seem
strange and complex, especially at first, it is in many ways easier to
understand and control than multi-threaded programming.  The *Note
asyncore: 11. module solves many of the difficult problems for you,
making the task of building sophisticated high-performance network
servers and clients a snap.  For “conversational” applications and
protocols the companion *Note asynchat: 10.  module is invaluable.

The basic idea behind both modules is to create one or more network
`channels', instances of class *Note asyncore.dispatcher: 1832. and
*Note asynchat.async_chat: 1833.  Creating the channels adds them to a
global map, used by the *Note loop(): 1834. function if you do not
provide it with your own `map'.

Once the initial channel(s) is(are) created, calling the *Note loop():
1834. function activates channel service, which continues until the
last channel (including any that have been added to the map during
asynchronous service) is closed.

 -- Function: asyncore.loop ([timeout[, use_poll[, map[, count]]]])
     Enter a polling loop that terminates after count passes or all open
     channels have been closed.  All arguments are optional.  The
     `count' parameter defaults to `None', resulting in the loop
     terminating only when all channels have been closed.  The
     `timeout' argument sets the timeout parameter for the appropriate
     *Note select(): 15de. or *Note poll(): 15d8.  call, measured in
     seconds; the default is 30 seconds.  The `use_poll' parameter, if
     true, indicates that *Note poll(): 15d8. should be used in
     preference to *Note select(): 15de. (the default is `False').

     The `map' parameter is a dictionary whose items are the channels
     to watch.  As channels are closed they are deleted from their map.
     If `map' is omitted, a global map is used. Channels (instances of
     *Note asyncore.dispatcher: 1832, *Note asynchat.async_chat: 1833.
     and subclasses thereof) can freely be mixed in the map.

 -- Class: asyncore.dispatcher
     The *Note dispatcher: 1832. class is a thin wrapper around a
     low-level socket object. To make it more useful, it has a few
     methods for event-handling which are called from the asynchronous
     loop.   Otherwise, it can be treated as a normal non-blocking
     socket object.

     The firing of low-level events at certain times or in certain
     connection states tells the asynchronous loop that certain
     higher-level events have taken place.  For example, if we have
     asked for a socket to connect to another host, we know that the
     connection has been made when the socket becomes writable for the
     first time (at this point you know that you may write to it with
     the expectation of success).  The implied higher-level events are:

     Event                      Description
     ------------------------------------------------------------------------ 
     `handle_connect()'         Implied by the first read or write event
     `handle_close()'           Implied by a read event with no data
                                available
     `handle_accept()'          Implied by a read event on a listening
                                socket

     During asynchronous processing, each mapped channel’s *Note
     readable(): 1835. and *Note writable(): 1836. methods are used to
     determine whether the channel’s socket should be added to the
     list of channels `select()'ed or `poll()'ed for read and write
     events.

     Thus, the set of channel events is larger than the basic socket
     events.  The full set of methods that can be overridden in your
     subclass follows:

      -- Method: handle_read ()
          Called when the asynchronous loop detects that a `read()'
          call on the channel’s socket will succeed.

      -- Method: handle_write ()
          Called when the asynchronous loop detects that a writable
          socket can be written.  Often this method will implement the
          necessary buffering for performance.  For example:

              def handle_write(self):
                  sent = self.send(self.buffer)
                  self.buffer = self.buffer[sent:]

      -- Method: handle_expt ()
          Called when there is out of band (OOB) data for a socket
          connection.  This will almost never happen, as OOB is
          tenuously supported and rarely used.

      -- Method: handle_connect ()
          Called when the active opener’s socket actually makes a
          connection.  Might send a “welcome” banner, or initiate a
          protocol negotiation with the remote endpoint, for example.

      -- Method: handle_close ()
          Called when the socket is closed.

      -- Method: handle_error ()
          Called when an exception is raised and not otherwise handled.
          The default version prints a condensed traceback.

      -- Method: handle_accept ()
          Called on listening channels (passive openers) when a
          connection can be established with a new remote endpoint that
          has issued a *Note connect(): 183e.  call for the local
          endpoint.

      -- Method: readable ()
          Called each time around the asynchronous loop to determine
          whether a channel’s socket should be added to the list on
          which read events can occur.  The default method simply
          returns `True', indicating that by default, all channels will
          be interested in read events.

      -- Method: writable ()
          Called each time around the asynchronous loop to determine
          whether a channel’s socket should be added to the list on
          which write events can occur.  The default method simply
          returns `True', indicating that by default, all channels will
          be interested in write events.

     In addition, each channel delegates or extends many of the socket
     methods.  Most of these are nearly identical to their socket
     partners.

      -- Method: create_socket (family, type)
          This is identical to the creation of a normal socket, and
          will use the same options for creation.  Refer to the *Note
          socket: 15c. documentation for information on creating
          sockets.

      -- Method: connect (address)
          As with the normal socket object, `address' is a tuple with
          the first element the host to connect to, and the second the
          port number.

      -- Method: send (data)
          Send `data' to the remote end-point of the socket.

      -- Method: recv (buffer_size)
          Read at most `buffer_size' bytes from the socket’s remote
          end-point.  An empty string implies that the channel has been
          closed from the other end.

          Note that *Note recv(): 1841. may raise *Note socket.error:
          399. with *Note EAGAIN: 14bc. or *Note EWOULDBLOCK: 14d9,
          even though *Note select.select(): 15de. or *Note
          select.poll(): 15d8. has reported the socket ready for
          reading.

      -- Method: listen (backlog)
          Listen for connections made to the socket.  The `backlog'
          argument specifies the maximum number of queued connections
          and should be at least 1; the maximum value is
          system-dependent (usually 5).

      -- Method: bind (address)
          Bind the socket to `address'.  The socket must not already be
          bound.  (The format of `address' depends on the address
          family — refer to the *Note socket: 15c. documentation for
          more information.)  To mark the socket as re-usable (setting
          the `SO_REUSEADDR' option), call the *Note dispatcher: 1832.
          object’s `set_reuse_addr()' method.

      -- Method: accept ()
          Accept a connection.  The socket must be bound to an address
          and listening for connections.  The return value can be
          either `None' or a pair `(conn, address)' where `conn' is a
          `new' socket object usable to send and receive data on the
          connection, and `address' is the address bound to the socket
          on the other end of the connection.  When `None' is returned
          it means the connection didn’t take place, in which case
          the server should just ignore this event and keep listening
          for further incoming connections.

      -- Method: close ()
          Close the socket.  All future operations on the socket object
          will fail.  The remote end-point will receive no more data
          (after queued data is flushed).  Sockets are automatically
          closed when they are garbage-collected.

 -- Class: asyncore.dispatcher_with_send
     A *Note dispatcher: 1832. subclass which adds simple buffered
     output capability, useful for simple clients. For more
     sophisticated usage use *Note asynchat.async_chat: 1833.

 -- Class: asyncore.file_dispatcher
     A file_dispatcher takes a file descriptor or file object along
     with an optional map argument and wraps it for use with the
     `poll()' or `loop()' functions.  If provided a file object or
     anything with a `fileno()' method, that method will be called and
     passed to the *Note file_wrapper: 1848. constructor.
     Availability: UNIX.

 -- Class: asyncore.file_wrapper
     A file_wrapper takes an integer file descriptor and calls *Note
     os.dup(): 1142. to duplicate the handle so that the original
     handle may be closed independently of the file_wrapper.  This
     class implements sufficient methods to emulate a socket for use by
     the *Note file_dispatcher: 1847. class.  Availability: UNIX.

* Menu:

* asyncore Example basic HTTP client::
* asyncore Example basic echo server::

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/asyncore.py


File: python.info,  Node: asyncore Example basic HTTP client,  Next: asyncore Example basic echo server,  Up: asyncore — Asynchronous socket handler

5.17.6.1 asyncore Example basic HTTP client
...........................................

Here is a very basic HTTP client that uses the *Note dispatcher: 1832.
class to implement its socket handling:

    import asyncore, socket

    class HTTPClient(asyncore.dispatcher):

        def __init__(self, host, path):
            asyncore.dispatcher.__init__(self)
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.connect( (host, 80) )
            self.buffer = 'GET %s HTTP/1.0\r\n\r\n' % path

        def handle_connect(self):
            pass

        def handle_close(self):
            self.close()

        def handle_read(self):
            print self.recv(8192)

        def writable(self):
            return (len(self.buffer) > 0)

        def handle_write(self):
            sent = self.send(self.buffer)
            self.buffer = self.buffer[sent:]


    client = HTTPClient('www.python.org', '/')
    asyncore.loop()


File: python.info,  Node: asyncore Example basic echo server,  Prev: asyncore Example basic HTTP client,  Up: asyncore — Asynchronous socket handler

5.17.6.2 asyncore Example basic echo server
...........................................

Here is a basic echo server that uses the *Note dispatcher: 1832. class
to accept connections and dispatches the incoming connections to a
handler:

    import asyncore
    import socket

    class EchoHandler(asyncore.dispatcher_with_send):

        def handle_read(self):
            data = self.recv(8192)
            if data:
                self.send(data)

    class EchoServer(asyncore.dispatcher):

        def __init__(self, host, port):
            asyncore.dispatcher.__init__(self)
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.set_reuse_addr()
            self.bind((host, port))
            self.listen(5)

        def handle_accept(self):
            pair = self.accept()
            if pair is not None:
                sock, addr = pair
                print 'Incoming connection from %s' % repr(addr)
                handler = EchoHandler(sock)

    server = EchoServer('localhost', 8080)
    asyncore.loop()


File: python.info,  Node: asynchat — Asynchronous socket command/response handler,  Prev: asyncore — Asynchronous socket handler,  Up: Interprocess Communication and Networking

5.17.7 `asynchat' — Asynchronous socket command/response handler
------------------------------------------------------------------

`Source code:' Lib/asynchat.py(1)

__________________________________________________________________

This module builds on the *Note asyncore: 11. infrastructure,
simplifying asynchronous clients and servers and making it easier to
handle protocols whose elements are terminated by arbitrary strings, or
are of variable length.  *Note asynchat: 10. defines the abstract class
*Note async_chat: 1833. that you subclass, providing implementations of
the `collect_incoming_data()' and `found_terminator()' methods. It uses
the same asynchronous loop as *Note asyncore: 11, and the two types of
channel, *Note asyncore.dispatcher: 1832.  and *Note
asynchat.async_chat: 1833, can freely be mixed in the channel map.
Typically an *Note asyncore.dispatcher: 1832. server channel generates
new *Note asynchat.async_chat: 1833. channel objects as it receives
incoming connection requests.

 -- Class: asynchat.async_chat
     This class is an abstract subclass of *Note asyncore.dispatcher:
     1832. To make practical use of the code you must subclass *Note
     async_chat: 1833, providing meaningful *Note
     collect_incoming_data(): 184f. and *Note found_terminator(): 1850.
     methods.  The *Note asyncore.dispatcher: 1832. methods can be
     used, although not all make sense in a message/response context.

     Like *Note asyncore.dispatcher: 1832, *Note async_chat: 1833.
     defines a set of events that are generated by an analysis of
     socket conditions after a `select()' call. Once the polling loop
     has been started the *Note async_chat: 1833. object’s methods
     are called by the event-processing framework with no action on the
     part of the programmer.

     Two class attributes can be modified, to improve performance, or
     possibly even to conserve memory.

      -- Data: ac_in_buffer_size
          The asynchronous input buffer size (default `4096').

      -- Data: ac_out_buffer_size
          The asynchronous output buffer size (default `4096').

     Unlike *Note asyncore.dispatcher: 1832, *Note async_chat: 1833.
     allows you to define a first-in-first-out queue (fifo) of
     `producers'. A producer need have only one method, `more()', which
     should return data to be transmitted on the channel.  The producer
     indicates exhaustion (`i.e.' that it contains no more data) by
     having its `more()' method return the empty string. At this point
     the *Note async_chat: 1833. object removes the producer from the
     fifo and starts using the next producer, if any. When the producer
     fifo is empty the `handle_write()' method does nothing. You use
     the channel object’s *Note set_terminator(): 1853. method to
     describe how to recognize the end of, or an important breakpoint
     in, an incoming transmission from the remote endpoint.

     To build a functioning *Note async_chat: 1833. subclass your
     input methods *Note collect_incoming_data(): 184f. and *Note
     found_terminator(): 1850. must handle the data that the channel
     receives asynchronously. The methods are described below.

 -- Method: async_chat.close_when_done ()
     Pushes a `None' on to the producer fifo. When this producer is
     popped off the fifo it causes the channel to be closed.

 -- Method: async_chat.collect_incoming_data (data)
     Called with `data' holding an arbitrary amount of received data.
     The default method, which must be overridden, raises a *Note
     NotImplementedError: 978. exception.

 -- Method: async_chat.discard_buffers ()
     In emergencies this method will discard any data held in the input
     and/or output buffers and the producer fifo.

 -- Method: async_chat.found_terminator ()
     Called when the incoming data stream  matches the termination
     condition set by *Note set_terminator(): 1853. The default method,
     which must be overridden, raises a *Note NotImplementedError: 978.
     exception. The buffered input data should be available via an
     instance attribute.

 -- Method: async_chat.get_terminator ()
     Returns the current terminator for the channel.

 -- Method: async_chat.push (data)
     Pushes data on to the channel’s fifo to ensure its transmission.
     This is all you need to do to have the channel write the data out
     to the network, although it is possible to use your own producers
     in more complex schemes to implement encryption and chunking, for
     example.

 -- Method: async_chat.push_with_producer (producer)
     Takes a producer object and adds it to the producer fifo
     associated with the channel.  When all currently-pushed producers
     have been exhausted the channel will consume this producer’s
     data by calling its `more()' method and send the data to the
     remote endpoint.

 -- Method: async_chat.set_terminator (term)
     Sets the terminating condition to be recognized on the channel.
     `term' may be any of three types of value, corresponding to three
     different ways to handle incoming protocol data.

     term            Description
     ------------------------------------------------------------------ 
     `string'        Will call *Note found_terminator(): 1850. when
                     the string is found in the input stream
     `integer'       Will call *Note found_terminator(): 1850. when
                     the indicated number of characters have been
                     received
     `None'          The channel continues to collect data forever

     Note that any data following the terminator will be available for
     reading by the channel after *Note found_terminator(): 1850. is
     called.

* Menu:

* asynchat - Auxiliary Classes::
* asynchat Example::

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/asynchat.py


File: python.info,  Node: asynchat - Auxiliary Classes,  Next: asynchat Example,  Up: asynchat — Asynchronous socket command/response handler

5.17.7.1 asynchat - Auxiliary Classes
.....................................

 -- Class: asynchat.fifo ([list=None])
     A *Note fifo: 185a. holding data which has been pushed by the
     application but not yet popped for writing to the channel.  A
     *Note fifo: 185a. is a list used to hold data and/or producers
     until they are required.  If the `list' argument is provided then
     it should contain producers or data items to be written to the
     channel.

      -- Method: is_empty ()
          Returns `True' if and only if the fifo is empty.

      -- Method: first ()
          Returns the least-recently *Note push(): 185d.ed item from
          the fifo.

      -- Method: push (data)
          Adds the given data (which may be a string or a producer
          object) to the producer fifo.

      -- Method: pop ()
          If the fifo is not empty, returns `True, first()', deleting
          the popped item.  Returns `False, None' for an empty fifo.


File: python.info,  Node: asynchat Example,  Prev: asynchat - Auxiliary Classes,  Up: asynchat — Asynchronous socket command/response handler

5.17.7.2 asynchat Example
.........................

The following partial example shows how HTTP requests can be read with
*Note async_chat: 1833.  A web server might create an
`http_request_handler' object for each incoming client connection.
Notice that initially the channel terminator is set to match the blank
line at the end of the HTTP headers, and a flag indicates that the
headers are being read.

Once the headers have been read, if the request is of type POST
(indicating that further data are present in the input stream) then the
`Content-Length:' header is used to set a numeric terminator to read the
right amount of data from the channel.

The `handle_request()' method is called once all relevant input has been
marshalled, after setting the channel terminator to `None' to ensure
that any extraneous data sent by the web client are ignored.

    class http_request_handler(asynchat.async_chat):

        def __init__(self, sock, addr, sessions, log):
            asynchat.async_chat.__init__(self, sock=sock)
            self.addr = addr
            self.sessions = sessions
            self.ibuffer = []
            self.obuffer = ""
            self.set_terminator("\r\n\r\n")
            self.reading_headers = True
            self.handling = False
            self.cgi_data = None
            self.log = log

        def collect_incoming_data(self, data):
            """Buffer the data"""
            self.ibuffer.append(data)

        def found_terminator(self):
            if self.reading_headers:
                self.reading_headers = False
                self.parse_headers("".join(self.ibuffer))
                self.ibuffer = []
                if self.op.upper() == "POST":
                    clen = self.headers.getheader("content-length")
                    self.set_terminator(int(clen))
                else:
                    self.handling = True
                    self.set_terminator(None)
                    self.handle_request()
            elif not self.handling:
                self.set_terminator(None)  # browsers sometimes over-send
                self.cgi_data = parse(self.headers, "".join(self.ibuffer))
                self.handling = True
                self.ibuffer = []
                self.handle_request()


File: python.info,  Node: Internet Data Handling,  Next: Structured Markup Processing Tools,  Prev: Interprocess Communication and Networking,  Up: The Python Standard Library

5.18 Internet Data Handling
===========================

This chapter describes modules which support handling data formats
commonly used on the Internet.

* Menu:

* email — An email and MIME handling package::
* json — JSON encoder and decoder::
* mailcap — Mailcap file handling::
* mailbox — Manipulate mailboxes in various formats::
* mhlib — Access to MH mailboxes::
* mimetools — Tools for parsing MIME messages::
* mimetypes — Map filenames to MIME types::
* MimeWriter — Generic MIME file writer::
* mimify — MIME processing of mail messages::
* multifile — Support for files containing distinct parts::
* rfc822 — Parse RFC 2822 mail headers::
* base64 — RFC 3548; Base16, Base32, Base64 Data Encodings: base64 — RFC 3548 Base16 Base32 Base64 Data Encodings.
* binhex — Encode and decode binhex4 files::
* binascii — Convert between binary and ASCII::
* quopri — Encode and decode MIME quoted-printable data::
* uu — Encode and decode uuencode files::


File: python.info,  Node: email — An email and MIME handling package,  Next: json — JSON encoder and decoder,  Up: Internet Data Handling

5.18.1 `email' — An email and MIME handling package
-----------------------------------------------------

New in version 2.2.

The *Note email: bb. package is a library for managing email messages,
including MIME and other RFC 2822(1)-based message documents.  It
subsumes most of the functionality in several older standard modules
such as *Note rfc822: 148, *Note mimetools: 110, *Note multifile: 119,
and other non-standard packages such as `mimecntl'.  It is specifically
`not' designed to do any sending of email messages to SMTP ( RFC
2821(2)), NNTP, or other servers; those are functions of modules such
as *Note smtplib: 15a. and *Note nntplib: 125. The *Note email: bb.
package attempts to be as RFC-compliant as possible, supporting in
addition to RFC 2822(3), such MIME-related RFCs as RFC 2045(4), RFC
2046(5), RFC 2047(6), and RFC 2231(7).

The primary distinguishing feature of the *Note email: bb. package is
that it splits the parsing and generating of email messages from the
internal `object model' representation of email.  Applications using
the *Note email: bb. package deal primarily with objects; you can add
sub-objects to messages, remove sub-objects from messages, completely
re-arrange the contents, etc.  There is a separate parser and a
separate generator which handles the transformation from flat text to
the object model, and then back to flat text again.  There are also
handy subclasses for some common MIME object types, and a few
miscellaneous utilities that help with such common tasks as extracting
and parsing message field values, creating RFC-compliant dates, etc.

The following sections describe the functionality of the *Note email:
bb. package.  The ordering follows a progression that should be common
in applications: an email message is read as flat text from a file or
other source, the text is parsed to produce the object structure of the
email message, this structure is manipulated, and finally, the object
tree is rendered back into flat text.

It is perfectly feasible to create the object structure out of whole
cloth — i.e. completely from scratch.  From there, a similar
progression can be taken as above.

Also included are detailed specifications of all the classes and
modules that the *Note email: bb. package provides, the exception
classes you might encounter while using the *Note email: bb. package,
some auxiliary utilities, and a few examples.  For users of the older
`mimelib' package, or previous versions of the *Note email: bb.
package, a section on differences and porting is provided.

Contents of the *Note email: bb. package documentation:

* Menu:

* email.message; Representing an email message: email message Representing an email message.
* email.parser; Parsing email messages: email parser Parsing email messages.
* email.generator; Generating MIME documents: email generator Generating MIME documents.
* email.mime; Creating email and MIME objects from scratch: email mime Creating email and MIME objects from scratch.
* email.header; Internationalized headers: email header Internationalized headers.
* email.charset; Representing character sets: email charset Representing character sets.
* email.encoders; Encoders: email encoders Encoders.
* email.errors; Exception and Defect classes: email errors Exception and Defect classes.
* email.utils; Miscellaneous utilities: email utils Miscellaneous utilities.
* email.iterators; Iterators: email iterators Iterators.
* email; Examples: email Examples.
* Package History::
* Differences from mimelib::

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2822.html

(2) https://tools.ietf.org/html/rfc2821.html

(3) https://tools.ietf.org/html/rfc2822.html

(4) https://tools.ietf.org/html/rfc2045.html

(5) https://tools.ietf.org/html/rfc2046.html

(6) https://tools.ietf.org/html/rfc2047.html

(7) https://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: email message Representing an email message,  Next: email parser Parsing email messages,  Up: email — An email and MIME handling package

5.18.1.1 `email.message': Representing an email message
.......................................................

The central class in the *Note email: bb. package is the *Note Message:
216. class, imported from the *Note email.message: c2. module.  It is
the base class for the *Note email: bb. object model.  *Note Message:
216. provides the core functionality for setting and querying header
fields, and for accessing message bodies.

Conceptually, a *Note Message: 216. object consists of `headers' and
`payloads'.  Headers are RFC 2822(1) style field names and values where
the field name and value are separated by a colon.  The colon is not
part of either the field name or the field value.

Headers are stored and returned in case-preserving form but are matched
case-insensitively.  There may also be a single envelope header, also
known as the `Unix-From' header or the `From_' header.  The payload is
either a string in the case of simple message objects or a list of
*Note Message: 216. objects for MIME container documents (e.g.
`multipart/*' and `message/rfc822').

*Note Message: 216. objects provide a mapping style interface for
accessing the message headers, and an explicit interface for accessing
both the headers and the payload.  It provides convenience methods for
generating a flat text representation of the message object tree, for
accessing commonly used header parameters, and for recursively walking
over the object tree.

Here are the methods of the *Note Message: 216. class:

 -- Class: email.message.Message
     The constructor takes no arguments.

      -- Method: as_string ([unixfrom])
          Return the entire message flattened as a string.  When
          optional `unixfrom' is `True', the envelope header is
          included in the returned string.  `unixfrom' defaults to
          `False'.  Flattening the message may trigger changes to the
          *Note Message: 216. if defaults need to be filled in to
          complete the transformation to a string (for example, MIME
          boundaries may be generated or modified).

          Note that this method is provided as a convenience and may
          not always format the message the way you want.  For example,
          by default it mangles lines that begin with `From'.  For more
          flexibility, instantiate a *Note Generator: 1869. instance
          and use its *Note flatten(): 186a. method directly.  For
          example:

              from cStringIO import StringIO
              from email.generator import Generator
              fp = StringIO()
              g = Generator(fp, mangle_from_=False, maxheaderlen=60)
              g.flatten(msg)
              text = fp.getvalue()

      -- Method: __str__ ()
          Equivalent to `as_string(unixfrom=True)'.

      -- Method: is_multipart ()
          Return `True' if the message’s payload is a list of
          sub-*Note Message: 216. objects, otherwise return `False'.
          When *Note is_multipart(): 186c. returns `False', the payload
          should be a string object.

      -- Method: set_unixfrom (unixfrom)
          Set the message’s envelope header to `unixfrom', which
          should be a string.

      -- Method: get_unixfrom ()
          Return the message’s envelope header.  Defaults to `None'
          if the envelope header was never set.

      -- Method: attach (payload)
          Add the given `payload' to the current payload, which must be
          `None' or a list of *Note Message: 216. objects before the
          call. After the call, the payload will always be a list of
          *Note Message: 216. objects.  If you want to set the payload
          to a scalar object (e.g. a string), use *Note set_payload():
          1870. instead.

      -- Method: get_payload ([i[, decode]])
          Return the current payload, which will be a list of *Note
          Message: 216. objects when *Note is_multipart(): 186c. is
          `True', or a string when *Note is_multipart(): 186c. is
          `False'.  If the payload is a list and you mutate the list
          object, you modify the message’s payload in place.

          With optional argument `i', *Note get_payload(): 1871. will
          return the `i'-th element of the payload, counting from zero,
          if *Note is_multipart(): 186c. is `True'.  An *Note
          IndexError: 4fe. will be raised if `i' is less than 0 or
          greater than or equal to the number of items in the payload.
          If the payload is a string (i.e.  *Note is_multipart(): 186c.
          is `False') and `i' is given, a *Note TypeError: 218. is
          raised.

          Optional `decode' is a flag indicating whether the payload
          should be decoded or not, according to the
          `Content-Transfer-Encoding' header. When `True' and the
          message is not a multipart, the payload will be decoded if
          this header’s value is `quoted-printable' or `base64'.  If
          some other encoding is used, or `Content-Transfer-Encoding'
          header is missing, or if the payload has bogus base64 data,
          the payload is returned as-is (undecoded).  If the message is
          a multipart and the `decode' flag is `True', then `None' is
          returned.  The default for `decode' is `False'.

      -- Method: set_payload (payload[, charset])
          Set the entire message object’s payload to `payload'.  It
          is the client’s responsibility to ensure the payload
          invariants.  Optional `charset' sets the message’s default
          character set; see *Note set_charset(): 1872. for details.

          Changed in version 2.2.2: `charset' argument added.


      -- Method: set_charset (charset)
          Set the character set of the payload to `charset', which can
          either be a *Note Charset: 1873. instance (see *Note
          email.charset: bc.), a string naming a character set, or
          `None'.  If it is a string, it will be converted to a *Note
          Charset: 1873. instance.  If `charset' is `None', the
          `charset' parameter will be removed from the `Content-Type'
          header (the message will not be otherwise modified).
          Anything else will generate a *Note TypeError: 218.

          If there is no existing `MIME-Version' header one will be
          added.  If there is no existing `Content-Type' header, one
          will be added with a value of `text/plain'.  Whether the
          `Content-Type' header already exists or not, its `charset'
          parameter will be set to `charset.output_charset'.   If
          `charset.input_charset' and `charset.output_charset' differ,
          the payload will be re-encoded to the `output_charset'.  If
          there is no existing `Content-Transfer-Encoding' header, then
          the payload will be transfer-encoded, if needed, using the
          specified *Note Charset: 1873, and a header with the
          appropriate value will be added.  If a
          `Content-Transfer-Encoding' header already exists, the
          payload is assumed to already be correctly encoded using that
          `Content-Transfer-Encoding' and is not modified.

          The message will be assumed to be of type `text/*', with the
          payload either in unicode or encoded with
          `charset.input_charset'.  It will be encoded or converted to
          `charset.output_charset' and transfer encoded properly, if
          needed, when generating the plain text representation of the
          message.  MIME headers (`MIME-Version', `Content-Type',
          `Content-Transfer-Encoding') will be added as needed.

          New in version 2.2.2.


      -- Method: get_charset ()
          Return the *Note Charset: 1873. instance associated with the
          message’s payload.

          New in version 2.2.2.


     The following methods implement a mapping-like interface for
     accessing the message’s RFC 2822(2) headers.  Note that there
     are some semantic differences between these methods and a normal
     mapping (i.e. dictionary) interface.  For example, in a dictionary
     there are no duplicate keys, but here there may be duplicate
     message headers.  Also, in dictionaries there is no guaranteed
     order to the keys returned by *Note keys(): 1875, but in a *Note
     Message: 216. object, headers are always returned in the order
     they appeared in the original message, or were added to the
     message later.  Any header deleted and then re-added are always
     appended to the end of the header list.

     These semantic differences are intentional and are biased toward
     maximal convenience.

     Note that in all cases, any envelope header present in the message
     is not included in the mapping interface.

      -- Method: __len__ ()
          Return the total number of headers, including duplicates.

      -- Method: __contains__ (name)
          Return true if the message object has a field named `name'.
          Matching is done case-insensitively and `name' should not
          include the trailing colon.  Used for the `in' operator, e.g.:

              if 'message-id' in myMessage:
                  print 'Message-ID:', myMessage['message-id']

      -- Method: __getitem__ (name)
          Return the value of the named header field.  `name' should
          not include the colon field separator.  If the header is
          missing, `None' is returned; a *Note KeyError: 205. is never
          raised.

          Note that if the named field appears more than once in the
          message’s headers, exactly which of those field values will
          be returned is undefined.  Use the *Note get_all(): 1879.
          method to get the values of all the extant named headers.

      -- Method: __setitem__ (name, val)
          Add a header to the message with field name `name' and value
          `val'.  The field is appended to the end of the message’s
          existing fields.

          Note that this does `not' overwrite or delete any existing
          header with the same name.  If you want to ensure that the
          new header is the only one present in the message with field
          name `name', delete the field first, e.g.:

              del msg['subject']
              msg['subject'] = 'Python roolz!'

      -- Method: __delitem__ (name)
          Delete all occurrences of the field with name `name' from the
          message’s headers.  No exception is raised if the named
          field isn’t present in the headers.

      -- Method: has_key (name)
          Return true if the message contains a header field named
          `name', otherwise return false.

      -- Method: keys ()
          Return a list of all the message’s header field names.

      -- Method: values ()
          Return a list of all the message’s field values.

      -- Method: items ()
          Return a list of 2-tuples containing all the message’s
          field headers and values.

      -- Method: get (name[, failobj])
          Return the value of the named header field.  This is
          identical to *Note __getitem__(): 1878. except that optional
          `failobj' is returned if the named header is missing
          (defaults to `None').

     Here are some additional useful methods:

      -- Method: get_all (name[, failobj])
          Return a list of all the values for the field named `name'.
          If there are no such named headers in the message, `failobj'
          is returned (defaults to `None').

      -- Method: add_header (_name, _value, **_params)
          Extended header setting.  This method is similar to *Note
          __setitem__(): 187a.  except that additional header
          parameters can be provided as keyword arguments.  `_name' is
          the header field to add and `_value' is the `primary' value
          for the header.

          For each item in the keyword argument dictionary `_params',
          the key is taken as the parameter name, with underscores
          converted to dashes (since dashes are illegal in Python
          identifiers).  Normally, the parameter will be added as
          `key="value"' unless the value is `None', in which case only
          the key will be added.  If the value contains non-ASCII
          characters, it must be specified as a three tuple in the
          format `(CHARSET, LANGUAGE, VALUE)', where `CHARSET' is a
          string naming the charset to be used to encode the value,
          `LANGUAGE' can usually be set to `None' or the empty string
          (see RFC 2231(3) for other possibilities), and `VALUE' is the
          string value containing non-ASCII code points.

          Here’s an example:

              msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')

          This will add a header that looks like

              Content-Disposition: attachment; filename="bud.gif"

          An example with non-ASCII characters:

              msg.add_header('Content-Disposition', 'attachment',
                             filename=('iso-8859-1', '', 'Fußballer.ppt'))

          Which produces

              Content-Disposition: attachment; filename*="iso-8859-1''Fu%DFballer.ppt"

      -- Method: replace_header (_name, _value)
          Replace a header.  Replace the first header found in the
          message that matches `_name', retaining header order and
          field name case.  If no matching header was found, a *Note
          KeyError: 205. is raised.

          New in version 2.2.2.


      -- Method: get_content_type ()
          Return the message’s content type.  The returned string is
          coerced to lower case of the form `maintype/subtype'.  If
          there was no `Content-Type' header in the message the default
          type as given by *Note get_default_type(): 1883. will be
          returned.  Since according to RFC 2045(4), messages always
          have a default type, *Note get_content_type(): 1882.  will
          always return a value.

          RFC 2045(5) defines a message’s default type to be
          `text/plain' unless it appears inside a `multipart/digest'
          container, in which case it would be `message/rfc822'.  If the
          `Content-Type' header has an invalid type specification, RFC
          2045(6) mandates that the default type be `text/plain'.

          New in version 2.2.2.


      -- Method: get_content_maintype ()
          Return the message’s main content type.  This is the
          `maintype' part of the string returned by *Note
          get_content_type(): 1882.

          New in version 2.2.2.


      -- Method: get_content_subtype ()
          Return the message’s sub-content type.  This is the
          `subtype' part of the string returned by *Note
          get_content_type(): 1882.

          New in version 2.2.2.


      -- Method: get_default_type ()
          Return the default content type.  Most messages have a
          default content type of `text/plain', except for messages
          that are subparts of `multipart/digest' containers.  Such
          subparts have a default content type of `message/rfc822'.

          New in version 2.2.2.


      -- Method: set_default_type (ctype)
          Set the default content type.  `ctype' should either be
          `text/plain' or `message/rfc822', although this is not
          enforced.  The default content type is not stored in the
          `Content-Type' header.

          New in version 2.2.2.


      -- Method: get_params ([failobj[, header[, unquote]]])
          Return the message’s `Content-Type' parameters, as a list.
          The elements of the returned list are 2-tuples of key/value
          pairs, as split on the `'='' sign.  The left hand side of the
          `'='' is the key, while the right hand side is the value.  If
          there is no `'='' sign in the parameter the value is the
          empty string, otherwise the value is as described in *Note
          get_param(): 1888. and is unquoted if optional `unquote' is
          `True' (the default).

          Optional `failobj' is the object to return if there is no
          `Content-Type' header.  Optional `header' is the header to
          search instead of `Content-Type'.

          Changed in version 2.2.2: `unquote' argument added.


      -- Method: get_param (param[, failobj[, header[, unquote]]])
          Return the value of the `Content-Type' header’s parameter
          `param' as a string.  If the message has no `Content-Type'
          header or if there is no such parameter, then `failobj' is
          returned (defaults to `None').

          Optional `header' if given, specifies the message header to
          use instead of `Content-Type'.

          Parameter keys are always compared case insensitively.  The
          return value can either be a string, or a 3-tuple if the
          parameter was RFC 2231(7) encoded.  When it’s a 3-tuple,
          the elements of the value are of the form `(CHARSET,
          LANGUAGE, VALUE)'.  Note that both `CHARSET' and `LANGUAGE'
          can be `None', in which case you should consider `VALUE' to
          be encoded in the `us-ascii' charset.  You can usually ignore
          `LANGUAGE'.

          If your application doesn’t care whether the parameter was
          encoded as in RFC 2231(8), you can collapse the parameter
          value by calling *Note email.utils.collapse_rfc2231_value():
          1889, passing in the return value from *Note get_param():
          1888.  This will return a suitably decoded Unicode string
          when the value is a tuple, or the original string unquoted if
          it isn’t.  For example:

              rawparam = msg.get_param('foo')
              param = email.utils.collapse_rfc2231_value(rawparam)

          In any case, the parameter value (either the returned string,
          or the `VALUE' item in the 3-tuple) is always unquoted,
          unless `unquote' is set to `False'.

          Changed in version 2.2.2: `unquote' argument added, and
          3-tuple return value possible.


      -- Method: set_param (param, value[, header[, requote[, charset[,
               language]]]])
          Set a parameter in the `Content-Type' header.  If the
          parameter already exists in the header, its value will be
          replaced with `value'.  If the `Content-Type' header as not
          yet been defined for this message, it will be set to
          `text/plain' and the new parameter value will be appended as
          per RFC 2045(9).

          Optional `header' specifies an alternative header to
          `Content-Type', and all parameters will be quoted as necessary
          unless optional `requote' is `False' (the default is `True').

          If optional `charset' is specified, the parameter will be
          encoded according to RFC 2231(10). Optional `language'
          specifies the RFC 2231 language, defaulting to the empty
          string.  Both `charset' and `language' should be strings.

          New in version 2.2.2.


      -- Method: del_param (param[, header[, requote]])
          Remove the given parameter completely from the `Content-Type'
          header.  The header will be re-written in place without the
          parameter or its value.  All values will be quoted as
          necessary unless `requote' is `False' (the default is
          `True').  Optional `header' specifies an alternative to
          `Content-Type'.

          New in version 2.2.2.


      -- Method: set_type (type[, header][, requote])
          Set the main type and subtype for the `Content-Type' header.
          `type' must be a string in the form `maintype/subtype',
          otherwise a *Note ValueError: 236. is raised.

          This method replaces the `Content-Type' header, keeping all
          the parameters in place.  If `requote' is `False', this
          leaves the existing header’s quoting as is, otherwise the
          parameters will be quoted (the default).

          An alternative header can be specified in the `header'
          argument. When the `Content-Type' header is set a
          `MIME-Version' header is also added.

          New in version 2.2.2.


      -- Method: get_filename ([failobj])
          Return the value of the `filename' parameter of the
          `Content-Disposition' header of the message.  If the header
          does not have a `filename' parameter, this method falls back
          to looking for the `name' parameter on the `Content-Type'
          header.  If neither is found, or the header is missing, then
          `failobj' is returned.  The returned string will always be
          unquoted as per *Note email.utils.unquote(): 188e.

      -- Method: get_boundary ([failobj])
          Return the value of the `boundary' parameter of the
          `Content-Type' header of the message, or `failobj' if either
          the header is missing, or has no `boundary' parameter.  The
          returned string will always be unquoted as per *Note
          email.utils.unquote(): 188e.

      -- Method: set_boundary (boundary)
          Set the `boundary' parameter of the `Content-Type' header to
          `boundary'.  *Note set_boundary(): 1890. will always quote
          `boundary' if necessary.  A *Note HeaderParseError: 1891. is
          raised if the message object has no `Content-Type' header.

          Note that using this method is subtly different than deleting
          the old `Content-Type' header and adding a new one with the
          new boundary via *Note add_header(): 1880, because *Note
          set_boundary(): 1890. preserves the order of the
          `Content-Type' header in the list of headers. However, it
          does `not' preserve any continuation lines which may have
          been present in the original `Content-Type' header.

      -- Method: get_content_charset ([failobj])
          Return the `charset' parameter of the `Content-Type' header,
          coerced to lower case.  If there is no `Content-Type' header,
          or if that header has no `charset' parameter, `failobj' is
          returned.

          Note that this method differs from *Note get_charset(): 1874.
          which returns the *Note Charset: 1873. instance for the
          default encoding of the message body.

          New in version 2.2.2.


      -- Method: get_charsets ([failobj])
          Return a list containing the character set names in the
          message.  If the message is a `multipart', then the list will
          contain one element for each subpart in the payload,
          otherwise, it will be a list of length 1.

          Each item in the list will be a string which is the value of
          the `charset' parameter in the `Content-Type' header for the
          represented subpart.  However, if the subpart has no
          `Content-Type' header, no `charset' parameter, or is not of
          the `text' main MIME type, then that item in the returned list
          will be `failobj'.

      -- Method: walk ()
          The *Note walk(): 1894. method is an all-purpose generator
          which can be used to iterate over all the parts and subparts
          of a message object tree, in depth-first traversal order.
          You will typically use *Note walk(): 1894. as the iterator in
          a `for' loop; each iteration returns the next subpart.

          Here’s an example that prints the MIME type of every part
          of a multipart message structure:

              >>> for part in msg.walk():
              ...     print part.get_content_type()
              multipart/report
              text/plain
              message/delivery-status
              text/plain
              text/plain
              message/rfc822

     Changed in version 2.5: The previously deprecated methods
     `get_type()', `get_main_type()', and `get_subtype()' were removed.

     *Note Message: 216. objects can also optionally contain two
     instance attributes, which can be used when generating the plain
     text of a MIME message.

      -- Attribute: preamble
          The format of a MIME document allows for some text between
          the blank line following the headers, and the first multipart
          boundary string. Normally, this text is never visible in a
          MIME-aware mail reader because it falls outside the standard
          MIME armor.  However, when viewing the raw text of the
          message, or when viewing the message in a non-MIME aware
          reader, this text can become visible.

          The `preamble' attribute contains this leading extra-armor
          text for MIME documents.  When the *Note Parser: 1896.
          discovers some text after the headers but before the first
          boundary string, it assigns this text to the message’s
          `preamble' attribute.  When the *Note Generator: 1869. is
          writing out the plain text representation of a MIME message,
          and it finds the message has a `preamble' attribute, it will
          write this text in the area between the headers and the first
          boundary.  See *Note email.parser: c4. and *Note
          email.generator: bf. for details.

          Note that if the message object has no preamble, the
          `preamble' attribute will be `None'.

      -- Attribute: epilogue
          The `epilogue' attribute acts the same way as the `preamble'
          attribute, except that it contains text that appears between
          the last boundary and the end of the message.

          Changed in version 2.5: You do not need to set the epilogue
          to the empty string in order for the *Note Generator: 1869.
          to print a newline at the end of the file.


      -- Attribute: defects
          The `defects' attribute contains a list of all the problems
          found when parsing this message.  See *Note email.errors: be.
          for a detailed description of the possible parsing defects.

          New in version 2.4.


---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2822.html

(2) https://tools.ietf.org/html/rfc2822.html

(3) https://tools.ietf.org/html/rfc2231.html

(4) https://tools.ietf.org/html/rfc2045.html

(5) https://tools.ietf.org/html/rfc2045.html

(6) https://tools.ietf.org/html/rfc2045.html

(7) https://tools.ietf.org/html/rfc2231.html

(8) https://tools.ietf.org/html/rfc2231.html

(9) https://tools.ietf.org/html/rfc2045.html

(10) https://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: email parser Parsing email messages,  Next: email generator Generating MIME documents,  Prev: email message Representing an email message,  Up: email — An email and MIME handling package

5.18.1.2 `email.parser': Parsing email messages
...............................................

Message object structures can be created in one of two ways: they can
be created from whole cloth by instantiating *Note Message: 216.
objects and stringing them together via *Note attach(): 186f. and *Note
set_payload(): 1870. calls, or they can be created by parsing a flat
text representation of the email message.

The *Note email: bb. package provides a standard parser that
understands most email document structures, including MIME documents.
You can pass the parser a string or a file object, and the parser will
return to you the root *Note Message: 216. instance of the object
structure.  For simple, non-MIME messages the payload of this root
object will likely be a string containing the text of the message.  For
MIME messages, the root object will return `True' from its *Note
is_multipart(): 186c. method, and the subparts can be accessed via the
*Note get_payload(): 1871.  and *Note walk(): 1894. methods.

There are actually two parser interfaces available for use, the classic
*Note Parser: 1896. API and the incremental *Note FeedParser: 189b.
API.  The classic *Note Parser: 1896. API is fine if you have the
entire text of the message in memory as a string, or if the entire
message lives in a file on the file system.  *Note FeedParser: 189b. is
more appropriate for when you’re reading the message from a stream
which might block waiting for more input (e.g. reading an email message
from a socket).  The *Note FeedParser: 189b. can consume and parse the
message incrementally, and only returns the root object when you close
the parser (1).

Note that the parser can be extended in limited ways, and of course you
can implement your own parser completely from scratch.  There is no
magical connection between the *Note email: bb. package’s bundled
parser and the *Note Message: 216. class, so your custom parser can
create message object trees any way it finds necessary.

* Menu:

* FeedParser API::
* Parser class API::
* Additional notes::

---------- Footnotes ----------

(1) As of email package version 3.0, introduced in Python 2.4, the
classic *Note Parser: 1896. was re-implemented in terms of the *Note
FeedParser: 189b, so the semantics and results are identical between
the two parsers.


File: python.info,  Node: FeedParser API,  Next: Parser class API,  Up: email parser Parsing email messages

5.18.1.3 FeedParser API
.......................

New in version 2.4.

The *Note FeedParser: 189b, imported from the `email.feedparser' module,
provides an API that is conducive to incremental parsing of email
messages, such as would be necessary when reading the text of an email
message from a source that can block (e.g. a socket).  The *Note
FeedParser: 189b. can of course be used to parse an email message fully
contained in a string or a file, but the classic *Note Parser: 1896.
API may be more convenient for such use cases.  The semantics and
results of the two parser APIs are identical.

The *Note FeedParser: 189b.’s API is simple; you create an instance,
feed it a bunch of text until there’s no more to feed it, then close
the parser to retrieve the root message object.  The *Note FeedParser:
189b. is extremely accurate when parsing standards-compliant messages,
and it does a very good job of parsing non-compliant messages,
providing information about how a message was deemed broken.  It will
populate a message object’s `defects' attribute with a list of any
problems it found in a message.  See the *Note email.errors: be. module
for the list of defects that it can find.

Here is the API for the *Note FeedParser: 189b.:

 -- Class: email.parser.FeedParser ([_factory])
     Create a *Note FeedParser: 189b. instance.  Optional `_factory' is
     a no-argument callable that will be called whenever a new message
     object is needed.  It defaults to the *Note email.message.Message:
     216. class.

      -- Method: feed (data)
          Feed the *Note FeedParser: 189b. some more data.  `data'
          should be a string containing one or more lines.  The lines
          can be partial and the *Note FeedParser: 189b. will stitch
          such partial lines together properly.  The lines in the
          string can have any of the common three line endings,
          carriage return, newline, or carriage return and newline
          (they can even be mixed).

      -- Method: close ()
          Closing a *Note FeedParser: 189b. completes the parsing of
          all previously fed data, and returns the root message object.
          It is undefined what happens if you feed more data to a
          closed *Note FeedParser: 189b.


File: python.info,  Node: Parser class API,  Next: Additional notes,  Prev: FeedParser API,  Up: email parser Parsing email messages

5.18.1.4 Parser class API
.........................

The *Note Parser: 1896. class, imported from the *Note email.parser:
c4. module, provides an API that can be used to parse a message when
the complete contents of the message are available in a string or file.
The *Note email.parser: c4.  module also provides a second class,
called `HeaderParser' which can be used if you’re only interested in
the headers of the message.  `HeaderParser' can be much faster in these
situations, since it does not attempt to parse the message body,
instead setting the payload to the raw body as a string. `HeaderParser'
has the same API as the *Note Parser: 1896.  class.

 -- Class: email.parser.Parser ([_class])
     The constructor for the *Note Parser: 1896. class takes an
     optional argument `_class'.  This must be a callable factory (such
     as a function or a class), and it is used whenever a sub-message
     object needs to be created.  It defaults to *Note Message: 216.
     (see *Note email.message: c2.).  The factory will be called
     without arguments.

     The optional `strict' flag is ignored.

     Deprecated since version 2.4: Because the *Note Parser: 1896.
     class is a backward compatible API wrapper around the
     new-in-Python 2.4 *Note FeedParser: 189b, `all' parsing is
     effectively non-strict.  You should simply stop passing a `strict'
     flag to the *Note Parser: 1896. constructor.

     Changed in version 2.2.2: The `strict' flag was added.

     Changed in version 2.4: The `strict' flag was deprecated.

     The other public *Note Parser: 1896. methods are:

      -- Method: parse (fp[, headersonly])
          Read all the data from the file-like object `fp', parse the
          resulting text, and return the root message object.  `fp'
          must support both the *Note readline(): 8b0. and the *Note
          read(): 1213.  methods on file-like objects.

          The text contained in `fp' must be formatted as a block of RFC
          2822(1) style headers and header continuation lines,
          optionally preceded by an envelope header.  The header block
          is terminated either by the end of the data or by a blank
          line.  Following the header block is the body of the message
          (which may contain MIME-encoded subparts).

          Optional `headersonly' is a flag specifying whether to stop
          parsing after reading the headers or not.  The default is
          `False', meaning it parses the entire contents of the file.

          Changed in version 2.2.2: The `headersonly' flag was added.


      -- Method: parsestr (text[, headersonly])
          Similar to the *Note parse(): 18a0. method, except it takes a
          string object instead of a file-like object.  Calling this
          method on a string is exactly equivalent to wrapping `text'
          in a *Note StringIO: 2df. instance first and calling *Note
          parse(): 18a0.

          Optional `headersonly' is as with the *Note parse(): 18a0.
          method.

          Changed in version 2.2.2: The `headersonly' flag was added.


Since creating a message object structure from a string or a file
object is such a common task, two functions are provided as a
convenience.  They are available in the top-level *Note email: bb.
package namespace.

 -- Function: email.message_from_string (s[, _class[, strict]])
     Return a message object structure from a string.  This is exactly
     equivalent to `Parser().parsestr(s)'.  Optional `_class' and
     `strict' are interpreted as with the *Note Parser: 1896. class
     constructor.

     Changed in version 2.2.2: The `strict' flag was added.


 -- Function: email.message_from_file (fp[, _class[, strict]])
     Return a message object structure tree from an open file object.
     This is exactly equivalent to `Parser().parse(fp)'.  Optional
     `_class' and `strict' are interpreted as with the *Note Parser:
     1896. class constructor.

     Changed in version 2.2.2: The `strict' flag was added.


Here’s an example of how you might use this at an interactive Python
prompt:

    >>> import email
    >>> msg = email.message_from_string(myString)

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: Additional notes,  Prev: Parser class API,  Up: email parser Parsing email messages

5.18.1.5 Additional notes
.........................

Here are some notes on the parsing semantics:

   * Most non-`multipart' type messages are parsed as a single message
     object with a string payload.  These objects will return `False'
     for *Note is_multipart(): 186c.  Their *Note get_payload(): 1871.
     method will return a string object.

   * All `multipart' type messages will be parsed as a container message
     object with a list of sub-message objects for their payload.  The
     outer container message will return `True' for *Note
     is_multipart(): 186c. and their *Note get_payload(): 1871. method
     will return the list of *Note Message: 216. subparts.

   * Most messages with a content type of `message/*' (e.g.
     `message/delivery-status' and `message/rfc822') will also be
     parsed as container object containing a list payload of length 1.
     Their *Note is_multipart(): 186c. method will return `True'.  The
     single element in the list payload will be a sub-message object.

   * Some non-standards compliant messages may not be internally
     consistent about their `multipart'-edness.  Such messages may have
     a `Content-Type' header of type `multipart', but their *Note
     is_multipart(): 186c. method may return `False'.  If such messages
     were parsed with the *Note FeedParser: 189b, they will have an
     instance of the `MultipartInvariantViolationDefect' class in their
     `defects' attribute list.  See *Note email.errors: be. for details.


File: python.info,  Node: email generator Generating MIME documents,  Next: email mime Creating email and MIME objects from scratch,  Prev: email parser Parsing email messages,  Up: email — An email and MIME handling package

5.18.1.6 `email.generator': Generating MIME documents
.....................................................

One of the most common tasks is to generate the flat text of the email
message represented by a message object structure.  You will need to do
this if you want to send your message via the *Note smtplib: 15a.
module or the *Note nntplib: 125. module, or print the message on the
console.  Taking a message object structure and producing a flat text
document is the job of the *Note Generator: 1869. class.

Again, as with the *Note email.parser: c4. module, you aren’t limited
to the functionality of the bundled generator; you could write one from
scratch yourself.  However the bundled generator knows how to generate
most email in a standards-compliant way, should handle MIME and
non-MIME email messages just fine, and is designed so that the
transformation from flat text, to a message structure via the *Note
Parser: 1896. class, and back to flat text, is idempotent (the input is
identical to the output) (1).  On the other hand, using the Generator
on a *Note Message: 216. constructed by program may result in changes
to the *Note Message: 216. object as defaults are filled in.

Here are the public methods of the *Note Generator: 1869. class,
imported from the *Note email.generator: bf. module:

 -- Class: email.generator.Generator (outfp[, mangle_from_[,
          maxheaderlen]])
     The constructor for the *Note Generator: 1869. class takes a
     file-like object called `outfp' for an argument.  `outfp' must
     support the *Note write(): 18a7. method and be usable as the
     output file in a Python extended print statement.

     Optional `mangle_from_' is a flag that, when `True', puts a `>'
     character in front of any line in the body that starts exactly as
     `From', i.e. `From' followed by a space at the beginning of the
     line.  This is the only guaranteed portable way to avoid having
     such lines be mistaken for a Unix mailbox format envelope header
     separator (see WHY THE CONTENT-LENGTH FORMAT IS BAD(2) for
     details).  `mangle_from_' defaults to `True', but you might want
     to set this to `False' if you are not writing Unix mailbox format
     files.

     Optional `maxheaderlen' specifies the longest length for a
     non-continued header.  When a header line is longer than
     `maxheaderlen' (in characters, with tabs expanded to 8 spaces),
     the header will be split as defined in the *Note Header: 18a8.
     class.  Set to zero to disable header wrapping.  The default is
     78, as recommended (but not required) by RFC 2822(3).

     The other public *Note Generator: 1869. methods are:

      -- Method: flatten (msg[, unixfrom])
          Print the textual representation of the message object
          structure rooted at `msg' to the output file specified when
          the *Note Generator: 1869. instance was created.  Subparts
          are visited depth-first and the resulting text will be
          properly MIME encoded.

          Optional `unixfrom' is a flag that forces the printing of the
          envelope header delimiter before the first RFC 2822(4) header
          of the root message object.  If the root object has no
          envelope header, a standard one is crafted.  By default, this
          is set to `False' to inhibit the printing of the envelope
          delimiter.

          Note that for subparts, no envelope header is ever printed.

          New in version 2.2.2.


      -- Method: clone (fp)
          Return an independent clone of this *Note Generator: 1869.
          instance with the exact same options.

          New in version 2.2.2.


      -- Method: write (s)
          Write the string `s' to the underlying file object, i.e.
          `outfp' passed to *Note Generator: 1869.’s constructor.
          This provides just enough file-like API for *Note Generator:
          1869. instances to be used in extended print statements.

As a convenience, see the methods `Message.as_string()' and
`str(aMessage)', a.k.a. `Message.__str__()', which simplify the
generation of a formatted string representation of a message object.
For more detail, see *Note email.message: c2.

The *Note email.generator: bf. module also provides a derived class,
called *Note DecodedGenerator: 18aa. which is like the *Note Generator:
1869. base class, except that non-`text' parts are substituted with a
format string representing the part.

 -- Class: email.generator.DecodedGenerator (outfp[, mangle_from_[,
          maxheaderlen[, fmt]]])
     This class, derived from *Note Generator: 1869. walks through all
     the subparts of a message.  If the subpart is of main type `text',
     then it prints the decoded payload of the subpart. Optional
     `_mangle_from_' and `maxheaderlen' are as with the *Note
     Generator: 1869. base class.

     If the subpart is not of main type `text', optional `fmt' is a
     format string that is used instead of the message payload. `fmt'
     is expanded with the following keywords, `%(keyword)s' format:

        * `type' – Full MIME type of the non-`text' part

        * `maintype' – Main MIME type of the non-`text' part

        * `subtype' – Sub-MIME type of the non-`text' part

        * `filename' – Filename of the non-`text' part

        * `description' – Description associated with the non-`text'
          part

        * `encoding' – Content transfer encoding of the non-`text'
          part

     The default value for `fmt' is `None', meaning

         [Non-text (%(type)s) part of message omitted, filename %(filename)s]

     New in version 2.2.2.


Changed in version 2.5: The previously deprecated method *Note
__call__(): 725. was removed.

---------- Footnotes ----------

(1) This statement assumes that you use the appropriate setting for the
`unixfrom' argument, and that you set maxheaderlen=0 (which will
preserve whatever the input line lengths were).  It is also not strictly
true, since in many cases runs of whitespace in headers are collapsed
into single blanks.  The latter is a bug that will eventually be fixed.

(2) https://www.jwz.org/doc/content-length.html

(3) https://tools.ietf.org/html/rfc2822.html

(4) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: email mime Creating email and MIME objects from scratch,  Next: email header Internationalized headers,  Prev: email generator Generating MIME documents,  Up: email — An email and MIME handling package

5.18.1.7 `email.mime': Creating email and MIME objects from scratch
...................................................................

Ordinarily, you get a message object structure by passing a file or
some text to a parser, which parses the text and returns the root
message object.  However you can also build a complete message
structure from scratch, or even individual *Note Message: 216. objects
by hand.  In fact, you can also take an existing structure and add new
*Note Message: 216. objects, move them around, etc.  This makes a very
convenient interface for slicing-and-dicing MIME messages.

You can create a new object structure by creating *Note Message: 216.
instances, adding attachments and all the appropriate headers manually.
For MIME messages though, the *Note email: bb. package provides some
convenient subclasses to make things easier.

Here are the classes:

 -- Class: email.mime.base.MIMEBase (_maintype, _subtype, **_params)
     Module: `email.mime.base'

     This is the base class for all the MIME-specific subclasses of
     *Note Message: 216.  Ordinarily you won’t create instances
     specifically of *Note MIMEBase: 18ad, although you could.  *Note
     MIMEBase: 18ad.  is provided primarily as a convenient base class
     for more specific MIME-aware subclasses.

     `_maintype' is the `Content-Type' major type (e.g. `text' or
     `image'), and `_subtype' is the `Content-Type' minor type  (e.g.
     `plain' or `gif').  `_params' is a parameter key/value dictionary
     and is passed directly to *Note Message.add_header: 1880.

     The *Note MIMEBase: 18ad. class always adds a `Content-Type' header
     (based on `_maintype', `_subtype', and `_params'), and a
     `MIME-Version' header (always set to `1.0').

 -- Class: email.mime.nonmultipart.MIMENonMultipart
     Module: `email.mime.nonmultipart'

     A subclass of *Note MIMEBase: 18ad, this is an intermediate base
     class for MIME messages that are not `multipart'.  The primary
     purpose of this class is to prevent the use of the *Note attach():
     186f. method, which only makes sense for `multipart' messages.  If
     *Note attach(): 186f.  is called, a *Note
     MultipartConversionError: 18af. exception is raised.

     New in version 2.2.2.


 -- Class: email.mime.multipart.MIMEMultipart ([_subtype[, boundary[,
          _subparts[, _params]]]])
     Module: `email.mime.multipart'

     A subclass of *Note MIMEBase: 18ad, this is an intermediate base
     class for MIME messages that are `multipart'.  Optional `_subtype'
     defaults to `mixed', but can be used to specify the subtype of the
     message.  A `Content-Type' header of `multipart/_subtype' will be
     added to the message object.  A `MIME-Version' header will also be
     added.

     Optional `boundary' is the multipart boundary string.  When `None'
     (the default), the boundary is calculated when needed (for
     example, when the message is serialized).

     `_subparts' is a sequence of initial subparts for the payload.  It
     must be possible to convert this sequence to a list.  You can
     always attach new subparts to the message by using the *Note
     Message.attach: 186f. method.

     Additional parameters for the `Content-Type' header are taken from
     the keyword arguments, or passed into the `_params' argument,
     which is a keyword dictionary.

     New in version 2.2.2.


 -- Class: email.mime.application.MIMEApplication (_data[, _subtype[,
          _encoder[, **_params]]])
     Module: `email.mime.application'

     A subclass of *Note MIMENonMultipart: 18ae, the *Note
     MIMEApplication: 18b1. class is used to represent MIME message
     objects of major type `application'.  `_data' is a string
     containing the raw byte data.  Optional `_subtype' specifies the
     MIME subtype and defaults to `octet-stream'.

     Optional `_encoder' is a callable (i.e. function) which will
     perform the actual encoding of the data for transport.  This
     callable takes one argument, which is the *Note MIMEApplication:
     18b1. instance. It should use *Note get_payload(): 1871. and *Note
     set_payload(): 1870. to change the payload to encoded form.  It
     should also add any `Content-Transfer-Encoding' or other headers
     to the message object as necessary.  The default encoding is
     base64.  See the *Note email.encoders: bd. module for a list of
     the built-in encoders.

     `_params' are passed straight through to the base class
     constructor.

     New in version 2.5.


 -- Class: email.mime.audio.MIMEAudio (_audiodata[, _subtype[,
          _encoder[, **_params]]])
     Module: `email.mime.audio'

     A subclass of *Note MIMENonMultipart: 18ae, the *Note MIMEAudio:
     18b2. class is used to create MIME message objects of major type
     `audio'. `_audiodata' is a string containing the raw audio data.
     If this data can be decoded by the standard Python module *Note
     sndhdr: 15b, then the subtype will be automatically included in
     the `Content-Type' header.  Otherwise you can explicitly specify
     the audio subtype via the `_subtype' parameter.  If the minor type
     could not be guessed and `_subtype' was not given, then *Note
     TypeError: 218. is raised.

     Optional `_encoder' is a callable (i.e. function) which will
     perform the actual encoding of the audio data for transport.  This
     callable takes one argument, which is the *Note MIMEAudio: 18b2.
     instance. It should use *Note get_payload(): 1871. and *Note
     set_payload(): 1870. to change the payload to encoded form.  It
     should also add any `Content-Transfer-Encoding' or other headers
     to the message object as necessary.  The default encoding is
     base64.  See the *Note email.encoders: bd. module for a list of
     the built-in encoders.

     `_params' are passed straight through to the base class
     constructor.

 -- Class: email.mime.image.MIMEImage (_imagedata[, _subtype[,
          _encoder[, **_params]]])
     Module: `email.mime.image'

     A subclass of *Note MIMENonMultipart: 18ae, the *Note MIMEImage:
     18b3. class is used to create MIME message objects of major type
     `image'. `_imagedata' is a string containing the raw image data.
     If this data can be decoded by the standard Python module *Note
     imghdr: f5, then the subtype will be automatically included in the
     `Content-Type' header.  Otherwise you can explicitly specify the
     image subtype via the `_subtype' parameter.  If the minor type
     could not be guessed and `_subtype' was not given, then *Note
     TypeError: 218. is raised.

     Optional `_encoder' is a callable (i.e. function) which will
     perform the actual encoding of the image data for transport.  This
     callable takes one argument, which is the *Note MIMEImage: 18b3.
     instance. It should use *Note get_payload(): 1871. and *Note
     set_payload(): 1870. to change the payload to encoded form.  It
     should also add any `Content-Transfer-Encoding' or other headers
     to the message object as necessary.  The default encoding is
     base64.  See the *Note email.encoders: bd. module for a list of
     the built-in encoders.

     `_params' are passed straight through to the *Note MIMEBase: 18ad.
     constructor.

 -- Class: email.mime.message.MIMEMessage (_msg[, _subtype])
     Module: `email.mime.message'

     A subclass of *Note MIMENonMultipart: 18ae, the *Note MIMEMessage:
     18b4. class is used to create MIME objects of main type `message'.
     `_msg' is used as the payload, and must be an instance of class
     *Note Message: 216. (or a subclass thereof), otherwise a *Note
     TypeError: 218. is raised.

     Optional `_subtype' sets the subtype of the message; it defaults to
     `rfc822'.

 -- Class: email.mime.text.MIMEText (_text[, _subtype[, _charset]])
     Module: `email.mime.text'

     A subclass of *Note MIMENonMultipart: 18ae, the *Note MIMEText:
     18b5. class is used to create MIME objects of major type `text'.
     `_text' is the string for the payload.  `_subtype' is the minor
     type and defaults to `plain'.  `_charset' is the character set of
     the text and is passed as a parameter to the *Note
     MIMENonMultipart: 18ae. constructor; it defaults to `us-ascii'.
     If `_text' is unicode, it is encoded using the `output_charset' of
     `_charset', otherwise it is used as-is.

     Changed in version 2.4: The previously deprecated `_encoding'
     argument has been removed.  Content Transfer Encoding now happens
     implicitly based on the `_charset' argument.

     Unless the `_charset' parameter is explicitly set to `None', the
     MIMEText object created will have both a `Content-Type' header
     with a `charset' parameter, and a `Content-Transfer-Endcoding'
     header.  This means that a subsequent `set_payload' call will not
     result in an encoded payload, even if a charset is passed in the
     `set_payload' command.  You can “reset” this behavior by
     deleting the `Content-Transfer-Encoding' header, after which a
     `set_payload' call will automatically encode the new payload (and
     add a new `Content-Transfer-Encoding' header).


File: python.info,  Node: email header Internationalized headers,  Next: email charset Representing character sets,  Prev: email mime Creating email and MIME objects from scratch,  Up: email — An email and MIME handling package

5.18.1.8 `email.header': Internationalized headers
..................................................

RFC 2822(1) is the base standard that describes the format of email
messages.  It derives from the older RFC 822(2) standard which came
into widespread use at a time when most email was composed of ASCII
characters only.  RFC 2822(3) is a specification written assuming email
contains only 7-bit ASCII characters.

Of course, as email has been deployed worldwide, it has become
internationalized, such that language specific character sets can now
be used in email messages.  The base standard still requires email
messages to be transferred using only 7-bit ASCII characters, so a slew
of RFCs have been written describing how to encode email containing
non-ASCII characters into RFC 2822(4)-compliant format. These RFCs
include RFC 2045(5), RFC 2046(6), RFC 2047(7), and RFC 2231(8). The
*Note email: bb. package supports these standards in its *Note
email.header: c0. and *Note email.charset: bc. modules.

If you want to include non-ASCII characters in your email headers, say
in the `Subject' or `To' fields, you should use the *Note Header: 18a8.
class and assign the field in the *Note Message: 216.  object to an
instance of *Note Header: 18a8. instead of using a string for the header
value.  Import the *Note Header: 18a8. class from the *Note
email.header: c0. module.  For example:

    >>> from email.message import Message
    >>> from email.header import Header
    >>> msg = Message()
    >>> h = Header('p\xf6stal', 'iso-8859-1')
    >>> msg['Subject'] = h
    >>> print msg.as_string()
    Subject: =?iso-8859-1?q?p=F6stal?=

Notice here how we wanted the `Subject' field to contain a non-ASCII
character?  We did this by creating a *Note Header: 18a8. instance and
passing in the character set that the byte string was encoded in.  When
the subsequent *Note Message: 216. instance was flattened, the `Subject'
field was properly RFC 2047(9) encoded.  MIME-aware mail readers would
show this header using the embedded ISO-8859-1 character.

New in version 2.2.2.

Here is the *Note Header: 18a8. class description:

 -- Class: email.header.Header ([s[, charset[, maxlinelen[,
          header_name[, continuation_ws[, errors]]]]]])
     Create a MIME-compliant header that can contain strings in
     different character sets.

     Optional `s' is the initial header value.  If `None' (the
     default), the initial header value is not set.  You can later
     append to the header with *Note append(): 18b8. method calls.  `s'
     may be a byte string or a Unicode string, but see the *Note
     append(): 18b8. documentation for semantics.

     Optional `charset' serves two purposes: it has the same meaning as
     the `charset' argument to the *Note append(): 18b8. method.  It
     also sets the default character set for all subsequent *Note
     append(): 18b8. calls that omit the `charset' argument.  If
     `charset' is not provided in the constructor (the default), the
     `us-ascii' character set is used both as `s'’s initial charset
     and as the default for subsequent *Note append(): 18b8. calls.

     The maximum line length can be specified explicitly via
     `maxlinelen'.  For splitting the first line to a shorter value (to
     account for the field header which isn’t included in `s', e.g.
     `Subject') pass in the name of the field in `header_name'.  The
     default `maxlinelen' is 76, and the default value for
     `header_name' is `None', meaning it is not taken into account for
     the first line of a long, split header.

     Optional `continuation_ws' must be RFC 2822(10)-compliant folding
     whitespace, and is usually either a space or a hard tab character.
     This character will be prepended to continuation lines.
     `continuation_ws' defaults to a single space character (” “).

     Optional `errors' is passed straight through to the *Note
     append(): 18b8. method.

      -- Method: append (s[, charset[, errors]])
          Append the string `s' to the MIME header.

          Optional `charset', if given, should be a *Note Charset: 1873.
          instance (see *Note email.charset: bc.) or the name of a
          character set, which will be converted to a *Note Charset:
          1873. instance.  A value of `None' (the default) means that
          the `charset' given in the constructor is used.

          `s' may be a byte string or a Unicode string.  If it is a
          byte string (i.e.  `isinstance(s, str)' is true), then
          `charset' is the encoding of that byte string, and a *Note
          UnicodeError: 44c. will be raised if the string cannot be
          decoded with that character set.

          If `s' is a Unicode string, then `charset' is a hint
          specifying the character set of the characters in the string.
          In this case, when producing an RFC 2822(11)-compliant
          header using RFC 2047(12) rules, the Unicode string will be
          encoded using the following charsets in order: `us-ascii',
          the `charset' hint, `utf-8'.  The first character set to not
          provoke a *Note UnicodeError: 44c. is used.

          Optional `errors' is passed through to any *Note unicode():
          1f5. or `unicode.encode()' call, and defaults to “strict”.

      -- Method: encode ([splitchars])
          Encode a message header into an RFC-compliant format,
          possibly wrapping long lines and encapsulating non-ASCII
          parts in base64 or quoted-printable encodings.  Optional
          `splitchars' is a string containing characters to split long
          ASCII lines on, in rough support of RFC 2822(13)’s `highest
          level syntactic breaks'.  This doesn’t affect RFC 2047(14)
          encoded lines.

     The *Note Header: 18a8. class also provides a number of methods to
     support standard operators and built-in functions.

      -- Method: __str__ ()
          A synonym for *Note Header.encode(): 18b9.  Useful for
          `str(aHeader)'.

      -- Method: __unicode__ ()
          A helper for the built-in *Note unicode(): 1f5. function.
          Returns the header as a Unicode string.

      -- Method: __eq__ (other)
          This method allows you to compare two *Note Header: 18a8.
          instances for equality.

      -- Method: __ne__ (other)
          This method allows you to compare two *Note Header: 18a8.
          instances for inequality.

The *Note email.header: c0. module also provides the following
convenient functions.

 -- Function: email.header.decode_header (header)
     Decode a message header value without converting the character
     set. The header value is in `header'.

     This function returns a list of `(decoded_string, charset)' pairs
     containing each of the decoded parts of the header.  `charset' is
     `None' for non-encoded parts of the header, otherwise a lower case
     string containing the name of the character set specified in the
     encoded string.

     Here’s an example:

         >>> from email.header import decode_header
         >>> decode_header('=?iso-8859-1?q?p=F6stal?=')
         [('p\xf6stal', 'iso-8859-1')]

 -- Function: email.header.make_header (decoded_seq[, maxlinelen[,
          header_name[, continuation_ws]]])
     Create a *Note Header: 18a8. instance from a sequence of pairs as
     returned by *Note decode_header(): 18be.

     *Note decode_header(): 18be. takes a header value string and
     returns a sequence of pairs of the format `(decoded_string,
     charset)' where `charset' is the name of the character set.

     This function takes one of those sequence of pairs and returns a
     *Note Header: 18a8.  instance.  Optional `maxlinelen',
     `header_name', and `continuation_ws' are as in the *Note Header:
     18a8. constructor.

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2822.html

(2) https://tools.ietf.org/html/rfc822.html

(3) https://tools.ietf.org/html/rfc2822.html

(4) https://tools.ietf.org/html/rfc2822.html

(5) https://tools.ietf.org/html/rfc2045.html

(6) https://tools.ietf.org/html/rfc2046.html

(7) https://tools.ietf.org/html/rfc2047.html

(8) https://tools.ietf.org/html/rfc2231.html

(9) https://tools.ietf.org/html/rfc2047.html

(10) https://tools.ietf.org/html/rfc2822.html

(11) https://tools.ietf.org/html/rfc2822.html

(12) https://tools.ietf.org/html/rfc2047.html

(13) https://tools.ietf.org/html/rfc2822.html

(14) https://tools.ietf.org/html/rfc2047.html


File: python.info,  Node: email charset Representing character sets,  Next: email encoders Encoders,  Prev: email header Internationalized headers,  Up: email — An email and MIME handling package

5.18.1.9 `email.charset': Representing character sets
.....................................................

This module provides a class *Note Charset: 1873. for representing
character sets and character set conversions in email messages, as well
as a character set registry and several convenience methods for
manipulating this registry.  Instances of *Note Charset: 1873. are used
in several other modules within the *Note email: bb. package.

Import this class from the *Note email.charset: bc. module.

New in version 2.2.2.

 -- Class: email.charset.Charset ([input_charset])
     Map character sets to their email properties.

     This class provides information about the requirements imposed on
     email for a specific character set.  It also provides convenience
     routines for converting between character sets, given the
     availability of the applicable codecs.  Given a character set, it
     will do its best to provide information on how to use that
     character set in an email message in an RFC-compliant way.

     Certain character sets must be encoded with quoted-printable or
     base64 when used in email headers or bodies.  Certain character
     sets must be converted outright, and are not allowed in email.

     Optional `input_charset' is as described below; it is always
     coerced to lower case.  After being alias normalized it is also
     used as a lookup into the registry of character sets to find out
     the header encoding, body encoding, and output conversion codec to
     be used for the character set.  For example, if `input_charset' is
     `iso-8859-1', then headers and bodies will be encoded using
     quoted-printable and no output conversion codec is necessary.  If
     `input_charset' is `euc-jp', then headers will be encoded with
     base64, bodies will not be encoded, but output text will be
     converted from the `euc-jp' character set to the `iso-2022-jp'
     character set.

     *Note Charset: 1873. instances have the following data attributes:

      -- Attribute: input_charset
          The initial character set specified.  Common aliases are
          converted to their `official' email names (e.g. `latin_1' is
          converted to `iso-8859-1').  Defaults to 7-bit `us-ascii'.

      -- Attribute: header_encoding
          If the character set must be encoded before it can be used in
          an email header, this attribute will be set to `Charset.QP'
          (for quoted-printable), `Charset.BASE64' (for base64
          encoding), or `Charset.SHORTEST' for the shortest of QP or
          BASE64 encoding. Otherwise, it will be `None'.

      -- Attribute: body_encoding
          Same as `header_encoding', but describes the encoding for the
          mail message’s body, which indeed may be different than the
          header encoding.  `Charset.SHORTEST' is not allowed for
          `body_encoding'.

      -- Attribute: output_charset
          Some character sets must be converted before they can be used
          in email headers or bodies.  If the `input_charset' is one of
          them, this attribute will contain the name of the character
          set output will be converted to.  Otherwise, it will be
          `None'.

      -- Attribute: input_codec
          The name of the Python codec used to convert the
          `input_charset' to Unicode.  If no conversion codec is
          necessary, this attribute will be `None'.

      -- Attribute: output_codec
          The name of the Python codec used to convert Unicode to the
          `output_charset'.  If no conversion codec is necessary, this
          attribute will have the same value as the `input_codec'.

     *Note Charset: 1873. instances also have the following methods:

      -- Method: get_body_encoding ()
          Return the content transfer encoding used for body encoding.

          This is either the string `quoted-printable' or `base64'
          depending on the encoding used, or it is a function, in which
          case you should call the function with a single argument, the
          Message object being encoded.  The function should then set
          the `Content-Transfer-Encoding' header itself to whatever is
          appropriate.

          Returns the string `quoted-printable' if `body_encoding' is
          `QP', returns the string `base64' if `body_encoding' is
          `BASE64', and returns the string `7bit' otherwise.

      -- Method: convert (s)
          Convert the string `s' from the `input_codec' to the
          `output_codec'.

      -- Method: to_splittable (s)
          Convert a possibly multibyte string to a safely splittable
          format. `s' is the string to split.

          Uses the `input_codec' to try and convert the string to
          Unicode, so it can be safely split on character boundaries
          (even for multibyte characters).

          Returns the string as-is if it isn’t known how to convert
          `s' to Unicode with the `input_charset'.

          Characters that could not be converted to Unicode will be
          replaced with the Unicode replacement character `'U+FFFD''.

      -- Method: from_splittable (ustr[, to_output])
          Convert a splittable string back into an encoded string.
          `ustr' is a Unicode string to “unsplit”.

          This method uses the proper codec to try and convert the
          string from Unicode back into an encoded format.  Return the
          string as-is if it is not Unicode, or if it could not be
          converted from Unicode.

          Characters that could not be converted from Unicode will be
          replaced with an appropriate character (usually `'?'').

          If `to_output' is `True' (the default), uses `output_codec'
          to convert to an encoded format.  If `to_output' is `False',
          it uses `input_codec'.

      -- Method: get_output_charset ()
          Return the output character set.

          This is the `output_charset' attribute if that is not `None',
          otherwise it is `input_charset'.

      -- Method: encoded_header_len ()
          Return the length of the encoded header string, properly
          calculating for quoted-printable or base64 encoding.

      -- Method: header_encode (s[, convert])
          Header-encode the string `s'.

          If `convert' is `True', the string will be converted from the
          input charset to the output charset automatically.  This is
          not useful for multibyte character sets, which have line
          length issues (multibyte characters must be split on a
          character, not a byte boundary); use the higher-level *Note
          Header: 18a8. class to deal with these issues (see *Note
          email.header: c0.).  `convert' defaults to `False'.

          The type of encoding (base64 or quoted-printable) will be
          based on the `header_encoding' attribute.

      -- Method: body_encode (s[, convert])
          Body-encode the string `s'.

          If `convert' is `True' (the default), the string will be
          converted from the input charset to output charset
          automatically. Unlike *Note header_encode(): 18ce, there are
          no issues with byte boundaries and multibyte charsets in
          email bodies, so this is usually pretty safe.

          The type of encoding (base64 or quoted-printable) will be
          based on the `body_encoding' attribute.

     The *Note Charset: 1873. class also provides a number of methods
     to support standard operations and built-in functions.

      -- Method: __str__ ()
          Returns `input_charset' as a string coerced to lower case.
          *Note __repr__(): 4a3. is an alias for *Note __str__(): 18d0.

      -- Method: __eq__ (other)
          This method allows you to compare two *Note Charset: 1873.
          instances for equality.

      -- Method: __ne__ (other)
          This method allows you to compare two *Note Charset: 1873.
          instances for inequality.

The *Note email.charset: bc. module also provides the following
functions for adding new entries to the global character set, alias,
and codec registries:

 -- Function: email.charset.add_charset (charset[, header_enc[,
          body_enc[, output_charset]]])
     Add character properties to the global registry.

     `charset' is the input character set, and must be the canonical
     name of a character set.

     Optional `header_enc' and `body_enc' is either `Charset.QP' for
     quoted-printable, `Charset.BASE64' for base64 encoding,
     `Charset.SHORTEST' for the shortest of quoted-printable or base64
     encoding, or `None' for no encoding.  `SHORTEST' is only valid for
     `header_enc'. The default is `None' for no encoding.

     Optional `output_charset' is the character set that the output
     should be in.  Conversions will proceed from input charset, to
     Unicode, to the output charset when the method *Note
     Charset.convert(): 18c9. is called.  The default is to output in
     the same character set as the input.

     Both `input_charset' and `output_charset' must have Unicode codec
     entries in the module’s character set-to-codec mapping; use
     *Note add_codec(): 18d4. to add codecs the module does not know
     about.  See the *Note codecs: 63. module’s documentation for
     more information.

     The global character set registry is kept in the module global
     dictionary `CHARSETS'.

 -- Function: email.charset.add_alias (alias, canonical)
     Add a character set alias.  `alias' is the alias name, e.g.
     `latin-1'.  `canonical' is the character set’s canonical name,
     e.g. `iso-8859-1'.

     The global charset alias registry is kept in the module global
     dictionary `ALIASES'.

 -- Function: email.charset.add_codec (charset, codecname)
     Add a codec that map characters in the given character set to and
     from Unicode.

     `charset' is the canonical name of a character set. `codecname' is
     the name of a Python codec, as appropriate for the second argument
     to the *Note unicode(): 1f5.  built-in, or to the `encode()'
     method of a Unicode string.


File: python.info,  Node: email encoders Encoders,  Next: email errors Exception and Defect classes,  Prev: email charset Representing character sets,  Up: email — An email and MIME handling package

5.18.1.10 `email.encoders': Encoders
....................................

When creating *Note Message: 216. objects from scratch, you often need
to encode the payloads for transport through compliant mail servers.
This is especially true for `image/*' and `text/*' type messages
containing binary data.

The *Note email: bb. package provides some convenient encodings in its
`encoders' module.  These encoders are actually used by the *Note
MIMEAudio: 18b2. and *Note MIMEImage: 18b3.  class constructors to
provide default encodings.  All encoder functions take exactly one
argument, the message object to encode.  They usually extract the
payload, encode it, and reset the payload to this newly encoded value.
They should also set the `Content-Transfer-Encoding' header as
appropriate.

Note that these functions are not meaningful for a multipart message.
They must be applied to individual subparts instead, and will raise a
*Note TypeError: 218. if passed a message whose type is multipart.

Here are the encoding functions provided:

 -- Function: email.encoders.encode_quopri (msg)
     Encodes the payload into quoted-printable form and sets the
     `Content-Transfer-Encoding' header to `quoted-printable' (1).
     This is a good encoding to use when most of your payload is normal
     printable data, but contains a few unprintable characters.

 -- Function: email.encoders.encode_base64 (msg)
     Encodes the payload into base64 form and sets the
     `Content-Transfer-Encoding' header to `base64'.  This is a good
     encoding to use when most of your payload is unprintable data
     since it is a more compact form than quoted-printable.  The
     drawback of base64 encoding is that it renders the text non-human
     readable.

 -- Function: email.encoders.encode_7or8bit (msg)
     This doesn’t actually modify the message’s payload, but it
     does set the `Content-Transfer-Encoding' header to either `7bit'
     or `8bit' as appropriate, based on the payload data.

 -- Function: email.encoders.encode_noop (msg)
     This does nothing; it doesn’t even set the
     `Content-Transfer-Encoding' header.

---------- Footnotes ----------

(1) Note that encoding with *Note encode_quopri(): 18d8. also encodes
all tabs and space characters in the data.


File: python.info,  Node: email errors Exception and Defect classes,  Next: email utils Miscellaneous utilities,  Prev: email encoders Encoders,  Up: email — An email and MIME handling package

5.18.1.11 `email.errors': Exception and Defect classes
......................................................

The following exception classes are defined in the *Note email.errors:
be. module:

 -- Exception: email.errors.MessageError
     This is the base class for all exceptions that the *Note email:
     bb. package can raise.  It is derived from the standard *Note
     Exception: 34d. class and defines no additional methods.

 -- Exception: email.errors.MessageParseError
     This is the base class for exceptions raised by the *Note Parser:
     1896.  class.  It is derived from *Note MessageError: 18de.

 -- Exception: email.errors.HeaderParseError
     Raised under some error conditions when parsing the RFC 2822(1)
     headers of a message, this class is derived from *Note
     MessageParseError: 18df. It can be raised from the *Note
     Parser.parse: 18a0. or *Note Parser.parsestr: 18a1. methods.

     Situations where it can be raised include finding an envelope
     header after the first RFC 2822(2) header of the message, finding
     a continuation line before the first RFC 2822(3) header is found,
     or finding a line in the headers which is neither a header or a
     continuation line.

 -- Exception: email.errors.BoundaryError
     Raised under some error conditions when parsing the RFC 2822(4)
     headers of a message, this class is derived from *Note
     MessageParseError: 18df. It can be raised from the *Note
     Parser.parse: 18a0. or *Note Parser.parsestr: 18a1. methods.

     Situations where it can be raised include not being able to find
     the starting or terminating boundary in a `multipart/*' message
     when strict parsing is used.

 -- Exception: email.errors.MultipartConversionError
     Raised when a payload is added to a *Note Message: 216. object
     using `add_payload()', but the payload is already a scalar and the
     message’s `Content-Type' main type is not either `multipart' or
     missing.  *Note MultipartConversionError: 18af. multiply inherits
     from *Note MessageError: 18de. and the built-in *Note TypeError:
     218.

     Since `Message.add_payload()' is deprecated, this exception is
     rarely raised in practice.  However the exception may also be
     raised if the *Note attach(): 186f.  method is called on an
     instance of a class derived from *Note MIMENonMultipart: 18ae.
     (e.g.  *Note MIMEImage: 18b3.).

Here’s the list of the defects that the *Note FeedParser: 189b.  can
find while parsing messages.  Note that the defects are added to the
message where the problem was found, so for example, if a message
nested inside a `multipart/alternative' had a malformed header, that
nested message object would have a defect, but the containing messages
would not.

All defect classes are subclassed from `email.errors.MessageDefect', but
this class is `not' an exception!

New in version 2.4: All the defect classes were added.

   * `NoBoundaryInMultipartDefect' – A message claimed to be a
     multipart, but had no `boundary' parameter.

   * `StartBoundaryNotFoundDefect' – The start boundary claimed in the
     `Content-Type' header was never found.

   * `FirstHeaderLineIsContinuationDefect' – The message had a
     continuation line as its first header line.

   * `MisplacedEnvelopeHeaderDefect' - A “Unix From” header was
     found in the middle of a header block.

   * `MalformedHeaderDefect' – A header was found that was missing a
     colon, or was otherwise malformed.

   * `MultipartInvariantViolationDefect' – A message claimed to be a
     `multipart', but no subparts were found.  Note that when a message
     has this defect, its *Note is_multipart(): 186c. method may return
     false even though its content type claims to be `multipart'.

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2822.html

(2) https://tools.ietf.org/html/rfc2822.html

(3) https://tools.ietf.org/html/rfc2822.html

(4) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: email utils Miscellaneous utilities,  Next: email iterators Iterators,  Prev: email errors Exception and Defect classes,  Up: email — An email and MIME handling package

5.18.1.12 `email.utils': Miscellaneous utilities
................................................

There are several useful utilities provided in the *Note email.utils:
c5. module:

 -- Function: email.utils.quote (str)
     Return a new string with backslashes in `str' replaced by two
     backslashes, and double quotes replaced by backslash-double quote.

 -- Function: email.utils.unquote (str)
     Return a new string which is an `unquoted' version of `str'. If
     `str' ends and begins with double quotes, they are stripped off.
     Likewise if `str' ends and begins with angle brackets, they are
     stripped off.

 -- Function: email.utils.parseaddr (address)
     Parse address – which should be the value of some
     address-containing field such as `To' or `Cc' – into its
     constituent `realname' and `email address' parts.  Returns a tuple
     of that information, unless the parse fails, in which case a
     2-tuple of `('', '')' is returned.

 -- Function: email.utils.formataddr (pair)
     The inverse of *Note parseaddr(): 18e4, this takes a 2-tuple of
     the form `(realname, email_address)' and returns the string value
     suitable for a `To' or `Cc' header.  If the first element of
     `pair' is false, then the second element is returned unmodified.

 -- Function: email.utils.getaddresses (fieldvalues)
     This method returns a list of 2-tuples of the form returned by
     `parseaddr()'.  `fieldvalues' is a sequence of header field values
     as might be returned by *Note Message.get_all: 1879.  Here’s a
     simple example that gets all the recipients of a message:

         from email.utils import getaddresses

         tos = msg.get_all('to', [])
         ccs = msg.get_all('cc', [])
         resent_tos = msg.get_all('resent-to', [])
         resent_ccs = msg.get_all('resent-cc', [])
         all_recipients = getaddresses(tos + ccs + resent_tos + resent_ccs)

 -- Function: email.utils.parsedate (date)
     Attempts to parse a date according to the rules in RFC 2822(1).
     however, some mailers don’t follow that format as specified, so
     *Note parsedate(): 18e7. tries to guess correctly in such cases.
     `date' is a string containing an RFC 2822(2) date, such as  `"Mon,
     20 Nov 1995 19:12:08 -0500"'.  If it succeeds in parsing the date,
     *Note parsedate(): 18e7. returns a 9-tuple that can be passed
     directly to *Note time.mktime(): 1225.; otherwise `None' will be
     returned.  Note that indexes 6, 7, and 8 of the result tuple are
     not usable.

 -- Function: email.utils.parsedate_tz (date)
     Performs the same function as *Note parsedate(): 18e7, but returns
     either `None' or a 10-tuple; the first 9 elements make up a tuple
     that can be passed directly to *Note time.mktime(): 1225, and the
     tenth is the offset of the date’s timezone from UTC (which is
     the official term for Greenwich Mean Time) (3).  If the input
     string has no timezone, the last element of the tuple returned is
     `None'.  Note that indexes 6, 7, and 8 of the result tuple are not
     usable.

 -- Function: email.utils.mktime_tz (tuple)
     Turn a 10-tuple as returned by *Note parsedate_tz(): 18e8. into a
     UTC timestamp (seconds since the Epoch).  If the timezone item in
     the tuple is `None', assume local time.

 -- Function: email.utils.formatdate ([timeval[, localtime][, usegmt]])
     Returns a date string as per RFC 2822(4), e.g.:

         Fri, 09 Nov 2001 01:08:47 -0000

     Optional `timeval' if given is a floating point time value as
     accepted by *Note time.gmtime(): b7f. and *Note time.localtime():
     b19, otherwise the current time is used.

     Optional `localtime' is a flag that when `True', interprets
     `timeval', and returns a date relative to the local timezone
     instead of UTC, properly taking daylight savings time into
     account. The default is `False' meaning UTC is used.

     Optional `usegmt' is a flag that when `True', outputs a  date
     string with the timezone as an ascii string `GMT', rather than a
     numeric `-0000'. This is needed for some protocols (such as HTTP).
     This only applies when `localtime' is `False'.  The default is
     `False'.

     New in version 2.4.


 -- Function: email.utils.make_msgid ([idstring])
     Returns a string suitable for an RFC 2822(5)-compliant
     `Message-ID' header.  Optional `idstring' if given, is a string
     used to strengthen the uniqueness of the message id.

 -- Function: email.utils.decode_rfc2231 (s)
     Decode the string `s' according to RFC 2231(6).

 -- Function: email.utils.encode_rfc2231 (s[, charset[, language]])
     Encode the string `s' according to RFC 2231(7).  Optional
     `charset' and `language', if given is the character set name and
     language name to use.  If neither is given, `s' is returned as-is.
     If `charset' is given but `language' is not, the string is
     encoded using the empty string for `language'.

 -- Function: email.utils.collapse_rfc2231_value (value[, errors[,
          fallback_charset]])
     When a header parameter is encoded in RFC 2231(8) format, *Note
     Message.get_param: 1888. may return a 3-tuple containing the
     character set, language, and value.  *Note
     collapse_rfc2231_value(): 1889. turns this into a unicode string.
     Optional `errors' is passed to the `errors' argument of the
     built-in *Note unicode(): 1f5. function; it defaults to `replace'.
     Optional `fallback_charset' specifies the character set to use if
     the one in the RFC 2231(9) header is not known by Python; it
     defaults to `us-ascii'.

     For convenience, if the `value' passed to *Note
     collapse_rfc2231_value(): 1889. is not a tuple, it should be a
     string and it is returned unquoted.

 -- Function: email.utils.decode_params (params)
     Decode parameters list according to RFC 2231(10).  `params' is a
     sequence of 2-tuples containing elements of the form
     `(content-type, string-value)'.

Changed in version 2.4: The `dump_address_pair()' function has been
removed; use *Note formataddr(): 18e5.  instead.

Changed in version 2.4: The `decode()' function has been removed; use
the `Header.decode_header' method instead.

Changed in version 2.4: The `encode()' function has been removed; use
the *Note Header.encode: 18b9. method instead.

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2822.html

(2) https://tools.ietf.org/html/rfc2822.html

(3) Note that the sign of the timezone offset is the opposite of the
sign of the `time.timezone' variable for the same timezone; the latter
variable follows the POSIX standard while this module follows RFC 2822
(https://tools.ietf.org/html/rfc2822.html).

(4) https://tools.ietf.org/html/rfc2822.html

(5) https://tools.ietf.org/html/rfc2822.html

(6) https://tools.ietf.org/html/rfc2231.html

(7) https://tools.ietf.org/html/rfc2231.html

(8) https://tools.ietf.org/html/rfc2231.html

(9) https://tools.ietf.org/html/rfc2231.html

(10) https://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: email iterators Iterators,  Next: email Examples,  Prev: email utils Miscellaneous utilities,  Up: email — An email and MIME handling package

5.18.1.13 `email.iterators': Iterators
......................................

Iterating over a message object tree is fairly easy with the *Note
Message.walk: 1894. method.  The *Note email.iterators: c1. module
provides some useful higher level iterations over message object trees.

 -- Function: email.iterators.body_line_iterator (msg[, decode])
     This iterates over all the payloads in all the subparts of `msg',
     returning the string payloads line-by-line.  It skips over all the
     subpart headers, and it skips over any subpart with a payload that
     isn’t a Python string.  This is somewhat equivalent to reading
     the flat text representation of the message from a file using
     *Note readline(): 8b0, skipping over all the intervening headers.

     Optional `decode' is passed through to *Note Message.get_payload:
     1871.

 -- Function: email.iterators.typed_subpart_iterator (msg[, maintype[,
          subtype]])
     This iterates over all the subparts of `msg', returning only those
     subparts that match the MIME type specified by `maintype' and
     `subtype'.

     Note that `subtype' is optional; if omitted, then subpart MIME
     type matching is done only with the main type.  `maintype' is
     optional too; it defaults to `text'.

     Thus, by default *Note typed_subpart_iterator(): 18f2. returns
     each subpart that has a MIME type of `text/*'.

The following function has been added as a useful debugging tool.  It
should `not' be considered part of the supported public interface for
the package.

 -- Function: email.iterators._structure (msg[, fp[, level]])
     Prints an indented representation of the content types of the
     message object structure.  For example:

         >>> msg = email.message_from_file(somefile)
         >>> _structure(msg)
         multipart/mixed
             text/plain
             text/plain
             multipart/digest
                 message/rfc822
                     text/plain
                 message/rfc822
                     text/plain
                 message/rfc822
                     text/plain
                 message/rfc822
                     text/plain
                 message/rfc822
                     text/plain
             text/plain

     Optional `fp' is a file-like object to print the output to.  It
     must be suitable for Python’s extended print statement.  `level'
     is used internally.


File: python.info,  Node: email Examples,  Next: Package History,  Prev: email iterators Iterators,  Up: email — An email and MIME handling package

5.18.1.14 `email': Examples
...........................

Here are a few examples of how to use the *Note email: bb. package to
read, write, and send simple email messages, as well as more complex
MIME messages.

First, let’s see how to create and send a simple text message:

    # Import smtplib for the actual sending function
    import smtplib

    # Import the email modules we'll need
    from email.mime.text import MIMEText

    # Open a plain text file for reading.  For this example, assume that
    # the text file contains only ASCII characters.
    fp = open(textfile, 'rb')
    # Create a text/plain message
    msg = MIMEText(fp.read())
    fp.close()

    # me == the sender's email address
    # you == the recipient's email address
    msg['Subject'] = 'The contents of %s' % textfile
    msg['From'] = me
    msg['To'] = you

    # Send the message via our own SMTP server, but don't include the
    # envelope header.
    s = smtplib.SMTP('localhost')
    s.sendmail(me, [you], msg.as_string())
    s.quit()

And parsing RFC822 headers can easily be done by the parse(filename) or
parsestr(message_as_string) methods of the Parser() class:

    # Import the email modules we'll need
    from email.parser import Parser

    #  If the e-mail headers are in a file, uncomment this line:
    #headers = Parser().parse(open(messagefile, 'r'))

    #  Or for parsing headers in a string, use:
    headers = Parser().parsestr('From: <user@example.com>\n'
            'To: <someone_else@example.com>\n'
            'Subject: Test message\n'
            '\n'
            'Body would go here\n')

    #  Now the header items can be accessed as a dictionary:
    print 'To: %s' % headers['to']
    print 'From: %s' % headers['from']
    print 'Subject: %s' % headers['subject']

Here’s an example of how to send a MIME message containing a bunch of
family pictures that may be residing in a directory:

    # Import smtplib for the actual sending function
    import smtplib

    # Here are the email package modules we'll need
    from email.mime.image import MIMEImage
    from email.mime.multipart import MIMEMultipart

    COMMASPACE = ', '

    # Create the container (outer) email message.
    msg = MIMEMultipart()
    msg['Subject'] = 'Our family reunion'
    # me == the sender's email address
    # family = the list of all recipients' email addresses
    msg['From'] = me
    msg['To'] = COMMASPACE.join(family)
    msg.preamble = 'Our family reunion'

    # Assume we know that the image files are all in PNG format
    for file in pngfiles:
        # Open the files in binary mode.  Let the MIMEImage class automatically
        # guess the specific image type.
        fp = open(file, 'rb')
        img = MIMEImage(fp.read())
        fp.close()
        msg.attach(img)

    # Send the email via our own SMTP server.
    s = smtplib.SMTP('localhost')
    s.sendmail(me, family, msg.as_string())
    s.quit()

Here’s an example of how to send the entire contents of a directory
as an email message: (1)

    #!/usr/bin/env python

    """Send the contents of a directory as a MIME message."""

    import os
    import sys
    import smtplib
    # For guessing MIME type based on file name extension
    import mimetypes

    from optparse import OptionParser

    from email import encoders
    from email.message import Message
    from email.mime.audio import MIMEAudio
    from email.mime.base import MIMEBase
    from email.mime.image import MIMEImage
    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText

    COMMASPACE = ', '


    def main():
        parser = OptionParser(usage="""\
    Send the contents of a directory as a MIME message.

    Usage: %prog [options]

    Unless the -o option is given, the email is sent by forwarding to your local
    SMTP server, which then does the normal delivery process.  Your local machine
    must be running an SMTP server.
    """)
        parser.add_option('-d', '--directory',
                          type='string', action='store',
                          help="""Mail the contents of the specified directory,
                          otherwise use the current directory.  Only the regular
                          files in the directory are sent, and we don't recurse to
                          subdirectories.""")
        parser.add_option('-o', '--output',
                          type='string', action='store', metavar='FILE',
                          help="""Print the composed message to FILE instead of
                          sending the message to the SMTP server.""")
        parser.add_option('-s', '--sender',
                          type='string', action='store', metavar='SENDER',
                          help='The value of the From: header (required)')
        parser.add_option('-r', '--recipient',
                          type='string', action='append', metavar='RECIPIENT',
                          default=[], dest='recipients',
                          help='A To: header value (at least one required)')
        opts, args = parser.parse_args()
        if not opts.sender or not opts.recipients:
            parser.print_help()
            sys.exit(1)
        directory = opts.directory
        if not directory:
            directory = '.'
        # Create the enclosing (outer) message
        outer = MIMEMultipart()
        outer['Subject'] = 'Contents of directory %s' % os.path.abspath(directory)
        outer['To'] = COMMASPACE.join(opts.recipients)
        outer['From'] = opts.sender
        outer.preamble = 'You will not see this in a MIME-aware mail reader.\n'

        for filename in os.listdir(directory):
            path = os.path.join(directory, filename)
            if not os.path.isfile(path):
                continue
            # Guess the content type based on the file's extension.  Encoding
            # will be ignored, although we should check for simple things like
            # gzip'd or compressed files.
            ctype, encoding = mimetypes.guess_type(path)
            if ctype is None or encoding is not None:
                # No guess could be made, or the file is encoded (compressed), so
                # use a generic bag-of-bits type.
                ctype = 'application/octet-stream'
            maintype, subtype = ctype.split('/', 1)
            if maintype == 'text':
                fp = open(path)
                # Note: we should handle calculating the charset
                msg = MIMEText(fp.read(), _subtype=subtype)
                fp.close()
            elif maintype == 'image':
                fp = open(path, 'rb')
                msg = MIMEImage(fp.read(), _subtype=subtype)
                fp.close()
            elif maintype == 'audio':
                fp = open(path, 'rb')
                msg = MIMEAudio(fp.read(), _subtype=subtype)
                fp.close()
            else:
                fp = open(path, 'rb')
                msg = MIMEBase(maintype, subtype)
                msg.set_payload(fp.read())
                fp.close()
                # Encode the payload using Base64
                encoders.encode_base64(msg)
            # Set the filename parameter
            msg.add_header('Content-Disposition', 'attachment', filename=filename)
            outer.attach(msg)
        # Now send or store the message
        composed = outer.as_string()
        if opts.output:
            fp = open(opts.output, 'w')
            fp.write(composed)
            fp.close()
        else:
            s = smtplib.SMTP('localhost')
            s.sendmail(opts.sender, opts.recipients, composed)
            s.quit()


    if __name__ == '__main__':
        main()

Here’s an example of how to unpack a MIME message like the one above,
into a directory of files:

    #!/usr/bin/env python

    """Unpack a MIME message into a directory of files."""

    import os
    import sys
    import email
    import errno
    import mimetypes

    from optparse import OptionParser


    def main():
        parser = OptionParser(usage="""\
    Unpack a MIME message into a directory of files.

    Usage: %prog [options] msgfile
    """)
        parser.add_option('-d', '--directory',
                          type='string', action='store',
                          help="""Unpack the MIME message into the named
                          directory, which will be created if it doesn't already
                          exist.""")
        opts, args = parser.parse_args()
        if not opts.directory:
            parser.print_help()
            sys.exit(1)

        try:
            msgfile = args[0]
        except IndexError:
            parser.print_help()
            sys.exit(1)

        try:
            os.mkdir(opts.directory)
        except OSError as e:
            # Ignore directory exists error
            if e.errno != errno.EEXIST:
                raise

        fp = open(msgfile)
        msg = email.message_from_file(fp)
        fp.close()

        counter = 1
        for part in msg.walk():
            # multipart/* are just containers
            if part.get_content_maintype() == 'multipart':
                continue
            # Applications should really sanitize the given filename so that an
            # email message can't be used to overwrite important files
            filename = part.get_filename()
            if not filename:
                ext = mimetypes.guess_extension(part.get_content_type())
                if not ext:
                    # Use a generic bag-of-bits extension
                    ext = '.bin'
                filename = 'part-%03d%s' % (counter, ext)
            counter += 1
            fp = open(os.path.join(opts.directory, filename), 'wb')
            fp.write(part.get_payload(decode=True))
            fp.close()


    if __name__ == '__main__':
        main()

Here’s an example of how to create an HTML message with an
alternative plain text version: (2)

    #!/usr/bin/env python

    import smtplib

    from email.mime.multipart import MIMEMultipart
    from email.mime.text import MIMEText

    # me == my email address
    # you == recipient's email address
    me = "my@email.com"
    you = "your@email.com"

    # Create message container - the correct MIME type is multipart/alternative.
    msg = MIMEMultipart('alternative')
    msg['Subject'] = "Link"
    msg['From'] = me
    msg['To'] = you

    # Create the body of the message (a plain-text and an HTML version).
    text = "Hi!\nHow are you?\nHere is the link you wanted:\nhttps://www.python.org"
    html = """\
    <html>
      <head></head>
      <body>
        <p>Hi!<br>
           How are you?<br>
           Here is the <a href="https://www.python.org">link</a> you wanted.
        </p>
      </body>
    </html>
    """

    # Record the MIME types of both parts - text/plain and text/html.
    part1 = MIMEText(text, 'plain')
    part2 = MIMEText(html, 'html')

    # Attach parts into message container.
    # According to RFC 2046, the last part of a multipart message, in this case
    # the HTML message, is best and preferred.
    msg.attach(part1)
    msg.attach(part2)

    # Send the message via local SMTP server.
    s = smtplib.SMTP('localhost')
    # sendmail function takes 3 arguments: sender's address, recipient's address
    # and message to send - here it is sent as one string.
    s.sendmail(me, you, msg.as_string())
    s.quit()

See also
........

Module *Note smtplib: 15a.
     SMTP protocol client

Module *Note nntplib: 125.
     NNTP protocol client

---------- Footnotes ----------

(1) Thanks to Matthew Dixon Cowles for the original inspiration and
examples.

(2) Contributed by Martin Matejek.


File: python.info,  Node: Package History,  Next: Differences from mimelib,  Prev: email Examples,  Up: email — An email and MIME handling package

5.18.1.15 Package History
.........................

This table describes the release history of the email package,
corresponding to the version of Python that the package was released
with.  For purposes of this document, when you see a note about change
or added versions, these refer to the Python version the change was
made in, `not' the email package version.  This table also describes
the Python compatibility of each version of the package.

email version       distributed with                   compatible with
----------------------------------------------------------------------------------- 
`1.x'               Python 2.2.0 to Python 2.2.1       `no longer supported'
`2.5'               Python 2.2.2+ and Python 2.3       Python 2.1 to 2.5
`3.0'               Python 2.4                         Python 2.3 to 2.5
`4.0'               Python 2.5                         Python 2.3 to 2.5

Here are the major differences between *Note email: bb. version 4 and
version 3:

   * All modules have been renamed according to PEP 8(1) standards.
     For example, the version 3 module `email.Message' was renamed to
     *Note email.message: c2. in version 4.

   * A new subpackage *Note email.mime: c3. was added and all the
     version 3 `email.MIME*' modules were renamed and situated into the
     *Note email.mime: c3.  subpackage.  For example, the version 3
     module `email.MIMEText' was renamed to `email.mime.text'.

     `Note that the version 3 names will continue to work until Python
     2.6'.

   * The `email.mime.application' module was added, which contains the
     *Note MIMEApplication: 18b1. class.

   * Methods that were deprecated in version 3 have been removed.
     These include `Generator.__call__()', `Message.get_type()',
     `Message.get_main_type()', `Message.get_subtype()'.

   * Fixes have been added for RFC 2231(2) support which can change
     some of the return types for *Note Message.get_param: 1888.  and
     friends.  Under some circumstances, values which used to return a
     3-tuple now return simple strings (specifically, if all extended
     parameter segments were unencoded, there is no language and
     charset designation expected, so the return type is now a simple
     string).  Also, %-decoding used to be done for both encoded and
     unencoded segments; this decoding is now done only for encoded
     segments.

Here are the major differences between *Note email: bb. version 3 and
version 2:

   * The *Note FeedParser: 189b. class was introduced, and the *Note
     Parser: 1896. class was implemented in terms of the *Note
     FeedParser: 189b.  All parsing therefore is non-strict, and
     parsing will make a best effort never to raise an exception.
     Problems found while parsing messages are stored in the
     message’s `defect' attribute.

   * All aspects of the API which raised *Note DeprecationWarning:
     1bd.s in version 2 have been removed.  These include the
     `_encoder' argument to the *Note MIMEText: 18b5. constructor, the
     `Message.add_payload()' method, the `Utils.dump_address_pair()'
     function, and the functions `Utils.decode()' and `Utils.encode()'.

   * New *Note DeprecationWarning: 1bd.s have been added to:
     `Generator.__call__()', `Message.get_type()',
     `Message.get_main_type()', `Message.get_subtype()', and the
     `strict' argument to the *Note Parser: 1896. class.  These are
     expected to be removed in future versions.

   * Support for Pythons earlier than 2.3 has been removed.

Here are the differences between *Note email: bb. version 2 and version
1:

   * The `email.Header' and `email.Charset' modules have been added.

   * The pickle format for *Note Message: 216. instances has changed.
     Since this was never (and still isn’t) formally defined, this
     isn’t considered a backward incompatibility.  However if your
     application pickles and unpickles *Note Message: 216. instances,
     be aware that in *Note email: bb. version 2, *Note Message: 216.
     instances now have private variables `_charset' and
     `_default_type'.

   * Several methods in the *Note Message: 216. class have been
     deprecated, or their signatures changed.  Also, many new methods
     have been added.  See the documentation for the *Note Message:
     216. class for details.  The changes should be completely backward
     compatible.

   * The object structure has changed in the face of `message/rfc822'
     content types.  In *Note email: bb. version 1, such a type would
     be represented by a scalar payload, i.e. the container message’s
     *Note is_multipart(): 186c. returned false, *Note get_payload():
     1871. was not a list object, but a single *Note Message: 216.
     instance.

     This structure was inconsistent with the rest of the package, so
     the object representation for `message/rfc822' content types was
     changed.  In *Note email: bb. version 2, the container `does'
     return `True' from *Note is_multipart(): 186c, and *Note
     get_payload(): 1871. returns a list containing a single *Note
     Message: 216. item.

     Note that this is one place that backward compatibility could not
     be completely maintained.  However, if you’re already testing
     the return type of *Note get_payload(): 1871, you should be fine.
     You just need to make sure your code doesn’t do a *Note
     set_payload(): 1870.  with a *Note Message: 216. instance on a
     container with a content type of `message/rfc822'.

   * The *Note Parser: 1896. constructor’s `strict' argument was
     added, and its *Note parse(): 18a0. and *Note parsestr(): 18a1.
     methods grew a `headersonly' argument.  The `strict' flag was also
     added to functions *Note email.message_from_file(): 18a3.  and
     *Note email.message_from_string(): 18a2.

   * `Generator.__call__()' is deprecated; use *Note Generator.flatten:
     186a. instead.  The *Note Generator: 1869. class has also grown the
     *Note clone(): 18a9. method.

   * The *Note DecodedGenerator: 18aa. class in the *Note
     email.generator: bf. module was added.

   * The intermediate base classes *Note MIMENonMultipart: 18ae. and
     *Note MIMEMultipart: 18b0. have been added, and interposed in the
     class hierarchy for most of the other MIME-related derived classes.

   * The `_encoder' argument to the *Note MIMEText: 18b5. constructor
     has been deprecated.  Encoding  now happens implicitly based on the
     `_charset' argument.

   * The following functions in the `email.Utils' module have been
     deprecated: `dump_address_pairs()', `decode()', and `encode()'.
     The following functions have been added to the module:
     `make_msgid()', `decode_rfc2231()', `encode_rfc2231()', and
     `decode_params()'.

   * The non-public function `email.Iterators._structure()' was added.

---------- Footnotes ----------

(1) https://www.python.org/dev/peps/pep-0008

(2) https://tools.ietf.org/html/rfc2231.html


File: python.info,  Node: Differences from mimelib,  Prev: Package History,  Up: email — An email and MIME handling package

5.18.1.16 Differences from `mimelib'
....................................

The *Note email: bb. package was originally prototyped as a separate
library called mimelib(1). Changes have been made so that method names
are more consistent, and some methods or modules have either been added
or removed.  The semantics of some of the methods have also changed.
For the most part, any functionality available in `mimelib' is still
available in the *Note email: bb. package, albeit often in a different
way.  Backward compatibility between the `mimelib' package and the
*Note email: bb. package was not a priority.

Here is a brief description of the differences between the `mimelib' and
the *Note email: bb. packages, along with hints on how to port your
applications.

Of course, the most visible difference between the two packages is that
the package name has been changed to *Note email: bb.  In addition, the
top-level package has the following differences:

   * `messageFromString()' has been renamed to *Note
     message_from_string(): 18a2.

   * `messageFromFile()' has been renamed to *Note message_from_file():
     18a3.

The *Note Message: 216. class has the following differences:

   * The method `asString()' was renamed to *Note as_string(): 1868.

   * The method `ismultipart()' was renamed to *Note is_multipart():
     186c.

   * The *Note get_payload(): 1871. method has grown a `decode'
     optional argument.

   * The method `getall()' was renamed to *Note get_all(): 1879.

   * The method `addheader()' was renamed to *Note add_header(): 1880.

   * The method `gettype()' was renamed to `get_type()'.

   * The method `getmaintype()' was renamed to `get_main_type()'.

   * The method `getsubtype()' was renamed to `get_subtype()'.

   * The method `getparams()' was renamed to *Note get_params(): 1887.
     Also, whereas `getparams()' returned a list of strings, *Note
     get_params(): 1887. returns a list of 2-tuples, effectively the
     key/value pairs of the parameters, split on the `'='' sign.

   * The method `getparam()' was renamed to *Note get_param(): 1888.

   * The method `getcharsets()' was renamed to *Note get_charsets():
     1893.

   * The method `getfilename()' was renamed to *Note get_filename():
     188d.

   * The method `getboundary()' was renamed to *Note get_boundary():
     188f.

   * The method `setboundary()' was renamed to *Note set_boundary():
     1890.

   * The method `getdecodedpayload()' was removed.  To get similar
     functionality, pass the value 1 to the `decode' flag of the *Note
     get_payload(): 1871. method.

   * The method `getpayloadastext()' was removed.  Similar
     functionality is supported by the *Note DecodedGenerator: 18aa.
     class in the *Note email.generator: bf. module.

   * The method `getbodyastext()' was removed.  You can get similar
     functionality by creating an iterator with *Note
     typed_subpart_iterator(): 18f2. in the *Note email.iterators: c1.
     module.

The *Note Parser: 1896. class has no differences in its public
interface. It does have some additional smarts to recognize
`message/delivery-status' type messages, which it represents as a *Note
Message: 216. instance containing separate *Note Message: 216. subparts
for each header block in the delivery status notification (2).

The *Note Generator: 1869. class has no differences in its public
interface.  There is a new class in the *Note email.generator: bf.
module though, called *Note DecodedGenerator: 18aa. which provides most
of the functionality previously available in the
`Message.getpayloadastext()' method.

The following modules and classes have been changed:

   * The *Note MIMEBase: 18ad. class constructor arguments `_major' and
     `_minor' have changed to `_maintype' and `_subtype' respectively.

   * The `Image' class/module has been renamed to `MIMEImage'.  The
     `_minor' argument has been renamed to `_subtype'.

   * The `Text' class/module has been renamed to `MIMEText'.  The
     `_minor' argument has been renamed to `_subtype'.

   * The `MessageRFC822' class/module has been renamed to
     `MIMEMessage'.  Note that an earlier version of `mimelib' called
     this class/module `RFC822', but that clashed with the Python
     standard library module *Note rfc822: 148. on some
     case-insensitive file systems.

     Also, the *Note MIMEMessage: 18b4. class now represents any kind
     of MIME message with main type `message'.  It takes an optional
     argument `_subtype' which is used to set the MIME subtype.
     `_subtype' defaults to `rfc822'.

`mimelib' provided some utility functions in its `address' and `date'
modules.  All of these functions have been moved to the *Note
email.utils: c5. module.

The `MsgReader' class/module has been removed.  Its functionality is
most closely supported in the *Note body_line_iterator(): 18f1. function
in the *Note email.iterators: c1. module.

---------- Footnotes ----------

(1) http://mimelib.sourceforge.net/

(2) Delivery Status Notifications (DSN) are defined in RFC 1894
(https://tools.ietf.org/html/rfc1894.html).


File: python.info,  Node: json — JSON encoder and decoder,  Next: mailcap — Mailcap file handling,  Prev: email — An email and MIME handling package,  Up: Internet Data Handling

5.18.2 `json' — JSON encoder and decoder
------------------------------------------

New in version 2.6.

JSON (JavaScript Object Notation)(1), specified by RFC 7159(2) (which
obsoletes RFC 4627(3)) and by ECMA-404(4), is a lightweight data
interchange format inspired by JavaScript(5) object literal syntax
(although it is not a strict subset of JavaScript (6) ).

*Note json: fd. exposes an API familiar to users of the standard library
*Note marshal: 10c. and *Note pickle: 12e. modules.

Encoding basic Python object hierarchies:

    >>> import json
    >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
    '["foo", {"bar": ["baz", null, 1.0, 2]}]'
    >>> print json.dumps("\"foo\bar")
    "\"foo\bar"
    >>> print json.dumps(u'\u1234')
    "\u1234"
    >>> print json.dumps('\\')
    "\\"
    >>> print json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True)
    {"a": 0, "b": 0, "c": 0}
    >>> from StringIO import StringIO
    >>> io = StringIO()
    >>> json.dump(['streaming API'], io)
    >>> io.getvalue()
    '["streaming API"]'

Compact encoding:

    >>> import json
    >>> json.dumps([1,2,3,{'4': 5, '6': 7}], separators=(',',':'))
    '[1,2,3,{"4":5,"6":7}]'

Pretty printing:

    >>> import json
    >>> print json.dumps({'4': 5, '6': 7}, sort_keys=True,
    ...                  indent=4, separators=(',', ': '))
    {
        "4": 5,
        "6": 7
    }

Decoding JSON:

    >>> import json
    >>> json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]')
    [u'foo', {u'bar': [u'baz', None, 1.0, 2]}]
    >>> json.loads('"\\"foo\\bar"')
    u'"foo\x08ar'
    >>> from StringIO import StringIO
    >>> io = StringIO('["streaming API"]')
    >>> json.load(io)
    [u'streaming API']

Specializing JSON object decoding:

    >>> import json
    >>> def as_complex(dct):
    ...     if '__complex__' in dct:
    ...         return complex(dct['real'], dct['imag'])
    ...     return dct
    ...
    >>> json.loads('{"__complex__": true, "real": 1, "imag": 2}',
    ...     object_hook=as_complex)
    (1+2j)
    >>> import decimal
    >>> json.loads('1.1', parse_float=decimal.Decimal)
    Decimal('1.1')

Extending *Note JSONEncoder: 18fc.:

    >>> import json
    >>> class ComplexEncoder(json.JSONEncoder):
    ...     def default(self, obj):
    ...         if isinstance(obj, complex):
    ...             return [obj.real, obj.imag]
    ...         # Let the base class default method raise the TypeError
    ...         return json.JSONEncoder.default(self, obj)
    ...
    >>> dumps(2 + 1j, cls=ComplexEncoder)
    '[2.0, 1.0]'
    >>> ComplexEncoder().encode(2 + 1j)
    '[2.0, 1.0]'
    >>> list(ComplexEncoder().iterencode(2 + 1j))
    ['[', '2.0', ', ', '1.0', ']']

Using `json.tool' from the shell to validate and pretty-print:

    $ echo '{"json":"obj"}' | python -m json.tool
    {
        "json": "obj"
    }
    $ echo '{1.2:3.4}' | python -mjson.tool
    Expecting property name enclosed in double quotes: line 1 column 2 (char 1)

     Note: JSON is a subset of YAML(7) 1.2.  The JSON produced by this
     module’s default settings (in particular, the default
     `separators' value) is also a subset of YAML 1.0 and 1.1.  This
     module can thus also be used as a YAML serializer.

* Menu:

* Basic Usage::
* Encoders and Decoders::
* Standard Compliance and Interoperability::

---------- Footnotes ----------

(1) http://json.org

(2) https://tools.ietf.org/html/rfc7159.html

(3) https://tools.ietf.org/html/rfc4627.html

(4)
http://www.ecma-international.org/publications/standards/Ecma-404.htm

(5) https://en.wikipedia.org/wiki/JavaScript

(6) As noted in the errata for RFC 7159
(https://www.rfc-editor.org/errata_search.php?rfc=7159), JSON permits
literal U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR)
characters in strings, whereas JavaScript (as of ECMAScript Edition
5.1) does not.

(7) http://yaml.org/


File: python.info,  Node: Basic Usage,  Next: Encoders and Decoders,  Up: json — JSON encoder and decoder

5.18.2.1 Basic Usage
....................

 -- Function: json.dump (obj, fp, skipkeys=False, ensure_ascii=True,
          check_circular=True, allow_nan=True, cls=None, indent=None,
          separators=None, encoding="utf-8", default=None,
          sort_keys=False, **kw)
     Serialize `obj' as a JSON formatted stream to `fp' (a
     `.write()'-supporting *Note file-like object: 18fe.) using this
     *Note conversion table: 18ff.

     If `skipkeys' is true (default: `False'), then dict keys that are
     not of a basic type (*Note str: 1ea, *Note unicode: 1f5, *Note
     int: 1f2, *Note long: 1f3, *Note float: 1eb, *Note bool: 455,
     `None') will be skipped instead of raising a *Note TypeError: 218.

     If `ensure_ascii' is true (the default), all non-ASCII characters
     in the output are escaped with `\uXXXX' sequences, and the result
     is a *Note str: 1ea. instance consisting of ASCII characters only.
     If `ensure_ascii' is false, some chunks written to `fp' may be
     *Note unicode: 1f5. instances.  This usually happens because the
     input contains unicode strings or the `encoding' parameter is
     used.  Unless `fp.write()' explicitly understands *Note unicode:
     1f5. (as in *Note codecs.getwriter(): a82.)  this is likely to
     cause an error.

     If `check_circular' is false (default: `True'), then the circular
     reference check for container types will be skipped and a circular
     reference will result in an *Note OverflowError: 2dd. (or worse).

     If `allow_nan' is false (default: `True'), then it will be a *Note
     ValueError: 236. to serialize out of range *Note float: 1eb.
     values (`nan', `inf', `-inf') in strict compliance of the JSON
     specification.  If `allow_nan' is true, their JavaScript
     equivalents (`NaN', `Infinity', `-Infinity') will be used.

     If `indent' is a non-negative integer, then JSON array elements
     and object members will be pretty-printed with that indent level.
     An indent level of 0, or negative, will only insert newlines.
     `None' (the default) selects the most compact representation.

          Note: Since the default item separator is `', '',  the output
          might include trailing whitespace when `indent' is specified.
          You can use `separators=(',', ': ')' to avoid this.

     If specified, `separators' should be an `(item_separator,
     key_separator)' tuple.  By default, `(', ', ': ')' are used.  To
     get the most compact JSON representation, you should specify
     `(',', ':')' to eliminate whitespace.

     `encoding' is the character encoding for str instances, default is
     UTF-8.

     If specified, `default' should be a function that gets called for
     objects that can’t otherwise be serialized.  It should return a
     JSON encodable version of the object or raise a *Note TypeError:
     218.  If not specified, *Note TypeError: 218.  is raised.

     If `sort_keys' is true (default: `False'), then the output of
     dictionaries will be sorted by key.

     To use a custom *Note JSONEncoder: 18fc. subclass (e.g. one that
     overrides the `default()' method to serialize additional types),
     specify it with the `cls' kwarg; otherwise *Note JSONEncoder:
     18fc. is used.

          Note: Unlike *Note pickle: 12e. and *Note marshal: 10c, JSON
          is not a framed protocol so trying to serialize more objects
          with repeated calls to *Note dump(): 5be. and the same `fp'
          will result in an invalid JSON file.

 -- Function: json.dumps (obj, skipkeys=False, ensure_ascii=True,
          check_circular=True, allow_nan=True, cls=None, indent=None,
          separators=None, encoding="utf-8", default=None,
          sort_keys=False, **kw)
     Serialize `obj' to a JSON formatted *Note str: 1ea. using this
     *Note conversion table: 18ff.  If `ensure_ascii' is false, the
     result may contain non-ASCII characters and the return value may
     be a *Note unicode: 1f5.  instance.

     The arguments have the same meaning as in *Note dump(): 5be.

          Note: Keys in key/value pairs of JSON are always of the type
          *Note str: 1ea. When a dictionary is converted into JSON, all
          the keys of the dictionary are coerced to strings. As a
          result of this, if a dictionary is converted into JSON and
          then back into a dictionary, the dictionary may not equal the
          original one. That is, `loads(dumps(x)) != x' if x has
          non-string keys.

 -- Function: json.load (fp[, encoding[, cls[, object_hook[,
          parse_float[, parse_int[, parse_constant[,
          object_pairs_hook[, **kw]]]]]]]])
     Deserialize `fp' (a `.read()'-supporting *Note file-like object:
     18fe.  containing a JSON document) to a Python object using this
     *Note conversion table: 1900.

     If the contents of `fp' are encoded with an ASCII based encoding
     other than UTF-8 (e.g. latin-1), then an appropriate `encoding'
     name must be specified.  Encodings that are not ASCII based (such
     as UCS-2) are not allowed, and should be wrapped with
     `codecs.getreader(encoding)(fp)', or simply decoded to a *Note
     unicode: 1f5. object and passed to *Note loads(): 1901.

     `object_hook' is an optional function that will be called with the
     result of any object literal decoded (a *Note dict: 319.).  The
     return value of `object_hook' will be used instead of the *Note
     dict: 319.  This feature can be used to implement custom decoders
     (e.g. JSON-RPC(1) class hinting).

     `object_pairs_hook' is an optional function that will be called
     with the result of any object literal decoded with an ordered list
     of pairs.  The return value of `object_pairs_hook' will be used
     instead of the *Note dict: 319.  This feature can be used to
     implement custom decoders that rely on the order that the key and
     value pairs are decoded (for example, *Note
     collections.OrderedDict(): 1b6. will remember the order of
     insertion). If `object_hook' is also defined, the
     `object_pairs_hook' takes priority.

     Changed in version 2.7: Added support for `object_pairs_hook'.

     `parse_float', if specified, will be called with the string of
     every JSON float to be decoded.  By default, this is equivalent to
     `float(num_str)'.  This can be used to use another datatype or
     parser for JSON floats (e.g. *Note decimal.Decimal: 1b5.).

     `parse_int', if specified, will be called with the string of every
     JSON int to be decoded.  By default, this is equivalent to
     `int(num_str)'.  This can be used to use another datatype or
     parser for JSON integers (e.g. *Note float: 1eb.).

     `parse_constant', if specified, will be called with one of the
     following strings: `'-Infinity'', `'Infinity'', `'NaN''.  This can
     be used to raise an exception if invalid JSON numbers are
     encountered.

     Changed in version 2.7: `parse_constant' doesn’t get called on
     ‘null’, ‘true’, ‘false’ anymore.

     To use a custom *Note JSONDecoder: 1d2. subclass, specify it with
     the `cls' kwarg; otherwise *Note JSONDecoder: 1d2. is used.
     Additional keyword arguments will be passed to the constructor of
     the class.

 -- Function: json.loads (s[, encoding[, cls[, object_hook[,
          parse_float[, parse_int[, parse_constant[,
          object_pairs_hook[, **kw]]]]]]]])
     Deserialize `s' (a *Note str: 1ea. or *Note unicode: 1f5. instance
     containing a JSON document) to a Python object using this *Note
     conversion table: 1900.

     If `s' is a *Note str: 1ea. instance and is encoded with an ASCII
     based encoding other than UTF-8 (e.g. latin-1), then an
     appropriate `encoding' name must be specified.  Encodings that are
     not ASCII based (such as UCS-2) are not allowed and should be
     decoded to *Note unicode: 1f5. first.

     The other arguments have the same meaning as in *Note load(): 237.

---------- Footnotes ----------

(1) http://www.jsonrpc.org


File: python.info,  Node: Encoders and Decoders,  Next: Standard Compliance and Interoperability,  Prev: Basic Usage,  Up: json — JSON encoder and decoder

5.18.2.2 Encoders and Decoders
..............................

 -- Class: json.JSONDecoder ([encoding[, object_hook[, parse_float[,
          parse_int[, parse_constant[, strict[,
          object_pairs_hook]]]]]]])
     Simple JSON decoder.

     Performs the following translations in decoding by default:

     JSON                Python
     -------------------------------------------- 
     object              dict
     array               list
     string              unicode
     number (int)        int, long
     number (real)       float
     true                True
     false               False
     null                None

     It also understands `NaN', `Infinity', and `-Infinity' as their
     corresponding `float' values, which is outside the JSON spec.

     `encoding' determines the encoding used to interpret any *Note
     str: 1ea. objects decoded by this instance (UTF-8 by default).  It
     has no effect when decoding *Note unicode: 1f5. objects.

     Note that currently only encodings that are a superset of ASCII
     work, strings of other encodings should be passed in as *Note
     unicode: 1f5.

     `object_hook', if specified, will be called with the result of
     every JSON object decoded and its return value will be used in
     place of the given *Note dict: 319.  This can be used to provide
     custom deserializations (e.g. to support JSON-RPC class hinting).

     `object_pairs_hook', if specified will be called with the result
     of every JSON object decoded with an ordered list of pairs.  The
     return value of `object_pairs_hook' will be used instead of the
     *Note dict: 319.  This feature can be used to implement custom
     decoders that rely on the order that the key and value pairs are
     decoded (for example, *Note collections.OrderedDict(): 1b6. will
     remember the order of insertion). If `object_hook' is also
     defined, the `object_pairs_hook' takes priority.

     Changed in version 2.7: Added support for `object_pairs_hook'.

     `parse_float', if specified, will be called with the string of
     every JSON float to be decoded.  By default, this is equivalent to
     `float(num_str)'.  This can be used to use another datatype or
     parser for JSON floats (e.g. *Note decimal.Decimal: 1b5.).

     `parse_int', if specified, will be called with the string of every
     JSON int to be decoded.  By default, this is equivalent to
     `int(num_str)'.  This can be used to use another datatype or
     parser for JSON integers (e.g. *Note float: 1eb.).

     `parse_constant', if specified, will be called with one of the
     following strings: `'-Infinity'', `'Infinity'', `'NaN''.  This can
     be used to raise an exception if invalid JSON numbers are
     encountered.

     If `strict' is false (`True' is the default), then control
     characters will be allowed inside strings.  Control characters in
     this context are those with character codes in the 0–31 range,
     including `'\t'' (tab), `'\n'', `'\r'' and `'\0''.

     If the data being deserialized is not a valid JSON document, a
     *Note ValueError: 236. will be raised.

      -- Method: decode (s)
          Return the Python representation of `s' (a *Note str: 1ea. or
          *Note unicode: 1f5. instance containing a JSON document).

      -- Method: raw_decode (s)
          Decode a JSON document from `s' (a *Note str: 1ea. or *Note
          unicode: 1f5.  beginning with a JSON document) and return a
          2-tuple of the Python representation and the index in `s'
          where the document ended.

          This can be used to decode a JSON document from a string that
          may have extraneous data at the end.

 -- Class: json.JSONEncoder ([skipkeys[, ensure_ascii[,
          check_circular[, allow_nan[, sort_keys[, indent[,
          separators[, encoding[, default]]]]]]]]])
     Extensible JSON encoder for Python data structures.

     Supports the following objects and types by default:

     Python                  JSON
     -------------------------------------------- 
     dict                    object
     list, tuple             array
     str, unicode            string
     int, long, float        number
     True                    true
     False                   false
     None                    null

     To extend this to recognize other objects, subclass and implement a
     *Note default(): 1905. method with another method that returns a
     serializable object for `o' if possible, otherwise it should call
     the superclass implementation (to raise *Note TypeError: 218.).

     If `skipkeys' is false (the default), then it is a *Note
     TypeError: 218. to attempt encoding of keys that are not str, int,
     long, float or `None'.  If `skipkeys' is true, such items are
     simply skipped.

     If `ensure_ascii' is true (the default), all non-ASCII characters
     in the output are escaped with `\uXXXX' sequences, and the results
     are *Note str: 1ea. instances consisting of ASCII characters only.
     If `ensure_ascii' is false, a result may be a *Note unicode: 1f5.
     instance. This usually happens if the input contains unicode
     strings or the `encoding' parameter is used.

     If `check_circular' is true (the default), then lists, dicts, and
     custom encoded objects will be checked for circular references
     during encoding to prevent an infinite recursion (which would
     cause an *Note OverflowError: 2dd.).  Otherwise, no such check
     takes place.

     If `allow_nan' is true (the default), then `NaN', `Infinity', and
     `-Infinity' will be encoded as such.  This behavior is not JSON
     specification compliant, but is consistent with most JavaScript
     based encoders and decoders.  Otherwise, it will be a *Note
     ValueError: 236. to encode such floats.

     If `sort_keys' is true (default: `False'), then the output of
     dictionaries will be sorted by key; this is useful for regression
     tests to ensure that JSON serializations can be compared on a
     day-to-day basis.

     If `indent' is a non-negative integer (it is `None' by default),
     then JSON array elements and object members will be pretty-printed
     with that indent level.  An indent level of 0 will only insert
     newlines.  `None' is the most compact representation.

          Note: Since the default item separator is `', '',  the output
          might include trailing whitespace when `indent' is specified.
          You can use `separators=(',', ': ')' to avoid this.

     If specified, `separators' should be an `(item_separator,
     key_separator)' tuple.  By default, `(', ', ': ')' are used.  To
     get the most compact JSON representation, you should specify
     `(',', ':')' to eliminate whitespace.

     If specified, `default' should be a function that gets called for
     objects that can’t otherwise be serialized.  It should return a
     JSON encodable version of the object or raise a *Note TypeError:
     218.  If not specified, *Note TypeError: 218.  is raised.

     If `encoding' is not `None', then all input strings will be
     transformed into unicode using that encoding prior to
     JSON-encoding.  The default is UTF-8.

      -- Method: default (o)
          Implement this method in a subclass such that it returns a
          serializable object for `o', or calls the base implementation
          (to raise a *Note TypeError: 218.).

          For example, to support arbitrary iterators, you could
          implement default like this:

              def default(self, o):
                 try:
                     iterable = iter(o)
                 except TypeError:
                     pass
                 else:
                     return list(iterable)
                 # Let the base class default method raise the TypeError
                 return JSONEncoder.default(self, o)

      -- Method: encode (o)
          Return a JSON string representation of a Python data
          structure, `o'.  For example:

              >>> JSONEncoder().encode({"foo": ["bar", "baz"]})
              '{"foo": ["bar", "baz"]}'

      -- Method: iterencode (o)
          Encode the given object, `o', and yield each string
          representation as available.  For example:

              for chunk in JSONEncoder().iterencode(bigobject):
                  mysocket.write(chunk)


File: python.info,  Node: Standard Compliance and Interoperability,  Prev: Encoders and Decoders,  Up: json — JSON encoder and decoder

5.18.2.3 Standard Compliance and Interoperability
.................................................

The JSON format is specified by RFC 7159(1) and by ECMA-404(2).  This
section details this module’s level of compliance with the RFC.  For
simplicity, *Note JSONEncoder: 18fc. and *Note JSONDecoder: 1d2.
subclasses, and parameters other than those explicitly mentioned, are
not considered.

This module does not comply with the RFC in a strict fashion,
implementing some extensions that are valid JavaScript but not valid
JSON.  In particular:

   - Infinite and NaN number values are accepted and output;

   - Repeated names within an object are accepted, and only the value
     of the last name-value pair is used.

Since the RFC permits RFC-compliant parsers to accept input texts that
are not RFC-compliant, this module’s deserializer is technically
RFC-compliant under default settings.

* Menu:

* Character Encodings::
* Infinite and NaN Number Values::
* Repeated Names Within an Object::
* Top-level Non-Object, Non-Array Values: Top-level Non-Object Non-Array Values.
* Implementation Limitations::

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc7159.html

(2)
http://www.ecma-international.org/publications/standards/Ecma-404.htm


File: python.info,  Node: Character Encodings,  Next: Infinite and NaN Number Values,  Up: Standard Compliance and Interoperability

5.18.2.4 Character Encodings
............................

The RFC requires that JSON be represented using either UTF-8, UTF-16, or
UTF-32, with UTF-8 being the recommended default for maximum
interoperability.  Accordingly, this module uses UTF-8 as the default
for its `encoding' parameter.

This module’s deserializer only directly works with ASCII-compatible
encodings; UTF-16, UTF-32, and other ASCII-incompatible encodings
require the use of workarounds described in the documentation for the
deserializer’s `encoding' parameter.

As permitted, though not required, by the RFC, this module’s
serializer sets `ensure_ascii=True' by default, thus escaping the
output so that the resulting strings only contain ASCII characters.

The RFC prohibits adding a byte order mark (BOM) to the start of a JSON
text, and this module’s serializer does not add a BOM to its output.
The RFC permits, but does not require, JSON deserializers to ignore an
initial BOM in their input.  This module’s deserializer raises a
*Note ValueError: 236.  when an initial BOM is present.

The RFC does not explicitly forbid JSON strings which contain byte
sequences that don’t correspond to valid Unicode characters (e.g.
unpaired UTF-16 surrogates), but it does note that they may cause
interoperability problems.  By default, this module accepts and outputs
(when present in the original *Note str: 1ea.) code points for such
sequences.


File: python.info,  Node: Infinite and NaN Number Values,  Next: Repeated Names Within an Object,  Prev: Character Encodings,  Up: Standard Compliance and Interoperability

5.18.2.5 Infinite and NaN Number Values
.......................................

The RFC does not permit the representation of infinite or NaN number
values.  Despite that, by default, this module accepts and outputs
`Infinity', `-Infinity', and `NaN' as if they were valid JSON number
literal values:

    >>> # Neither of these calls raises an exception, but the results are not valid JSON
    >>> json.dumps(float('-inf'))
    '-Infinity'
    >>> json.dumps(float('nan'))
    'NaN'
    >>> # Same when deserializing
    >>> json.loads('-Infinity')
    -inf
    >>> json.loads('NaN')
    nan

In the serializer, the `allow_nan' parameter can be used to alter this
behavior.  In the deserializer, the `parse_constant' parameter can be
used to alter this behavior.


File: python.info,  Node: Repeated Names Within an Object,  Next: Top-level Non-Object Non-Array Values,  Prev: Infinite and NaN Number Values,  Up: Standard Compliance and Interoperability

5.18.2.6 Repeated Names Within an Object
........................................

The RFC specifies that the names within a JSON object should be unique,
but does not mandate how repeated names in JSON objects should be
handled.  By default, this module does not raise an exception; instead,
it ignores all but the last name-value pair for a given name:

    >>> weird_json = '{"x": 1, "x": 2, "x": 3}'
    >>> json.loads(weird_json)
    {u'x': 3}

The `object_pairs_hook' parameter can be used to alter this behavior.


File: python.info,  Node: Top-level Non-Object Non-Array Values,  Next: Implementation Limitations,  Prev: Repeated Names Within an Object,  Up: Standard Compliance and Interoperability

5.18.2.7 Top-level Non-Object, Non-Array Values
...............................................

The old version of JSON specified by the obsolete RFC 4627(1) required
that the top-level value of a JSON text must be either a JSON object or
array (Python *Note dict: 319. or *Note list: 3d6.), and could not be a
JSON null, boolean, number, or string value.  RFC 7159(2) removed that
restriction, and this module does not and has never implemented that
restriction in either its serializer or its deserializer.

Regardless, for maximum interoperability, you may wish to voluntarily
adhere to the restriction yourself.

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc4627.html

(2) https://tools.ietf.org/html/rfc7159.html


File: python.info,  Node: Implementation Limitations,  Prev: Top-level Non-Object Non-Array Values,  Up: Standard Compliance and Interoperability

5.18.2.8 Implementation Limitations
...................................

Some JSON deserializer implementations may set limits on:

   * the size of accepted JSON texts

   * the maximum level of nesting of JSON objects and arrays

   * the range and precision of JSON numbers

   * the content and maximum length of JSON strings

This module does not impose any such limits beyond those of the relevant
Python datatypes themselves or the Python interpreter itself.

When serializing to JSON, beware any such limitations in applications
that may consume your JSON.  In particular, it is common for JSON
numbers to be deserialized into IEEE 754 double precision numbers and
thus subject to that representation’s range and precision
limitations.  This is especially relevant when serializing Python *Note
int: 1f2. values of extremely large magnitude, or when serializing
instances of “exotic” numerical types such as *Note
decimal.Decimal: 1b5.


File: python.info,  Node: mailcap — Mailcap file handling,  Next: mailbox — Manipulate mailboxes in various formats,  Prev: json — JSON encoder and decoder,  Up: Internet Data Handling

5.18.3 `mailcap' — Mailcap file handling
------------------------------------------

`Source code:' Lib/mailcap.py(1)

__________________________________________________________________

Mailcap files are used to configure how MIME-aware applications such as
mail readers and Web browsers react to files with different MIME types.
(The name “mailcap” is derived from the phrase “mail
capability”.)  For example, a mailcap file might contain a line like
`video/mpeg; xmpeg %s'.  Then, if the user encounters an email message
or Web document with the MIME type `video/mpeg', `%s' will be replaced
by a filename (usually one belonging to a temporary file) and the
`xmpeg' program can be automatically started to view the file.

The mailcap format is documented in RFC 1524(2), “A User Agent
Configuration Mechanism For Multimedia Mail Format Information,” but
is not an Internet standard.  However, mailcap files are supported on
most Unix systems.

 -- Function: mailcap.findmatch (caps, MIMEtype[, key[, filename[,
          plist]]])
     Return a 2-tuple; the first element is a string containing the
     command line to be executed (which can be passed to *Note
     os.system(): 413.), and the second element is the mailcap entry
     for a given MIME type.  If no matching MIME type can be found,
     `(None, None)' is returned.

     `key' is the name of the field desired, which represents the type
     of activity to be performed; the default value is ‘view’,
     since in the  most common case you simply want to view the body of
     the MIME-typed data.  Other possible values might be ‘compose’
     and ‘edit’, if you wanted to create a new body of the given
     MIME type or alter the existing body data.  See RFC 1524(3) for a
     complete list of these fields.

     `filename' is the filename to be substituted for `%s' in the
     command line; the default value is `'/dev/null'' which is almost
     certainly not what you want, so usually you’ll override it by
     specifying a filename.

     `plist' can be a list containing named parameters; the default
     value is simply an empty list.  Each entry in the list must be a
     string containing the parameter name, an equals sign (`'=''), and
     the parameter’s value.  Mailcap entries can contain  named
     parameters like `%{foo}', which will be replaced by the value of
     the parameter named ‘foo’.  For example, if the command line
     `showpartial %{id} %{number} %{total}' was in a mailcap file, and
     `plist' was set to `['id=1', 'number=2', 'total=3']', the
     resulting command line would be `'showpartial 1 2 3''.

     In a mailcap file, the “test” field can optionally be
     specified to test some external condition (such as the machine
     architecture, or the window system in use) to determine whether or
     not the mailcap line applies.  *Note findmatch(): 1910.  will
     automatically check such conditions and skip the entry if the
     check fails.

 -- Function: mailcap.getcaps ()
     Returns a dictionary mapping MIME types to a list of mailcap file
     entries. This dictionary must be passed to the *Note findmatch():
     1910. function.  An entry is stored as a list of dictionaries, but
     it shouldn’t be necessary to know the details of this
     representation.

     The information is derived from all of the mailcap files found on
     the system.  Settings in the user’s mailcap file
     `$HOME/.mailcap' will override settings in the system mailcap
     files `/etc/mailcap', `/usr/etc/mailcap', and
     `/usr/local/etc/mailcap'.

An example usage:

    >>> import mailcap
    >>> d = mailcap.getcaps()
    >>> mailcap.findmatch(d, 'video/mpeg', filename='tmp1223')
    ('xmpeg tmp1223', {'view': 'xmpeg %s'})

---------- Footnotes ----------

(1) https://hg.python.org/cpython/file/2.7/Lib/mailcap.py

(2) https://tools.ietf.org/html/rfc1524.html

(3) https://tools.ietf.org/html/rfc1524.html


File: python.info,  Node: mailbox — Manipulate mailboxes in various formats,  Next: mhlib — Access to MH mailboxes,  Prev: mailcap — Mailcap file handling,  Up: Internet Data Handling

5.18.4 `mailbox' — Manipulate mailboxes in various formats
------------------------------------------------------------

This module defines two classes, *Note Mailbox: 1914. and *Note
Message: 1915, for accessing and manipulating on-disk mailboxes and the
messages they contain.  *Note Mailbox: 1914. offers a dictionary-like
mapping from keys to messages.  *Note Message: 1915. extends the *Note
email.message: c2. module’s *Note Message: 216. class with
format-specific state and behavior.  Supported mailbox formats are
Maildir, mbox, MH, Babyl, and MMDF.

See also
........

Module *Note email: bb.
     Represent and manipulate messages.

* Menu:

* Mailbox objects::
* Message objects::
* Exceptions: Exceptions<5>.
* Deprecated classes and methods::
* Examples: Examples<9>.


File: python.info,  Node: Mailbox objects,  Next: Message objects,  Up: mailbox — Manipulate mailboxes in various formats

5.18.4.1 `Mailbox' objects
..........................

 -- Class: mailbox.Mailbox
     A mailbox, which may be inspected and modified.

     The *Note Mailbox: 1914. class defines an interface and is not
     intended to be instantiated.  Instead, format-specific subclasses
     should inherit from *Note Mailbox: 1914. and your code should
     instantiate a particular subclass.

     The *Note Mailbox: 1914. interface is dictionary-like, with small
     keys corresponding to messages. Keys are issued by the *Note
     Mailbox: 1914. instance with which they will be used and are only
     meaningful to that *Note Mailbox: 1914.  instance. A key continues
     to identify a message even if the corresponding message is
     modified, such as by replacing it with another message.

     Messages may be added to a *Note Mailbox: 1914. instance using the
     set-like method *Note add(): 1918. and removed using a `del'
     statement or the set-like methods *Note remove(): 1919. and *Note
     discard(): 191a.

     *Note Mailbox: 1914. interface semantics differ from dictionary
     semantics in some noteworthy ways. Each time a message is
     requested, a new representation (typically a *Note Message: 1915.
     instance) is generated based upon the current state of the
     mailbox. Similarly, when a message is added to a *Note Mailbox:
     1914. instance, the provided message representation’s contents
     are copied. In neither case is a reference to the message
     representation kept by the *Note Mailbox: 1914. instance.

     The default *Note Mailbox: 1914. iterator iterates over message
     representations, not keys as the default dictionary iterator does.
     Moreover, modification of a mailbox during iteration is safe and
     well-defined. Messages added to the mailbox after an iterator is
     created will not be seen by the iterator. Messages removed from
     the mailbox before the iterator yields them will be silently
     skipped, though using a key from an iterator may result in a *Note
     KeyError: 205. exception if the corresponding message is
     subsequently removed.

          Warning: Be very cautious when modifying mailboxes that might
          be simultaneously changed by some other process.  The safest
          mailbox format to use for such tasks is Maildir; try to avoid
          using single-file formats such as mbox for concurrent
          writing.  If you’re modifying a mailbox, you `must' lock it
          by calling the *Note lock(): 191b. and *Note unlock(): 191c.
          methods `before' reading any messages in the file or making
          any changes by adding or deleting a message.  Failing to lock
          the mailbox runs the risk of losing messages or corrupting
          the entire mailbox.

     *Note Mailbox: 1914. instances have the following methods:

      -- Method: add (message)
          Add `message' to the mailbox and return the key that has been
          assigned to it.

          Parameter `message' may be a *Note Message: 1915. instance, an
          *Note email.message.Message: 216. instance, a string, or a
          file-like object (which should be open in text mode). If
          `message' is an instance of the appropriate format-specific
          *Note Message: 1915. subclass (e.g., if it’s an *Note
          mboxMessage: 191d. instance and this is an *Note mbox: 191e.
          instance), its format-specific information is used.
          Otherwise, reasonable defaults for format-specific
          information are used.

      -- Method: remove (key)
      -- Method: __delitem__ (key)
      -- Method: discard (key)
          Delete the message corresponding to `key' from the mailbox.

          If no such message exists, a *Note KeyError: 205. exception
          is raised if the method was called as *Note remove(): 1919.
          or *Note __delitem__(): 191f. but no exception is raised if
          the method was called as *Note discard(): 191a. The behavior
          of *Note discard(): 191a. may be preferred if the underlying
          mailbox format supports concurrent modification by other
          processes.

      -- Method: __setitem__ (key, message)
          Replace the message corresponding to `key' with `message'.
          Raise a *Note KeyError: 205. exception if no message already
          corresponds to `key'.

          As with *Note add(): 1918, parameter `message' may be a *Note
          Message: 1915.  instance, an *Note email.message.Message:
          216. instance, a string, or a file-like object (which should
          be open in text mode). If `message' is an instance of the
          appropriate format-specific *Note Message: 1915. subclass
          (e.g., if it’s an *Note mboxMessage: 191d. instance and
          this is an *Note mbox: 191e. instance), its format-specific
          information is used. Otherwise, the format-specific
          information of the message that currently corresponds to
          `key' is left unchanged.

      -- Method: iterkeys ()
      -- Method: keys ()
          Return an iterator over all keys if called as *Note
          iterkeys(): 1921. or return a list of keys if called as *Note
          keys(): 1922.

      -- Method: itervalues ()
      -- Method: __iter__ ()
      -- Method: values ()
          Return an iterator over representations of all messages if
          called as *Note itervalues(): 1923. or *Note __iter__():
          1924. or return a list of such representations if called as
          *Note values(): 1925. The messages are represented as
          instances of the appropriate format-specific *Note Message:
          1915. subclass unless a custom message factory was specified
          when the *Note Mailbox: 1914.  instance was initialized.

               Note: The behavior of *Note __iter__(): 1924. is unlike
               that of dictionaries, which iterate over keys.

      -- Method: iteritems ()
      -- Method: items ()
          Return an iterator over (`key', `message') pairs, where `key'
          is a key and `message' is a message representation, if called
          as *Note iteritems(): 1926. or return a list of such pairs if
          called as *Note items(): 1927. The messages are represented
          as instances of the appropriate format-specific *Note
          Message: 1915. subclass unless a custom message factory was
          specified when the *Note Mailbox: 1914. instance was
          initialized.

      -- Method: get (key, default=None)
      -- Method: __getitem__ (key)
          Return a representation of the message corresponding to
          `key'. If no such message exists, `default' is returned if
          the method was called as *Note get(): 1928. and a *Note
          KeyError: 205. exception is raised if the method was called
          as *Note __getitem__(): 1929. The message is represented as
          an instance of the appropriate format-specific *Note Message:
          1915. subclass unless a custom message factory was specified
          when the *Note Mailbox: 1914. instance was initialized.

      -- Method: get_message (key)
          Return a representation of the message corresponding to `key'
          as an instance of the appropriate format-specific *Note
          Message: 1915. subclass, or raise a *Note KeyError: 205.
          exception if no such message exists.

      -- Method: get_string (key)
          Return a string representation of the message corresponding
          to `key', or raise a *Note KeyError: 205. exception if no
          such message exists.

      -- Method: get_file (key)
          Return a file-like representation of the message
          corresponding to `key', or raise a *Note KeyError: 205.
          exception if no such message exists. The file-like object
          behaves as if open in binary mode. This file should be closed
          once it is no longer needed.

               Note: Unlike other representations of messages,
               file-like representations are not necessarily
               independent of the *Note Mailbox: 1914. instance that
               created them or of the underlying mailbox. More specific
               documentation is provided by each subclass.

      -- Method: has_key (key)
      -- Method: __contains__ (key)
          Return `True' if `key' corresponds to a message, `False'
          otherwise.

      -- Method: __len__ ()
          Return a count of messages in the mailbox.

      -- Method: clear ()
          Delete all messages from the mailbox.

      -- Method: pop (key[, default])
          Return a representation of the message corresponding to `key'
          and delete the message. If no such message exists, return
          `default' if it was supplied or else raise a *Note KeyError:
          205. exception. The message is represented as an instance of
          the appropriate format-specific *Note Message: 1915. subclass
          unless a custom message factory was specified when the *Note
          Mailbox: 1914. instance was initialized.

      -- Method: popitem ()
          Return an arbitrary (`key', `message') pair, where `key' is a
          key and `message' is a message representation, and delete the
          corresponding message. If the mailbox is empty, raise a *Note
          KeyError: 205. exception. The message is represented as an
          instance of the appropriate format-specific *Note Message:
          1915. subclass unless a custom message factory was specified
          when the *Note Mailbox: 1914. instance was initialized.

      -- Method: update (arg)
          Parameter `arg' should be a `key'-to-`message' mapping or an
          iterable of (`key', `message') pairs. Updates the mailbox so
          that, for each given `key' and `message', the message
          corresponding to `key' is set to `message' as if by using
          *Note __setitem__(): 1920. As with *Note __setitem__(): 1920,
          each `key' must already correspond to a message in the
          mailbox or else a *Note KeyError: 205. exception will be
          raised, so in general it is incorrect for `arg' to be a *Note
          Mailbox: 1914. instance.

               Note: Unlike with dictionaries, keyword arguments are
               not supported.

      -- Method: flush ()
          Write any pending changes to the filesystem. For some *Note
          Mailbox: 1914.  subclasses, changes are always written
          immediately and *Note flush(): 1934. does nothing, but you
          should still make a habit of calling this method.

      -- Method: lock ()
          Acquire an exclusive advisory lock on the mailbox so that
          other processes know not to modify it. An *Note
          ExternalClashError: 1935. is raised if the lock is not
          available. The particular locking mechanisms used depend upon
          the mailbox format.  You should `always' lock the mailbox
          before making any modifications to its contents.

      -- Method: unlock ()
          Release the lock on the mailbox, if any.

      -- Method: close ()
          Flush the mailbox, unlock it if necessary, and close any open
          files. For some *Note Mailbox: 1914. subclasses, this method
          does nothing.

* Menu:

* Maildir::
* mbox::
* MH::
* Babyl::
* MMDF::


File: python.info,  Node: Maildir,  Next: mbox,  Up: Mailbox objects

5.18.4.2 `Maildir'
..................

 -- Class: mailbox.Maildir (dirname, factory=rfc822.Message,
          create=True)
     A subclass of *Note Mailbox: 1914. for mailboxes in Maildir
     format. Parameter `factory' is a callable object that accepts a
     file-like message representation (which behaves as if opened in
     binary mode) and returns a custom representation.  If `factory' is
     `None', *Note MaildirMessage: 1939. is used as the default message
     representation. If `create' is `True', the mailbox is created if
     it does not exist.

     It is for historical reasons that `factory' defaults to *Note
     rfc822.Message: 193a.  and that `dirname' is named as such rather
     than `path'. For a *Note Maildir: 238.  instance that behaves like
     instances of other *Note Mailbox: 1914. subclasses, set `factory'
     to `None'.

     Maildir is a directory-based mailbox format invented for the qmail
     mail transfer agent and now widely supported by other programs.
     Messages in a Maildir mailbox are stored in separate files within
     a common directory structure. This design allows Maildir mailboxes
     to be accessed and modified by multiple unrelated programs without
     data corruption, so file locking is unnecessary.

     Maildir mailboxes contain three subdirectories, namely: `tmp',
     `new', and `cur'. Messages are created momentarily in the `tmp'
     subdirectory and then moved to the `new' subdirectory to finalize
     delivery. A mail user agent may subsequently move the message to
     the `cur' subdirectory and store information about the state of
     the message in a special “info” section appended to its file
     name.

     Folders of the style introduced by the Courier mail transfer agent
     are also supported. Any subdirectory of the main mailbox is
     considered a folder if `'.'' is the first character in its name.
     Folder names are represented by *Note Maildir: 238. without the
     leading `'.''. Each folder is itself a Maildir mailbox but should
     not contain other folders. Instead, a logical nesting is indicated
     using `'.'' to delimit levels, e.g., “Archived.2005.07”.

          Note: The Maildir specification requires the use of a colon
          (`':'') in certain message file names. However, some
          operating systems do not permit this character in file names,
          If you wish to use a Maildir-like format on such an operating
          system, you should specify another character to use instead.
          The exclamation point (`'!'') is a popular choice. For
          example:

              import mailbox
              mailbox.Maildir.colon = '!'

          The `colon' attribute may also be set on a per-instance basis.

     *Note Maildir: 238. instances have all of the methods of *Note
     Mailbox: 1914. in addition to the following:

      -- Method: list_folders ()
          Return a list of the names of all folders.

      -- Method: get_folder (folder)
          Return a *Note Maildir: 238. instance representing the folder
          whose name is `folder'. A *Note NoSuchMailboxError: 193d.
          exception is raised if the folder does not exist.

      -- Method: add_folder (folder)
          Create a folder whose name is `folder' and return a *Note
          Maildir: 238.  instance representing it.

      -- Method: remove_folder (folder)
          Delete the folder whose name is `folder'. If the folder
          contains any messages, a *Note NotEmptyError: 1940. exception
          will be raised and the folder will not be deleted.

      -- Method: clean ()
          Delete temporary files from the mailbox that have not been
          accessed in the last 36 hours. The Maildir specification says
          that mail-reading programs should do this occasionally.

     Some *Note Mailbox: 1914. methods implemented by *Note Maildir:
     238. deserve special remarks:

      -- Method: add (message)
      -- Method: __setitem__ (key, message)
      -- Method: update (arg)
               Warning: These methods generate unique file names based
               upon the current process ID. When using multiple
               threads, undetected name clashes may occur and cause
               corruption of the mailbox unless threads are coordinated
               to avoid using these methods to manipulate the same
               mailbox simultaneously.

      -- Method: flush ()
          All changes to Maildir mailboxes are immediately applied, so
          this method does nothing.

      -- Method: lock ()
      -- Method: unlock ()
          Maildir mailboxes do not support (or require) locking, so
          these methods do nothing.

      -- Method: close ()
          *Note Maildir: 238. instances do not keep any open files and
          the underlying mailboxes do not support locking, so this
          method does nothing.

      -- Method: get_file (key)
          Depending upon the host platform, it may not be possible to
          modify or remove the underlying message while the returned
          file remains open.

See also
........

maildir man page from qmail(1)
     The original specification of the format.

Using maildir format(2)
     Notes on Maildir by its inventor. Includes an updated
     name-creation scheme and details on “info” semantics.

maildir man page from Courier(3)
     Another specification of the format. Describes a common extension
     for supporting folders.

---------- Footnotes ----------

(1) http://www.qmail.org/man/man5/maildir.html

(2) https://cr.yp.to/proto/maildir.html

(3) http://www.courier-mta.org/maildir.html


File: python.info,  Node: mbox,  Next: MH,  Prev: Maildir,  Up: Mailbox objects

5.18.4.3 `mbox'
...............

 -- Class: mailbox.mbox (path, factory=None, create=True)
     A subclass of *Note Mailbox: 1914. for mailboxes in mbox format.
     Parameter `factory' is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation. If `factory' is `None', *Note
     mboxMessage: 191d. is used as the default message representation.
     If `create' is `True', the mailbox is created if it does not exist.

     The mbox format is the classic format for storing mail on Unix
     systems. All messages in an mbox mailbox are stored in a single
     file with the beginning of each message indicated by a line whose
     first five characters are “From “.

     Several variations of the mbox format exist to address perceived
     shortcomings in the original. In the interest of compatibility,
     *Note mbox: 191e. implements the original format, which is
     sometimes referred to as `mboxo'. This means that the
     `Content-Length' header, if present, is ignored and that any
     occurrences of “From ” at the beginning of a line in a message
     body are transformed to “>From ” when storing the message,
     although occurrences of “>From ” are not transformed to
     “From ” when reading the message.

     Some *Note Mailbox: 1914. methods implemented by *Note mbox: 191e.
     deserve special remarks:

      -- Method: get_file (key)
          Using the file after calling `flush()' or `close()' on the
          *Note mbox: 191e. instance may yield unpredictable results or
          raise an exception.

      -- Method: lock ()
      -- Method: unlock ()
          Three locking mechanisms are used—dot locking and, if
          available, the `flock()' and `lockf()' system calls.

See also
........

mbox man page from qmail(1)
     A specification of the format and its variations.

mbox man page from tin(2)
     Another specification of the format, with details on locking.

Configuring Netscape Mail on Unix: Why The Content-Length Format is Bad(3)
     An argument for using the original mbox format rather than a
     variation.

"mbox" is a family of several mutually incompatible mailbox formats(4)
     A history of mbox variations.

---------- Footnotes ----------

(1) http://www.qmail.org/man/man5/mbox.html

(2) http://www.tin.org/bin/man.cgi?section=5&topic=mbox

(3) https://www.jwz.org/doc/content-length.html

(4)
http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/mail-mbox-formats.html


File: python.info,  Node: MH,  Next: Babyl,  Prev: mbox,  Up: Mailbox objects

5.18.4.4 `MH'
.............

 -- Class: mailbox.MH (path, factory=None, create=True)
     A subclass of *Note Mailbox: 1914. for mailboxes in MH format.
     Parameter `factory' is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation. If `factory' is `None', *Note
     MHMessage: 1952. is used as the default message representation. If
     `create' is `True', the mailbox is created if it does not exist.

     MH is a directory-based mailbox format invented for the MH Message
     Handling System, a mail user agent. Each message in an MH mailbox
     resides in its own file. An MH mailbox may contain other MH
     mailboxes (called `folders') in addition to messages. Folders may
     be nested indefinitely. MH mailboxes also support `sequences',
     which are named lists used to logically group messages without
     moving them to sub-folders. Sequences are defined in a file called
     `.mh_sequences' in each folder.

     The *Note MH: 1951. class manipulates MH mailboxes, but it does
     not attempt to emulate all of `mh'’s behaviors. In particular,
     it does not modify and is not affected by the `context' or
     `.mh_profile' files that are used by `mh' to store its state and
     configuration.

     *Note MH: 1951. instances have all of the methods of *Note
     Mailbox: 1914. in addition to the following:

      -- Method: list_folders ()
          Return a list of the names of all folders.

      -- Method: get_folder (folder)
          Return an *Note MH: 1951. instance representing the folder
          whose name is `folder'. A *Note NoSuchMailboxError: 193d.
          exception is raised if the folder does not exist.

      -- Method: add_folder (folder)
          Create a folder whose name is `folder' and return an *Note
          MH: 1951. instance representing it.

      -- Method: remove_folder (folder)
          Delete the folder whose name is `folder'. If the folder
          contains any messages, a *Note NotEmptyError: 1940. exception
          will be raised and the folder will not be deleted.

      -- Method: get_sequences ()
          Return a dictionary of sequence names mapped to key lists. If
          there are no sequences, the empty dictionary is returned.

      -- Method: set_sequences (sequences)
          Re-define the sequences that exist in the mailbox based upon
          `sequences', a dictionary of names mapped to key lists, like
          returned by *Note get_sequences(): 1957.

      -- Method: pack ()
          Rename messages in the mailbox as necessary to eliminate gaps
          in numbering.  Entries in the sequences list are updated
          correspondingly.

               Note: Already-issued keys are invalidated by this
               operation and should not be subsequently used.

     Some *Note Mailbox: 1914. methods implemented by *Note MH: 1951.
     deserve special remarks:

      -- Method: remove (key)
      -- Method: __delitem__ (key)
      -- Method: discard (key)
          These methods immediately delete the message. The MH
          convention of marking a message for deletion by prepending a
          comma to its name is not used.

      -- Method: lock ()
      -- Method: unlock ()
          Three locking mechanisms are used—dot locking and, if
          available, the `flock()' and `lockf()' system calls. For MH
          mailboxes, locking the mailbox means locking the
          `.mh_sequences' file and, only for the duration of any
          operations that affect them, locking individual message files.

      -- Method: get_file (key)
          Depending upon the host platform, it may not be possible to
          remove the underlying message while the returned file remains
          open.

      -- Method: flush ()
          All changes to MH mailboxes are immediately applied, so this
          method does nothing.

      -- Method: close ()
          *Note MH: 1951. instances do not keep any open files, so this
          method is equivalent to *Note unlock(): 195e.

See also
........

nmh - Message Handling System(1)
     Home page of `nmh', an updated version of the original `mh'.

MH & nmh: Email for Users & Programmers(2)
     A GPL-licensed book on `mh' and `nmh', with some information on
     the mailbox format.

---------- Footnotes ----------

(1) http://www.nongnu.org/nmh/

(2) http://rand-mh.sourceforge.net/book/


File: python.info,  Node: Babyl,  Next: MMDF,  Prev: MH,  Up: Mailbox objects

5.18.4.5 `Babyl'
................

 -- Class: mailbox.Babyl (path, factory=None, create=True)
     A subclass of *Note Mailbox: 1914. for mailboxes in Babyl format.
     Parameter `factory' is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation.  If `factory' is `None',
     *Note BabylMessage: 1965. is used as the default message
     representation. If `create' is `True', the mailbox is created if
     it does not exist.

     Babyl is a single-file mailbox format used by the Rmail mail user
     agent included with Emacs. The beginning of a message is indicated
     by a line containing the two characters Control-Underscore
     (`'\037'') and Control-L (`'\014''). The end of a message is
     indicated by the start of the next message or, in the case of the
     last message, a line containing a Control-Underscore (`'\037'')
     character.

     Messages in a Babyl mailbox have two sets of headers, original
     headers and so-called visible headers. Visible headers are
     typically a subset of the original headers that have been
     reformatted or abridged to be more attractive. Each message in a
     Babyl mailbox also has an accompanying list of `labels', or short
     strings that record extra information about the message, and a
     list of all user-defined labels found in the mailbox is kept in
     the Babyl options section.

     *Note Babyl: 1964. instances have all of the methods of *Note
     Mailbox: 1914. in addition to the following:

      -- Method: get_labels ()
          Return a list of the names of all user-defined labels used in
          the mailbox.

               Note: The actual messages are inspected to determine
               which labels exist in the mailbox rather than consulting
               the list of labels in the Babyl options section, but the
               Babyl section is updated whenever the mailbox is
               modified.

     Some *Note Mailbox: 1914. methods implemented by *Note Babyl:
     1964. deserve special remarks:

      -- Method: get_file (key)
          In Babyl mailboxes, the headers of a message are not stored
          contiguously with the body of the message. To generate a
          file-like representation, the headers and body are copied
          together into a *Note StringIO: 2df. instance (from the *Note
          StringIO: 164. module), which has an API identical to that of
          a file. As a result, the file-like object is truly
          independent of the underlying mailbox but does not save
          memory compared to a string representation.

      -- Method: lock ()
      -- Method: unlock ()
          Three locking mechanisms are used—dot locking and, if
          available, the `flock()' and `lockf()' system calls.

See also
........

Format of Version 5 Babyl Files(1)
     A specification of the Babyl format.

Reading Mail with Rmail(2)
     The Rmail manual, with some information on Babyl semantics.

---------- Footnotes ----------

(1) https://quimby.gnus.org/notes/BABYL

(2) https://www.gnu.org/software/emacs/manual/html_node/emacs/Rmail.html


File: python.info,  Node: MMDF,  Prev: Babyl,  Up: Mailbox objects

5.18.4.6 `MMDF'
...............

 -- Class: mailbox.MMDF (path, factory=None, create=True)
     A subclass of *Note Mailbox: 1914. for mailboxes in MMDF format.
     Parameter `factory' is a callable object that accepts a file-like
     message representation (which behaves as if opened in binary mode)
     and returns a custom representation. If `factory' is `None', *Note
     MMDFMessage: 196d. is used as the default message representation.
     If `create' is `True', the mailbox is created if it does not exist.

     MMDF is a single-file mailbox format invented for the Multichannel
     Memorandum Distribution Facility, a mail transfer agent. Each
     message is in the same form as an mbox message but is bracketed
     before and after by lines containing four Control-A (`'\001'')
     characters. As with the mbox format, the beginning of each message
     is indicated by a line whose first five characters are “From
     “, but additional occurrences of “From ” are not transformed
     to “>From ” when storing messages because the extra message
     separator lines prevent mistaking such occurrences for the starts
     of subsequent messages.

     Some *Note Mailbox: 1914. methods implemented by *Note MMDF: 196c.
     deserve special remarks:

      -- Method: get_file (key)
          Using the file after calling `flush()' or `close()' on the
          *Note MMDF: 196c. instance may yield unpredictable results or
          raise an exception.

      -- Method: lock ()
      -- Method: unlock ()
          Three locking mechanisms are used—dot locking and, if
          available, the `flock()' and `lockf()' system calls.

See also
........

mmdf man page from tin(1)
     A specification of MMDF format from the documentation of tin, a
     newsreader.

MMDF(2)
     A Wikipedia article describing the Multichannel Memorandum
     Distribution Facility.

---------- Footnotes ----------

(1) http://www.tin.org/bin/man.cgi?section=5&topic=mmdf

(2) https://en.wikipedia.org/wiki/MMDF


File: python.info,  Node: Message objects,  Next: Exceptions<5>,  Prev: Mailbox objects,  Up: mailbox — Manipulate mailboxes in various formats

5.18.4.7 `Message' objects
..........................

 -- Class: mailbox.Message ([message])
     A subclass of the *Note email.message: c2. module’s *Note
     Message: 216. Subclasses of *Note mailbox.Message: 1915. add
     mailbox-format-specific state and behavior.

     If `message' is omitted, the new instance is created in a default,
     empty state.  If `message' is an *Note email.message.Message: 216.
     instance, its contents are copied; furthermore, any
     format-specific information is converted insofar as possible if
     `message' is a *Note Message: 1915. instance. If `message' is a
     string or a file, it should contain an RFC 2822(1)-compliant
     message, which is read and parsed.

     The format-specific state and behaviors offered by subclasses
     vary, but in general it is only the properties that are not
     specific to a particular mailbox that are supported (although
     presumably the properties are specific to a particular mailbox
     format). For example, file offsets for single-file mailbox formats
     and file names for directory-based mailbox formats are not
     retained, because they are only applicable to the original
     mailbox. But state such as whether a message has been read by the
     user or marked as important is retained, because it applies to the
     message itself.

     There is no requirement that *Note Message: 1915. instances be
     used to represent messages retrieved using *Note Mailbox: 1914.
     instances. In some situations, the time and memory required to
     generate *Note Message: 1915. representations might not be
     acceptable. For such situations, *Note Mailbox: 1914. instances
     also offer string and file-like representations, and a custom
     message factory may be specified when a *Note Mailbox: 1914.
     instance is initialized.

* Menu:

* MaildirMessage::
* mboxMessage::
* MHMessage::
* BabylMessage::
* MMDFMessage::

---------- Footnotes ----------

(1) https://tools.ietf.org/html/rfc2822.html


File: python.info,  Node: MaildirMessage,  Next: mboxMessage,  Up: Message objects

5.18.4.8 `MaildirMessage'
.........................

 -- Class: mailbox.MaildirMessage ([message])
     A message with Maildir-specific behaviors. Parameter `message' has
     the same meaning as with the *Note Message: 1915. constructor.

     Typically, a mail user agent application moves all of the messages
     in the `new' subdirectory to the `cur' subdirectory after the
     first time the user opens and closes the mailbox, recording that
     the messages are old whether or not they’ve actually been read.
     Each message in `cur' has an “info” section added to its file
     name to store information about its state.  (Some mail readers may
     also add an “info” section to messages in `new'.)  The
     “info” section may take one of two forms: it may contain
     “2,” followed by a list of standardized flags (e.g.,
     “2,FR”) or it may contain “1,” followed by so-called
     experimental information. Standard flags for Maildir messages are
     as follows:

     Flag       Meaning       Explanation
     -------------------------------------------------------------- 
     D          Draft         Under composition
     F          Flagged       Marked as important
     P          Passed        Forwarded, resent, or bounced
     R          Replied       Replied to
     S          Seen          Read
     T          Trashed       Marked for subsequent deletion

     *Note MaildirMessage: 1939. instances offer the following methods:

      -- Method: get_subdir ()
          Return either “new” (if the message should be stored in
          the `new' subdirectory) or “cur” (if the message should
          be stored in the `cur' subdirectory).

               Note: A message is typically moved from `new' to `cur'
               after its mailbox has been accessed, whether or not the
               message is has been read. A message `msg' has been read
               if `"S" in msg.get_flags()' is `True'.

      -- Method: set_subdir (subdir)
          Set the subdirectory the message should be stored in.
          Parameter `subdir' must be either “new” or “cur”.

      -- Method: get_flags ()
          Return a string specifying the flags that are currently set.
          If the message complies with the standard Maildir format, the
          result is the concatenation in alphabetical order of zero or
          one occurrence of each of `'D'', `'F'', `'P'', `'R'', `'S'',
          and `'T''. The empty string is returned if no flags are set
          or if “info” contains experimental semantics.

      -- Method: set_flags (flags)
          Set the flags specified by `flags' and unset all others.

      -- Method: add_flag (flag)
          Set the flag(s) specified by `flag' without changing other
          flags. To add more than one flag at a time, `flag' may be a
          string of more than one character. The current “info” is
          overwritten whether or not it contains experimental
          information rather than flags.

      -- Method: remove_flag (flag)
          Unset the flag(s) specified by `flag' without changing other
          flags. To remove more than one flag at a time, `flag' maybe a
          string of more than one character.  If “info” contains
          experimental information rather than flags, the current
          “info” is not modified.

      -- Method: get_date ()
          Return the delivery date of the message as a floating-point
          number representing seconds since the epoch.

      -- Method: set_date (date)
          Set the delivery date of the message to `date', a
          floating-point number representing seconds since the epoch.

      -- Method: get_info ()
          Return a string containing the “info” for a message. This
          is useful for accessing and modifying “info” that is
          experimental (i.e., not a list of flags).

      -- Method: set_info (info)
          Set “info” to `info', which should be a string.

When a *Note MaildirMessage: 1939. instance is created based upon an
*Note mboxMessage: 191d. or *Note MMDFMessage: 196d. instance, the
`Status' and `X-Status' headers are omitted and the following
conversions take place:

Resulting state          *Note mboxMessage: 191d. or *Note MMDFMessage:
                         196d.  state
---------------------------------------------------------------------------- 
“cur” subdirectory   O flag
F flag                   F flag
R flag                   A flag
S flag                   R flag
T flag                   D flag

When a *Note MaildirMessage: 1939. instance is created based upon an
*Note MHMessage: 1952. instance, the following conversions take place:

Resulting state                     *Note MHMessage: 1952. state
------------------------------------------------------------------- 
“cur” subdirectory              “unseen” sequence
“cur” subdirectory and S flag   no “unseen” sequence
F flag                              “flagged” sequence
R flag                              “replied” sequence

When a *Note MaildirMessage: 1939. instance is created based upon a
*Note BabylMessage: 1965. instance, the following conversions take
place:

Resulting state                     *Note BabylMessage: 1965. state
------------------------------------------------------------------------ 
“cur” subdirectory              “unseen” label
“cur” subdirectory and S flag   no “unseen” label
P flag                              “forwarded” or “resent”
                                    label
R flag                              “answered” label
T flag                              “deleted” label


File: python.info,  Node: mboxMessage,  Next: MHMessage,  Prev: MaildirMessage,  Up: Message objects

5.18.4.9 `mboxMessage'
......................

 -- Class: mailbox.mboxMessage ([message])
     A message with mbox-specific behaviors. Parameter `message' has
     the same meaning as with the *Note Message: 1915. constructor.

     Messages in an mbox mailbox are stored together in a single file.
     The sender’s envelope address and the time of delivery are
     typically stored in a line beginning with “From ” that is used
     to indicate the start of a message, though there is considerable
     variation in the exact format of this data among mbox
     implementations. Flags that indicate the state of the message,
     such as whether it has been read or marked as important, are
     typically stored in `Status' and `X-Status' headers.

     Conventional flags for mbox messages are as follows:

     Flag       Meaning        Explanation
     --------------------------------------------------------------- 
     R          Read           Read
     O          Old            Previously detected by MUA
     D          Deleted        Marked for subsequent deletion
     F          Flagged        Marked as important
     A          Answered       Replied to

     The “R” and “O” flags are stored in the `Status' header,
     and the “D”, “F”, and “A” flags are stored in the
     `X-Status' header. The flags and headers typically appear in the
     order mentioned.

     *Note mboxMessage: 191d. instances offer the following methods:

      -- Method: get_from ()
          Return a string representing the “From ” line that marks
          the start of the message in an mbox mailbox. The leading
          “From ” and the trailing newline are excluded.

      -- Method: set_from (from_, time_=None)
          Set the “From ” line to `from_', which should be
          specified without a leading “From ” or trailing newline.
          For convenience, `time_' may be specified and will be
          formatted appropriately and appended to `from_'. If `time_'
          is specified, it should be a *Note time.struct_time: b18.
          instance, a tuple suitable for passing to *Note
          time.strftime(): 3d8, or `True' (to use *Note time.gmtime():
          b7f.).

      -- Method: get_flags ()
          Return a string specifying the flags that are currently set.
          If the message complies with the conventional format, the
          result is the concatenation in the following order of zero or
          one occurrence of each of `'R'', `'O'', `'D'', `'F'', and
          `'A''.

      -- Method: set_flags (flags)
          Set the flags specified by `flags' and unset all others.
          Parameter `flags' should be the concatenation in any order of
          zero or more occurrences of each of `'R'', `'O'', `'D'',
          `'F'', and `'A''.

      -- Method: add_flag (flag)
          Set the flag(s) specified by `flag' without changing other
          flags. To add more than one flag at a time, `flag' may be a
          string of more than one character.

      -- Method: remove_flag (flag)
          Unset the flag(s) specified by `flag' without changing other
          flags. To remove more than one flag at a time, `flag' maybe a
          string of more than one character.

When an *Note mboxMessage: 191d. instance is created based upon a *Note
MaildirMessage: 1939. instance, a “From ” line is generated based
upon the *Note MaildirMessage: 1939. instance’s delivery date, and
the following conversions take place:

Resulting state       *Note MaildirMessage: 1939. state
---------------------------------------------------------- 
R flag                S flag
O flag                “cur” subdirectory
D flag                T flag
F flag                F flag
A flag                R flag

When an *Note mboxMessage: 191d. instance is created based upon an
*Note MHMessage: 1952. instance, the following conversions take place:

Resulting state         *Note MHMessage: 1952. state
------------------------------------------------------- 
R flag and O flag       no “unseen” sequence
O flag                  “unseen” sequence
F flag                  “flagged” sequence
A flag                  “replied” sequence

When an *Note mboxMessage: 191d. instance is created based upon a *Note
BabylMessage: 1965. instance, the following conversions take place:

Resulting state         *Note BabylMessage: 1965. state
---------------------------------------------------------- 
R flag and O flag       no “unseen” label
O flag                  “unseen” label
D flag                  “deleted” label
A flag                  “answered” label

When a *Note Message: 1915. instance is created based upon an *Note
MMDFMessage: 196d.  instance, the “From ” line is copied and all
flags directly correspond:

Resulting state       *Note MMDFMessage: 196d. state
------------------------------------------------------- 
R flag                R flag
O flag                O flag
D flag                D flag
F flag                F flag
A flag                A flag


File: python.info,  Node: MHMessage,  Next: BabylMessage,  Prev: mboxMessage,  Up: Message objects

5.18.4.10 `MHMessage'
.....................

 -- Class: mailbox.MHMessage ([message])
     A message with MH-specific behaviors. Parameter `message' has the
     same meaning as with the *Note Message: 1915. constructor.

     MH messages do not support marks or flags in the traditional
     sense, but they do support sequences, which are logical groupings
     of arbitrary messages. Some mail reading programs (although not
     the standard `mh' and `nmh') use sequences in much the same way
     flags are used with other formats, as follows:

     Sequence       Explanation
     -------------------------------------------------------------- 
     unseen         Not read, but previously detected by MUA
     replied        Replied to
     flagged        Marked as important

     *Note MHMessage: 1952. instances offer the following methods:

      -- Method: get_sequences ()
          Return a list of the names of sequences that include this
          message.

      -- Method: set_sequences (sequences)
          Set the list of sequences that include this message.

      -- Method: add_sequence (sequence)
          Add `sequence' to the list of sequences that include this
          message.

      -- Method: remove_sequence (sequence)
          Remove `sequence' from the list of sequences that include
          this message.

When an *Note MHMessage: 1952. instance is created based upon a *Note
MaildirMessage: 1939. instance, the following conversions take place:

Resulting state          *Note MaildirMessage: 1939. state
------------------------------------------------------------- 
“unseen” sequence    no S flag
“replied” sequence   R flag
“flagged” sequence   F flag

When an *Note MHMessage: 1952. instance is created based upon an *Note
mboxMessage: 191d. or *Note MMDFMessage: 196d. instance, the `Status'
and `X-Status' headers are omitted and the following conversions take
place:

Resulting state          *Note mboxMessage: 191d. or *Note MMDFMessage:
                         196d.  state
---------------------------------------------------------------------------- 
“unseen” sequence    no R flag
“replied” sequence   A flag
“flagged” sequence   F flag

When an *Note MHMessage: 1952. instance is created based upon a *Note
BabylMessage: 1965. instance, the following conversions take place:

Resulting state          *Note BabylMessage: 1965. state
----------------------------------------------------------- 
“unseen” sequence    “unseen” label
“replied” sequence   “answered” label


File: python.info,  Node: BabylMessage,  Next: MMDFMessage,  Prev: MHMessage,  Up: Message objects

5.18.4.11 `BabylMessage'
........................

 -- Class: mailbox.BabylMessage ([message])
     A message with Babyl-specific behaviors. Parameter `message' has
     the same meaning as with the *Note Message: 1915. constructor.

     Certain message labels, called `attributes', are defined by
     convention to have special meanings. The attributes are as follows:

     Label           Explanation
     --------------------------------------------------------------- 
     unseen          Not read, but previously detected by MUA
     deleted         Marked for subsequent deletion
     filed           Copied to another file or mailbox
     answered        Replied to
     forwarded       Forwarded
     edited          Modified by the user
     resent          Resent

     By default, Rmail displays only visible headers. The *Note
     BabylMessage: 1965.  class, though, uses the original headers
     because they are more complete. Visible headers may be accessed
     explicitly if desired.

     *Note BabylMessage: 1965. instances offer the following methods:

      -- Method: get_labels ()
          Return a list of labels on the message.

      -- Method: set_labels (labels)
          Set the list of labels on the message to `labels'.

      -- Method: add_label (label)
          Add `label' to the list of labels on the message.

      -- Method: remove_label (label)
          Remove `label' from the list of labels on the message.

      -- Method: get_visible ()
          Return an *Note Message: 1915. instance whose headers are the
          message’s visible headers and whose body is empty.

      -- Method: set_visible (visible)
          Set the message’s visible headers to be the same as the
          headers in `message'.  Parameter `visible' should be a *Note
          Message: 1915. instance, an *Note email.message.Message: 216.
          instance, a string, or a file-like object (which should be
          open in text mode).

      -- Method: update_visible ()
          When a *Note BabylMessage: 1965. instance’s original
          headers are modified, the visible headers are not
          automatically modified to correspond. This method updates the
          visible headers as follows: each visible header with a
          corresponding original header is set to the value of the
          original header, each visible header without a corresponding
          original header is removed, and any of `Date', `From',
          `Reply-To', `To', `CC', and `Subject' that are present in the
          original headers but not the visible headers are added to the
          visible headers.

When a *Note BabylMessage: 1965. instance is created based upon a *Note
MaildirMessage: 1939. instance, the following conversions take place:

Resulting state         *Note MaildirMessage: 1939. state
------------------------------------------------------------ 
“unseen” label      no S flag
“deleted” label     T flag
“answered” label    R flag
“forwarded” label   P flag

When a *Note BabylMessage: 1965. instance is created based upon an
*Note mboxMessage: 191d. or *Note MMDFMessage: 196d. instance, the
`Status' and `X-Status' headers are omitted and the following
conversions take place:

Resulting state        *Note mboxMessage: 191d. or *Note MMDFMessage:
                       196d.  state
-------------------------------------------------------------------------- 
“unseen” label     no R flag
“deleted” label    D flag
“answered” label   A flag

When a *Note BabylMessage: 1965. instance is created based upon an
*Note MHMessage: 1952. instance, the following conversions take place:

Resulting state        *Note MHMessage: 1952. state
------------------------------------------------------ 
“unseen” label     “unseen” sequence
“answered” label   “replied” sequence


File: python.info,  Node: MMDFMessage,  Prev: BabylMessage,  Up: Message objects

5.18.4.12 `MMDFMessage'
.......................

 -- Class: mailbox.MMDFMessage ([message])
     A message with MMDF-specific behaviors. Parameter `message' has
     the same meaning as with the *Note Message: 1915. constructor.

     As with message in an mbox mailbox, MMDF messages are stored with
     the sender’s address and the delivery date in an initial line
     beginning with “From “.  Likewise, flags that indicate the
     state of the message are typically stored in `Status' and
     `X-Status' headers.

     Conventional flags for MMDF messages are identical to those of
     mbox message and are as follows:

     Flag       Meaning        Explanation
     --------------------------------------------------------------- 
     R          Read           Read
     O          Old            Previously detected by MUA
     D          Deleted        Marked for subsequent deletion
     F          Flagged        Marked as important
     A          Answered       Replied to

     The “R” and “O” flags are stored in the `Status' header,
     and the “D”, “F”, and “A” flags are stored in the
     `X-Status' header. The flags and headers typically appear in the
     order mentioned.

     *Note MMDFMessage: 196d. instances offer the following methods,
     which are identical to those offered by *Note mboxMessage: 191d.:

      -- Method: get_from ()
          Return a string representing the “From ” line that marks
          the start of the message in an mbox mailbox. The leading
          “From ” and the trailing newline are excluded.

      -- Method: set_from (from_, time_=None)
          Set the “From ” line to `from_', which should be
          specified without a leading “From ” or trailing newline.
          For convenience, `time_' may be specified and will be
          formatted appropriately and appended to `from_'. If `time_'
          is specified, it should be a *Note time.struct_time: b18.
          instance, a tuple suitable for passing to *Note
          time.strftime(): 3d8, or `True' (to use *Note time.gmtime():
          b7f.).

      -- Method: get_flags ()
          Return a string specifying the flags that are currently set.
          If the message complies with the conventional format, the
          result is the concatenation in the following order of zero or
          one occurrence of each of `'R'', `'O'', `'D'', `'F'', and
          `'A''.

      -- Method: set_flags (flags)
          Set the flags specified by `flags' and unset all others.
          Parameter `flags' should be the concatenation in any order of
          zero or more occurrences of each of `'R'', `'O'', `'D'',
          `'F'', and `'A''.

      -- Method: add_flag (flag)
          Set the flag(s) specified by `flag' without changing other
          flags. To add more than one flag at a time, `flag' may be a
          string of more than one character.

      -- Method: remove_flag (flag)
          Unset the flag(s) specified by `flag' without changing other
          flags. To remove more than one flag at a time, `flag' maybe a
          string of more than one character.

When an *Note MMDFMessage: 196d. instance is created based upon a *Note
MaildirMessage: 1939. instance, a “From ” line is generated based
upon the *Note MaildirMessage: 1939. instance’s delivery date, and
the following conversions take place:

Resulting state       *Note MaildirMessage: 1939. state
---------------------------------------------------------- 
R flag                S flag
O flag                “cur” subdirectory
D flag                T flag
F flag                F flag
A flag                R flag

When an *Note MMDFMessage: 196d. instance is created based upon an
*Note MHMessage: 1952. instance, the following conversions take place:

Resulting state         *Note MHMessage: 1952. state
------------------------------------------------------- 
R flag and O flag       no “unseen” sequence
O flag                  “unseen” sequence
F flag                  “flagged” sequence
A flag                  “replied” sequence

When an *Note MMDFMessage: 196d. instance is created based upon a *Note
BabylMessage: 1965. instance, the following conversions take place:

Resulting state         *Note BabylMessage: 1965. state
---------------------------------------------------------- 
R flag and O flag       no “unseen” label
O flag                  “unseen” label
D flag                  “deleted” label
A flag                  “answered” label

When an *Note MMDFMessage: 196d. instance is created based upon an
*Note mboxMessage: 191d. instance, the “From ” line is copied and
all flags directly correspond:

Resulting state       *Note mboxMessage: 191d. state
------------------------------------------------------- 
R flag                R flag
O flag                O flag
D flag                D flag
F flag                F flag
A flag                A flag


File: python.info,  Node: Exceptions<5>,  Next: Deprecated classes and methods,  Prev: Message objects,  Up: mailbox — Manipulate mailboxes in various formats

5.18.4.13 Exceptions
....................

The following exception classes are defined in the *Note mailbox: 10a.
module:

 -- Exception: mailbox.Error
     The based class for all other module-specific exceptions.

 -- Exception: mailbox.NoSuchMailboxError
     Raised when a mailbox is expected but is not found, such as when
     instantiating a *Note Mailbox: 1914. subclass with a path that
     does not exist (and with the `create' parameter set to `False'),
     or when opening a folder that does not exist.

 -- Exception: mailbox.NotEmptyError
     Raised when a mailbox is not empty but is expected to be, such as
     when deleting a folder that contains messages.

 -- Exception: mailbox.ExternalClashError
     Raised when some mailbox-related condition beyond the control of
     the program causes it to be unable to proceed, such as when
     failing to acquire a lock that another program already holds a
     lock, or when a uniquely-generated file name already exists.

 -- Exception: mailbox.FormatError
     Raised when the data in a file cannot be parsed, such as when an
     *Note MH: 1951.  instance attempts to read a corrupted
     `.mh_sequences' file.


File: python.info,  Node: Deprecated classes and methods,  Next: Examples<9>,  Prev: Exceptions<5>,  Up: mailbox — Manipulate mailboxes in various formats

5.18.4.14 Deprecated classes and methods
........................................

Deprecated since version 2.6.

Older versions of the *Note mailbox: 10a. module do not support
modification of mailboxes, such as adding or removing message, and do
not provide classes to represent format-specific message properties.
For backward compatibility, the older mailbox classes are still
available, but the newer classes should be used in preference to them.
The old classes have been removed in Python 3.

Older mailbox objects support only iteration and provide a single
public method:

 -- Method: oldmailbox.next ()
     Return the next message in the mailbox, created with the optional
     `factory' argument passed into the mailbox object’s constructor.
     By default this is an *Note rfc822.Message: 193a. object (see the
     *Note rfc822: 148. module).  Depending on the mailbox
     implementation the `fp' attribute of this object may be a true file
     object or a class instance simulating a file object, taking care
     of things like message boundaries if multiple mail messages are
     contained in a single file, etc.  If no more messages are
     available, this method returns `None'.

Most of the older mailbox classes have names that differ from the
current mailbox class names, except for *Note Maildir: 238. For this
reason, the new *Note Maildir: 238. class defines a `next()' method and
its constructor differs slightly from those of the other new mailbox
classes.

The older mailbox classes whose names are not the same as their newer
counterparts are as follows:

 -- Class: mailbox.UnixMailbox (fp[, factory])
     Access to a classic Unix-style mailbox, where all messages are
     contained in a single file and separated by `From' (a.k.a.
     `From_') lines.  The file object `fp' points to the mailbox file.
     The optional `factory' parameter is a callable that should create
     new message objects.  `factory' is called with one argument, `fp'
     by the `next()' method of the mailbox object.  The default is the
     *Note rfc822.Message: 193a. class (see the *Note rfc822: 148.
     module – and the note below).

          Note: For reasons of this module’s internal implementation,
          you will probably want to open the `fp' object in binary
          mode.  This is especially important on Windows.

     For maximum portability, messages in a Unix-style mailbox are
     separated by any line that begins exactly with the string `'From
     '' (note the trailing space) if preceded by exactly two newlines.
     Because of the wide-range of variations in practice, nothing else
     on the `From_' line should be considered.  However, the current
     implementation doesn’t check for the leading two newlines.  This
     is usually fine for most applications.

     The *Note UnixMailbox: 19a4. class implements a more strict
     version of `From_' line checking, using a regular expression that
     usually correctly matched `From_' delimiters.  It considers
     delimiter line to be separated by `From name time' lines.  For
     maximum portability, use the *Note PortableUnixMailbox: 19a5.
     class instead.  This class is identical to *Note UnixMailbox:
     19a4. except that individual messages are separated by only `From'
     lines.

 -- Class: mailbox.PortableUnixMailbox (fp[, factory])
     A less-strict version of *Note UnixMailbox: 19a4, which considers
     only the `From' at the beginning of the line separating messages.
     The “`name' `time'” portion of the From line is ignored, to
     protect against some variations that are observed in practice.
     This works since lines in the message which begin with `'From ''
     are quoted by mail handling software at delivery-time.

 -- Class: mailbox.MmdfMailbox (fp[, factory])
     Access an MMDF-style mailbox, where all messages are contained in
     a single file and separated by lines consisting of 4 control-A
     characters.  The file object `fp' points to the mailbox file.
     Optional `factory' is as with the *Note UnixMailbox: 19a4. class.

 -- Class: mailbox.MHMailbox (dirname[, factory])
     Access an MH mailbox, a directory with each message in a separate
     file with a numeric name. The name of the mailbox directory is
     passed in `dirname'.  `factory' is as with the *Note UnixMailbox:
     19a4. class.

 -- Class: mailbox.BabylMailbox (fp[, factory])
     Access a Babyl mailbox, which is similar to an MMDF mailbox.  In
     Babyl format, each message has two sets of headers, the `original'
     headers and the `visible' headers.  The original headers appear
     before a line containing only `'*** EOOH ***''
     (End-Of-Original-Headers) and the visible headers appear after the
     `EOOH' line.  Babyl-compliant mail readers will show you only the
     visible headers, and *Note BabylMailbox: 19a8. objects will return
     messages containing only the visible headers.  You’ll have to do
     your own parsing of the mailbox file to get at the original
     headers.  Mail messages start with the EOOH line and end with a
     line containing only `'\037\014''.  `factory' is as with the *Note
     UnixMailbox: 19a4. class.

If you wish to use the older mailbox classes with the *Note email: bb.
module rather than the deprecated *Note rfc822: 148. module, you can do
so as follows:

    import email
    import email.Errors
    import mailbox

    def msgfactory(fp):
        try:
            return email.message_from_file(fp)
        except email.Errors.MessageParseError:
            # Don't return None since that will
            # stop the mailbox iterator
            return ''

    mbox = mailbox.UnixMailbox(fp, msgfactory)

Alternatively, if you know your mailbox contains only well-formed MIME
messages, you can simplify this to:

    import email
    import mailbox

    mbox = mailbox.UnixMailbox(fp, email.message_from_file)


File: python.info,  Node: Examples<9>,  Prev: Deprecated classes and methods,  Up: mailbox — Manipulate mailboxes in various formats

5.18.4.15 Examples
..................

A simple example of printing the subjects of all messages in a mailbox
that seem interesting:

    import mailbox
    for message in mailbox.mbox('~/mbox'):
        subject = message['subject']       # Could possibly be None.
        if subject and 'python' in subject.lower():
            print subject

To copy all mail from a Babyl mailbox to an MH mailbox, converting all
of the format-specific information that can be converted:

    import mailbox
    destination = mailbox.MH('~/Mail')
    destination.lock()
    for message in mailbox.Babyl('~/RMAIL'):
        destination.add(mailbox.MHMessage(message))
    destination.flush()
    destination.unlock()

This example sorts mail from several mailing lists into different
mailboxes, being careful to avoid mail corruption due to concurrent
modification by other programs, mail loss due to interruption of the
program, or premature termination due to malformed messages in the
mailbox:

    import mailbox
    import email.errors

    list_names = ('python-list', 'python-dev', 'python-bugs')

    boxes = dict((name, mailbox.mbox('~/email/%s' % name)) for name in list_names)
    inbox = mailbox.Maildir('~/Maildir', factory=None)

    for key in inbox.iterkeys():
        try:
            message = inbox[key]
        except email.errors.MessageParseError:
            continue                # The message is malformed. Just leave it.

        for name in list_names:
            list_id = message['list-id']
            if list_id and name in list_id:
                # Get mailbox to use
                box = boxes[name]

                # Write copy to disk before removing original.
                # If there's a crash, you might duplicate a message, but
                # that's better than losing a message completely.
                box.lock()
                box.add(message)
                box.flush()
                box.unlock()

                # Remove original message
                inbox.lock()
                inbox.discard(key)
                inbox.flush()
                inbox.unlock()
                break               # Found destination, so stop looking.

    for box in boxes.itervalues():
        box.close()


File: python.info,  Node: mhlib — Access to MH mailboxes,  Next: mimetools — Tools for parsing MIME messages,  Prev: mailbox — Manipulate mailboxes in various formats,  Up: Internet Data Handling

5.18.5 `mhlib' — Access to MH mailboxes
-----------------------------------------

Deprecated since version 2.6: The *Note mhlib: 10f. module has been
removed in Python 3. Use the *Note mailbox: 10a. instead.

The *Note mhlib: 10f. module provides a Python interface to MH folders
and their contents.

The module contains three basic classes, *Note MH: 19ad, which
represents a particular collection of folders, *Note Folder: 19ae,
which represents a single folder, and *Note Message: 19af, which
represents a single message.

 -- Class: mhlib.MH ([path[, profile]])
     *Note MH: 19ad. represents a collection of MH folders.

 -- Class: mhlib.Folder (mh, name)
     The *Note Folder: 19ae. class represents a single folder and its
     messages.

 -- Class: mhlib.Message (folder, number[, name])
     *Note Message: 19af. objects represent individual messages in a
     folder.  The Message class is derived from *Note
     mimetools.Message: 19b0.

* Menu:

* MH Objects::
* Folder Objects::
* Message Objects::


File: python.info,  Node: MH Objects,  Next: Folder Objects,  Up: mhlib — Access to MH mailboxes

5.18.5.1 MH Objects
...................

*Note MH: 19ad. instances have the following methods:

 -- Method: MH.error (format[, ...])
     Print an error message – can be overridden.

 -- Method: MH.getprofile (key)
     Return a profile entry (`None' if not set).

 -- Method: MH.getpath ()
     Return the mailbox pathname.

 -- Method: MH.getcontext ()
     Return the current folder name.

 -- Method: MH.setcontext (name)
     Set the current folder name.

 -- Method: MH.listfolders ()
     Return a list of top-level folders.

 -- Method: MH.listallfolders ()
     Return a list of all folders.

 -- Method: MH.listsubfolders (name)
     Return a list of direct subfolders of the given folder.

 -- Method: MH.listallsubfolders (name)
     Return a list of all subfolders of the given folder.

 -- Method: MH.makefolder (name)
     Create a new folder.

 -- Method: MH.deletefolder (name)
     Delete a folder – must have no subfolders.

 -- Method: MH.openfolder (name)
     Return a new open folder object.


File: python.info,  Node: Folder Objects,  Next: Message Objects,  Prev: MH Objects,  Up: mhlib — Access to MH mailboxes

5.18.5.2 Folder Objects
.......................

*Note Folder: 19ae. instances represent open folders and have the
following methods:

 -- Method: Folder.error (format[, ...])
     Print an error message – can be overridden.

 -- Method: Folder.getfullname ()
     Return the folder’s full pathname.

 -- Method: Folder.getsequencesfilename ()
     Return the full pathname of the folder’s sequences file.

 -- Method: Folder.getmessagefilename (n)
     Return the full pathname of message `n' of the folder.

 -- Method: Folder.listmessages ()
     Return a list of messages in the folder (as numbers).

 -- Method: Folder.getcurrent ()
     Return the current message number.

 -- Method: Folder.setcurrent (n)
     Set the current message number to `n'.

 -- Method: Folder.parsesequence (seq)
     Parse msgs syntax into list of messages.

 -- Method: Folder.getlast ()
     Get last message, or `0' if no messages are in the folder.

 -- Method: Folder.setlast (n)
     Set last message (internal use only).

 -- Method: Folder.getsequences ()
     Return dictionary of sequences in folder.  The sequence names are
     used  as keys, and the values are the lists of message numbers in
     the sequences.

 -- Method: Folder.putsequences (dict)
     Return dictionary of sequences in folder name: list.

 -- Method: Folder.removemessages (list)
     Remove messages in list from folder.

 -- Method: Folder.refilemessages (list, tofolder)
     Move messages in list to other folder.

 -- Method: Folder.movemessage (n, tofolder, ton)
     Move one message to a given destination in another folder.

 -- Method: Folder.copymessage (n, tofolder, ton)
     Copy one message to a given destination in another folder.

